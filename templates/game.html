<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Smart Farm Robot Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #container { width: 100vw; height: 100vh; }
        
        /* ========== HUDÊ†∑Âºè ========== */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            color: #fff;
        }
        
        /* Ë£ÖÂ§áÈù¢Êùø - Â∑¶‰∏äËßí */
        .equipment-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 15px;
            min-width: 280px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .current-equipment {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .equipment-icon {
            font-size: 32px;
        }
        
        .equipment-name {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .equipment-hotkeys {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .hotkey {
            padding: 8px 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            text-align: center;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: all;
        }
        
        .hotkey:hover {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }
        
        .hotkey.active {
            background: rgba(0, 255, 136, 0.5);
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .equipment-status .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .progress-bar {
            width: 120px;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .progress-fill.low {
            background: linear-gradient(90deg, #ff4444, #cc0000);
        }
        
        /* Áä∂ÊÄÅÈù¢Êùø - Âè≥‰∏äËßí */
        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid #00bfff;
            border-radius: 12px;
            padding: 15px;
            min-width: 220px;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.3);
        }
        
        .status-panel .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .status-panel .icon {
            font-size: 18px;
        }
        
        .status-panel .value {
            margin-left: auto;
            font-weight: bold;
            color: #00bfff;
            font-family: 'Courier New', monospace;
        }
        
        /* ‰ªªÂä°Èù¢Êùø - Â∑¶‰∏ãËßí */
        .task-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid #ffa500;
            border-radius: 12px;
            padding: 15px;
            min-width: 280px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.3);
        }
        
        .task-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #ffa500;
        }
        
        .task-item {
            margin: 8px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #ffa500;
            font-size: 12px;
        }
        
        .task-item.completed {
            opacity: 0.6;
            border-left-color: #4CAF50;
        }
        
        .task-progress {
            margin-top: 5px;
            font-size: 11px;
            color: #ccc;
        }
        
        /* Â∞èÂú∞Âõæ - Âè≥‰∏ãËßí */
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid #666;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.8);
        }
        
        /* ÂáÜÊòü - Â±èÂπï‰∏≠Â§Æ */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            opacity: 0.5;
            transition: all 0.3s;
        }
        
        .crosshair.locked {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }
        
        .crosshair::before {
            width: 16px;
            height: 2px;
            top: 14px;
            left: 7px;
        }
        
        .crosshair::after {
            width: 2px;
            height: 16px;
            top: 7px;
            left: 14px;
        }
        
        .crosshair-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            top: 13px;
            left: 13px;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.8);
        }
        
        /* Ê∂àÊÅØÊèêÁ§∫ - Âõ∫ÂÆöÂè≥‰∏ãËßíËΩªÈáèÁ∫ßÊòæÁ§∫ */
        .message-log {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 280px;
            max-height: 150px;
            overflow: hidden;
            pointer-events: none;
            font-family: 'Segoe UI', sans-serif;
            z-index: 500;
        }
        
        .message {
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(5px);
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            font-size: 12px;
            text-align: left;
            animation: messageFadeIn 0.3s ease-out;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        .message-success {
            border-left: 3px solid #52D273;
            color: #52D273;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .message-error {
            border-left: 3px solid #FF6B6B;
            color: #FF6B6B;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .message-info {
            border-left: 3px solid #5DADE2;
            color: #5DADE2;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes messageFadeIn {
            from { transform: translateX(30px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* ÊéßÂà∂ÊèêÁ§∫ - Â±èÂπï‰∏ãÊñπ */
        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
        }
        
        .controls-hint.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <!-- HUDÁïåÈù¢ -->
    <div id="hud">
        <!-- Ë£ÖÂ§áÈù¢Êùø -->
        <div class="equipment-panel">
            <div class="current-equipment">
                <span class="equipment-icon" id="equipment-icon">üî¥</span>
                <span class="equipment-name" id="equipment-name">Laser Weeder</span>
            </div>
            <div class="equipment-hotkeys">
                <button class="hotkey active" onclick="switchEquipment('laser')">1 Laser</button>
                <button class="hotkey" onclick="switchEquipment('scanner')">2 Scanner</button>
                <button class="hotkey" onclick="switchEquipment('soil')">3 Soil</button>
                <button class="hotkey" onclick="switchEquipment('spray')">4 Pesticide</button>
                <button class="hotkey" onclick="switchEquipment('water')">5 Water</button>
                <button class="hotkey" onclick="switchEquipment('planter')">P Plant</button>
                <button class="hotkey" onclick="switchEquipment('arm')">H Harvest</button>
            </div>
            <div class="equipment-status">
                <div class="status-item">
                    <span>Energy</span>
                    <div class="progress-bar">
                        <div id="energy-bar" class="progress-fill" style="width: 100%"></div>
                    </div>
                </div>
                <div class="status-item">
                    <span>Range</span>
                    <span id="equipment-range">3.0m</span>
                </div>
            </div>
        </div>
        
        <!-- Áä∂ÊÄÅÈù¢Êùø -->
        <div class="status-panel">
            <div class="status-item">
                <span class="icon">üöó</span>
                <span>Speed</span>
                <span id="cart-speed" class="value">0.0 m/s</span>
            </div>
            <div class="status-item">
                <span class="icon">üìç</span>
                <span>Position</span>
                <span id="cart-position" class="value">(0.0, 0.0)</span>
            </div>
            <div class="status-item">
                <span class="icon">üéØ</span>
                <span>Score</span>
                <span id="game-score" class="value">0</span>
            </div>
            <div class="status-item">
                <span class="icon">üí∞</span>
                <span>Coins</span>
                <span id="game-coins" class="value">0</span>
            </div>
        </div>
        
        <!-- ‰ªªÂä°Èù¢Êùø -->
        <div class="task-panel">
            <h3>üìã Tasks</h3>
            <div id="task-list"></div>
        </div>
        
        <!-- Â∞èÂú∞Âõæ -->
        <canvas id="minimap" class="minimap" width="150" height="150"></canvas>
        
        <!-- ÂáÜÊòü -->
        <div class="crosshair">
            <div class="crosshair-dot"></div>
        </div>
        
        <!-- Ê∂àÊÅØÊó•Âøó -->
        <div id="message-log" class="message-log"></div>
        
        <!-- ÊéßÂà∂ÊèêÁ§∫ -->
        <div class="controls-hint" id="controls-hint">
            WASD:Move | QE:Rotate | Space:Brake | F1-F4:Camera | 1-5:Equipment | P:Plant | H:Harvest | 7890/UIJK:Arm | ,.:Gripper | M:Monitor | R:Reset
        </div>
        
        <!-- Êú∫Ê¢∞ËáÇÁä∂ÊÄÅÊòæÁ§∫ -->
        <div id="arm-status" style="display: none; position: fixed; top: 120px; right: 20px; background: rgba(0, 0, 0, 0.85); border: 2px solid #FF6B35; border-radius: 10px; padding: 15px; width: 220px; font-family: monospace; font-size: 12px; color: white; z-index: 1000;">
            <div style="color: #FF6B35; font-weight: bold; margin-bottom: 10px; text-align: center; border-bottom: 1px solid #FF6B35; padding-bottom: 5px;">ü¶æ Robotic Arm Status</div>
            <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 10px;">
                <span style="color: #3498DB;">ËΩ¥1:</span><span id="arm-axis1-display" style="color: #00FF00;">0¬∞</span>
                <span style="color: #9B59B6;">ËΩ¥2:</span><span id="arm-axis2-display" style="color: #00FF00;">30¬∞</span>
                <span style="color: #E67E22;">ËΩ¥3:</span><span id="arm-axis3-display" style="color: #00FF00;">-45¬∞</span>
                <span style="color: #16A085;">ËΩ¥4:</span><span id="arm-axis4-display" style="color: #00FF00;">30¬∞</span>
                <span style="color: #E74C3C;">Gripper:</span><span id="arm-gripper-display" style="color: #00FF00;">Open</span>
            </div>
            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 10px; color: #AAA; text-align: center;">
                Press R to Reset | Press H to Hide
            </div>
        </div>
        
        <!-- Êú∫Ê¢∞ËáÇÊâãÂä®ÊéßÂà∂Èù¢ÊùøÔºàÈöêËóèÔºâ -->
        <div id="arm-control-panel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 2px solid #FF6B35; border-radius: 15px; padding: 20px; width: 500px; max-height: 80vh; overflow-y: auto; z-index: 9999; box-shadow: 0 0 30px rgba(255, 107, 53, 0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #FF6B35; padding-bottom: 10px;">
                <h3 style="color: #FF6B35; margin: 0; font-size: 20px;">ü¶æ Robotic Arm Manual Control</h3>
                <button id="close-arm-panel" style="background: #E74C3C; color: white; border: none; border-radius: 5px; width: 30px; height: 30px; cursor: pointer; font-size: 18px;">‚úï</button>
            </div>
            
            <div style="color: white;">
                <!-- Ê®°ÂºèÊèêÁ§∫ -->
                <div style="background: rgba(255, 107, 53, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                    <p style="margin: 0; font-size: 14px;">üéÆ Use keyboard or sliders to control each joint</p>
                </div>
                
                <!-- ËΩ¥1ÊéßÂà∂ -->
                <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #FF6B35; font-weight: bold;">Axis 1 - Base Rotation (Left/Right)</span>
                        <span id="axis1-value" style="color: #00FF00; font-family: monospace;">0¬∞</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="axis-btn" data-axis="1" data-dir="-1" style="flex: 1; background: #3498DB; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚óÄ 7</button>
                        <input type="range" id="axis1-slider" min="-180" max="180" value="0" step="5" style="flex: 3;">
                        <button class="axis-btn" data-axis="1" data-dir="1" style="flex: 1; background: #3498DB; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">8 ‚ñ∂</button>
                    </div>
                </div>
                
                <!-- ËΩ¥2ÊéßÂà∂ -->
                <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #FF6B35; font-weight: bold;">Axis 2 - Shoulder Joint (Forward/Backward)</span>
                        <span id="axis2-value" style="color: #00FF00; font-family: monospace;">30¬∞</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="axis-btn" data-axis="2" data-dir="-1" style="flex: 1; background: #9B59B6; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚ñº U</button>
                        <input type="range" id="axis2-slider" min="-90" max="90" value="30" step="5" style="flex: 3;">
                        <button class="axis-btn" data-axis="2" data-dir="1" style="flex: 1; background: #9B59B6; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">I ‚ñ≤</button>
                    </div>
                </div>
                
                <!-- ËΩ¥3ÊéßÂà∂ -->
                <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #FF6B35; font-weight: bold;">Axis 3 - Elbow Joint (Bend)</span>
                        <span id="axis3-value" style="color: #00FF00; font-family: monospace;">-45¬∞</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="axis-btn" data-axis="3" data-dir="-1" style="flex: 1; background: #E67E22; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚ñº J</button>
                        <input type="range" id="axis3-slider" min="-150" max="10" value="-45" step="5" style="flex: 3;">
                        <button class="axis-btn" data-axis="3" data-dir="1" style="flex: 1; background: #E67E22; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">K ‚ñ≤</button>
                    </div>
                </div>
                
                <!-- ËΩ¥4ÊéßÂà∂ -->
                <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #FF6B35; font-weight: bold;">Axis 4 - Wrist Joint (Pitch)</span>
                        <span id="axis4-value" style="color: #00FF00; font-family: monospace;">30¬∞</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="axis-btn" data-axis="4" data-dir="-1" style="flex: 1; background: #16A085; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚ñº N</button>
                        <input type="range" id="axis4-slider" min="-90" max="90" value="30" step="5" style="flex: 3;">
                        <button class="axis-btn" data-axis="4" data-dir="1" style="flex: 1; background: #16A085; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">O ‚ñ≤</button>
                    </div>
                </div>
                
                <!-- ÊäìÊâãÊéßÂà∂ -->
                <div style="margin-bottom: 15px; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: #FF6B35; font-weight: bold;">Gripper</span>
                        <span id="gripper-value" style="color: #00FF00; font-family: monospace;">Âº†ÂºÄ</span>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="gripper-open" style="flex: 1; background: #27AE60; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold;">Open (,)</button>
                        <button id="gripper-close" style="flex: 1; background: #C0392B; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold;">Close (.)</button>
                    </div>
                </div>
                
                <!-- È¢ÑËÆæÂßøÊÄÅ -->
                <div style="background: rgba(52, 152, 219, 0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="color: #3498DB; margin: 0 0 10px 0; font-size: 14px;">‚ö° Quick Poses</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button class="pose-btn" data-pose="home" style="background: #34495E; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">üè† Home</button>
                        <button class="pose-btn" data-pose="ready" style="background: #34495E; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚úã Ready</button>
                        <button class="pose-btn" data-pose="reach" style="background: #34495E; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">üìè Reach</button>
                        <button class="pose-btn" data-pose="vertical" style="background: #34495E; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px;">‚¨áÔ∏è Vertical</button>
                    </div>
                </div>
                
                <!-- Êú´Á´Ø‰ΩçÁΩÆÊòæÁ§∫ -->
                <div style="background: rgba(0, 255, 0, 0.1); padding: 10px; border-radius: 8px; text-align: center;">
                    <h4 style="color: #2ECC71; margin: 0 0 8px 0; font-size: 13px;">üìç End Effector Position (Relative to Cart)</h4>
                    <div style="display: flex; justify-content: space-around; font-family: monospace; font-size: 12px;">
                        <span>X: <span id="ee-x" style="color: #E74C3C;">0.00</span>m</span>
                        <span>Y: <span id="ee-y" style="color: #3498DB;">0.00</span>m</span>
                        <span>Z: <span id="ee-z" style="color: #2ECC71;">0.00</span>m</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    
    <script>
        // ========== ÂÖ®Â±ÄÂèòÈáè ==========
        let scene, camera, renderer;
        let cart, farm;
        const gridConfig = {
            cellSize: 0.5,
            gridSize: 8,
            offsetX: -2.0,
            offsetZ: -2.0
        };
        const gridCells = [];
        let gridLabelGroup = null;
        let autoTraverse = {
            active: false,
            path: [],
            currentIndex: 0,
            speed: 1.2,
            threshold: 0.08
        };
        let cameraMode = 'third_person'; // third_person, first_person, free, birds_eye
        let orbitControls;
        
        // ‰ªøÁúüÁä∂ÊÄÅ
        let gameState = {
            energy: 100,
            score: 0,
            coins: 0,
            currentEquipment: 'laser',
            plants: [],
            tasks: []
        };
        
        // Ë£ÖÂ§áÈÖçÁΩÆÔºàÊØè‰∏™Ë£ÖÂ§áÊúâ‰∏çÂêåÁöÑ‰ΩçÁΩÆÂíå‰∫§‰∫íÊñπÂºèÔºâ
        const equipmentConfig = {
            laser: {
                name: 'Laser Weeder',
                icon: 'üî¥',
                position: new THREE.Vector3(0, 0, 0),  // Arm end effector
                range: 5.0,
                interactionType: 'auto_aim',  // Auto aim
                color: 0xFF0000,
                tip: 'Press Space to auto-aim and attack the nearest weed in range | Use 7/8/U/I/J/K/N/O for manual control'
            },
            scanner: {
                name: 'Multispectral Scanner',
                icon: 'üîµ',
                position: new THREE.Vector3(0, 0.4, 0),  // Top
                range: 2.5,  // Scan radius
                interactionType: 'scanner_cone',  // Fan-shaped scan area
                scanAngle: Math.PI * 0.6,  // 108 degree fan
                color: 0x00BFFF,
                tip: 'Press Space to scan all plants in the forward fan area'
            },
            arm: {
                name: 'Robotic Arm Gripper',
                icon: 'ü¶æ',
                position: new THREE.Vector3(0.25, 0.2, 0),  // Right side
                range: 0.9,
                interactionType: 'auto',  // Auto-harvest nearest mature plant
                color: 0xFFAA00,
                tip: 'Press H to switch | Space to harvest nearby mature plants | Arm auto-grabs'
            },
            soil: {
                name: 'Soil Testing Probe',
                icon: 'üî¨',
                position: new THREE.Vector3(0, -0.1, 0),  // Bottom
                range: 0.4,
                interactionType: 'auto',  // Auto-detect beneath cart
                color: 0xFFFF00,
                tip: 'Press Space to test soil beneath'
            },
            spray: {
                name: 'Pesticide Sprayer',
                icon: 'üí®',
                position: new THREE.Vector3(0, 0.15, -0.2),  // Front
                range: 2.5,
                interactionType: 'cone',  // Cone area
                color: 0x00FF00,
                tip: 'Hold mouse to continuously spray front cone area'
            },
            water: {
                name: 'Watering System',
                icon: 'üíß',
                position: new THREE.Vector3(0, 0.25, 0.15),  // Rear top
                range: 2.2,
                interactionType: 'area',  // Surrounding area
                color: 0x00BFFF,
                tip: 'Hold mouse to water surrounding area'
            },
            planter: {
                name: 'Seed Planter',
                icon: 'üå±',
                position: new THREE.Vector3(0, 0.3, 0),  // Top
                range: 0.6,  // Small range, can only plant beneath or directly in front
                interactionType: 'auto',  // Auto planting
                color: 0x8B4513,
                tip: 'Press P to switch | Space to plant beneath (5 coins)'
            }
        };
        
        // ËåÉÂõ¥ÊåáÁ§∫Âô®
        let rangeIndicator = null;
        let equipmentModel = null;
        let isUsingEquipment = false;  // ÊåÅÁª≠‰ΩøÁî®Áä∂ÊÄÅÔºàÂñ∑Ê¥í/ÊµáÊ∞¥Ôºâ
        
        // ÊøÄÂÖâÁûÑÂáÜÁ≥ªÁªüÔºàÁÆÄÂåñÁâàÔºâ
        let laserAimLine = null;  // ÊøÄÂÖâÁûÑÂáÜËæÖÂä©Á∫ø
        let laserAimDot = null;   // ÊøÄÂÖâÁûÑÂáÜÁÇπ
        let laserAimLineEnabled = false;  // ÁûÑÂáÜÁ∫øÊòØÂê¶ÂêØÁî®
        
        
        // ÈîÆÁõòÁä∂ÊÄÅ
        let keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            rotateLeft: false,
            rotateRight: false,
            brake: false,
            boost: false
        };
        
        // Èº†Ê†áÊéßÂà∂ÔºàFPSÈ£éÊ†ºÔºâ
        let mouseControl = {
            isLocked: false,
            sensitivity: 0.002,  // Èº†Ê†áÁÅµÊïèÂ∫¶ÔºàÂèØË∞ÉËäÇÔºö0.001-0.005Ôºâ
            yaw: 0,              // Ê∞¥Âπ≥ÊóãËΩ¨ËßíÂ∫¶
            pitch: 0,            // ÂûÇÁõ¥ÊóãËΩ¨ËßíÂ∫¶
            maxPitch: Math.PI / 2.2,  // ÊúÄÂ§ß‰øØ‰ª∞ËßíÔºàÁ∫¶82Â∫¶ÔºåÊõ¥Êé•ËøëCFÔºâ
            smoothing: 0.3       // ËßÜËßíÂπ≥ÊªëÁ≥ªÊï∞Ôºà0-1ÔºåË∂äÂ§ßË∂äÂπ≥ÊªëÔºâ
        };
        
        // Áõ∏Êú∫Áº©ÊîæÊéßÂà∂
        let cameraZoom = {
            distance: 4,         // Á¨¨‰∏â‰∫∫Áß∞Áõ∏Êú∫Ë∑ùÁ¶ª
            minDistance: 2,      // ÊúÄÂ∞èË∑ùÁ¶ª
            maxDistance: 10,     // ÊúÄÂ§ßË∑ùÁ¶ª
            zoomSpeed: 0.3       // Áº©ÊîæÈÄüÂ∫¶
        };
        
        // ËßÜËßíÊëáÊôÉÊïàÊûúÔºàÁßªÂä®Êó∂Ôºâ
        let headBob = {
            enabled: true,
            time: 0,
            frequency: 5.0,      // ÊëáÊôÉÈ¢ëÁéá
            amplitude: 0.03,     // ÊëáÊôÉÂπÖÂ∫¶
            currentOffset: new THREE.Vector3()
        };
        
        // Â∞èËΩ¶Áâ©ÁêÜÂèÇÊï∞ÔºàFPSÈ£éÊ†ºÔºâ
        let cartSpeed = 0;
        let cartVelocity = new THREE.Vector3();  // ÈÄüÂ∫¶ÂêëÈáè
        const maxSpeed = 2.5;           // Ê≠£Â∏∏ÈÄüÂ∫¶
        const sprintSpeed = 4.0;        // ÂÜ≤Âà∫ÈÄüÂ∫¶
        const crouchSpeed = 1.2;        // Ëπ≤‰ºèÈÄüÂ∫¶
        const acceleration = 2.5;       // Âä†ÈÄüÂ∫¶ÔºàÊõ¥Âø´ÂìçÂ∫îÔºâ
        const deceleration = 3.0;      // ÂáèÈÄüÂ∫¶
        const friction = 0.88;          // Êë©Êì¶Á≥ªÊï∞ÔºàÊÉØÊÄßÔºâ
        const rotationSpeed = 2.0;     // ÊóãËΩ¨ÈÄüÂ∫¶
        
        // FPSÁßªÂä®Áä∂ÊÄÅ
        let moveState = {
            isSprinting: false,
            isCrouching: false,
            currentHeight: 0.6,  // ÂΩìÂâçÁõ∏Êú∫È´òÂ∫¶
            normalHeight: 0.6,
            crouchHeight: 0.3
        };
        
        // Socket.IOËøûÊé•
        const socket = io();
        
        // Èü≥ÊïàÁ≥ªÁªüÔºàÁÆÄÂçïÂÆûÁé∞ÔºåÊó†ÈúÄÁúüÂÆûÈü≥È¢ëÊñá‰ª∂Ôºâ
        const SoundEffects = {
            play: function(soundName) {
                console.log(`üîä Êí≠ÊîæÈü≥Êïà: ${soundName}`);
                // ÂèØ‰ª•ÂêéÁª≠Ê∑ªÂä† Web Audio API Êàñ Howler.js
                // ÊöÇÊó∂Áî®console.logÊ®°Êãü
            },
            laser: () => SoundEffects.play('laser_fire'),
            scan: () => SoundEffects.play('scanner_beep'),
            success: () => SoundEffects.play('success_ding'),
            error: () => SoundEffects.play('error_buzz'),
            equipmentSwitch: () => SoundEffects.play('equipment_switch'),
            spray: () => SoundEffects.play('spray_pesticide'),
            water: () => SoundEffects.play('water_splash'),
            growth: () => SoundEffects.play('plant_growth')
        };
        
        // ========== Êú∫Ê¢∞ËáÇÊâãÂä®ÊéßÂà∂Á≥ªÁªü ==========
        let armManualControl = {
            enabled: true,  // ÂßãÁªàÂêØÁî®
            showStatus: false,  // Áä∂ÊÄÅÊòæÁ§∫ÂºÄÂÖ≥
            currentAngles: {
                axis1: 0,      // Âü∫Â∫ßÊóãËΩ¨ (Â∫¶)
                axis2: 30,     // ËÇ©ÂÖ≥ËäÇ (Â∫¶)
                axis3: -45,    // ËÇòÂÖ≥ËäÇ (Â∫¶)
                axis4: 30      // ËÖïÂÖ≥ËäÇ (Â∫¶)
            },
            gripperOpen: true
        };
        
        // ÂàáÊç¢Áä∂ÊÄÅÊòæÁ§∫
        function toggleArmStatus() {
            armManualControl.showStatus = !armManualControl.showStatus;
            document.getElementById('arm-status').style.display = armManualControl.showStatus ? 'block' : 'none';
            if (armManualControl.showStatus) {
                updateArmStatusDisplay();
            }
        }
        
        // ÂàáÊç¢ÊâãÂä®ÊéßÂà∂Èù¢Êùø
        function toggleArmControlPanel() {
            const panel = document.getElementById('arm-control-panel');
            armManualControl.enabled = panel.style.display === 'none';
            panel.style.display = armManualControl.enabled ? 'block' : 'none';
            
            if (armManualControl.enabled) {
                // ËØªÂèñÂΩìÂâçÊú∫Ê¢∞ËáÇËßíÂ∫¶
                readCurrentArmAngles();
                updateAllSliders();
                showMessage('ÊâãÂä®ÊéßÂà∂Ê®°ÂºèÂ∑≤ÂêØÁî®', 'info');
            } else {
                showMessage('ÊâãÂä®ÊéßÂà∂Ê®°ÂºèÂ∑≤ÂÖ≥Èó≠', 'info');
            }
        }
        
        // ËØªÂèñÂΩìÂâçÊú∫Ê¢∞ËáÇËßíÂ∫¶
        function readCurrentArmAngles() {
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return;
            
            const axis2 = armBase.getObjectByName('axis2_shoulder');
            const axis3 = axis2.getObjectByName('axis3_elbow');
            const axis4 = axis3.getObjectByName('axis4_wrist');
            
            armManualControl.currentAngles.axis1 = THREE.MathUtils.radToDeg(armBase.rotation.y);
            armManualControl.currentAngles.axis2 = THREE.MathUtils.radToDeg(axis2.rotation.z);
            armManualControl.currentAngles.axis3 = THREE.MathUtils.radToDeg(axis3.rotation.z);
            armManualControl.currentAngles.axis4 = THREE.MathUtils.radToDeg(axis4.rotation.z);
        }
        
        // Êõ¥Êñ∞ÊâÄÊúâÊªëÂùó
        function updateAllSliders() {
            document.getElementById('axis1-slider').value = armManualControl.currentAngles.axis1;
            document.getElementById('axis2-slider').value = armManualControl.currentAngles.axis2;
            document.getElementById('axis3-slider').value = armManualControl.currentAngles.axis3;
            document.getElementById('axis4-slider').value = armManualControl.currentAngles.axis4;
            
            updateAxisDisplay(1);
            updateAxisDisplay(2);
            updateAxisDisplay(3);
            updateAxisDisplay(4);
        }
        
        // ÊéßÂà∂ËΩ¥ÊóãËΩ¨
        function controlAxis(axisNum, direction, step = 5) {
            const angleKey = `axis${axisNum}`;
            armManualControl.currentAngles[angleKey] += direction * step;
            
            // ÈôêÂà∂ËåÉÂõ¥
            const limits = {
                axis1: null,  // Êó†ÈôêÂà∂ÔºåÂèØ‰ª•360Â∫¶ËøûÁª≠ÊóãËΩ¨
                axis2: [-90, 90],
                axis3: [-150, 10],  // Êâ©Â§ßËåÉÂõ¥ÔºåÂèØ‰ª•Êõ¥Â§ßÂºØÊõ≤
                axis4: [-90, 90]
            };
            
            // ËΩ¥1‰∏çÈôêÂà∂ÔºåÂÖ∂‰ªñËΩ¥ÈôêÂà∂ËåÉÂõ¥
            if (limits[angleKey]) {
                const [min, max] = limits[angleKey];
                armManualControl.currentAngles[angleKey] = Math.max(min, Math.min(max, armManualControl.currentAngles[angleKey]));
            }
            // ËΩ¥1ËßíÂ∫¶ÂΩí‰∏ÄÂåñÂà∞-180~180ÊòæÁ§∫Ôºà‰ΩÜ‰∏çÈôêÂà∂ÂÆûÈôÖÂÄºÔºâ
            if (axisNum === 1) {
                // ‰øùÊåÅÂéüÂßãÂÄºÁî®‰∫éÊóãËΩ¨ÔºåÂè™Âú®ÊòæÁ§∫Êó∂ÂΩí‰∏ÄÂåñ
            }
            
            // Â∫îÁî®Âà∞Êú∫Ê¢∞ËáÇ
            applyAxisAngle(axisNum);
            
            // Êõ¥Êñ∞ÊòæÁ§∫
            updateAxisDisplay(axisNum);
            const slider = document.getElementById(`axis${axisNum}-slider`);
            if (slider) slider.value = armManualControl.currentAngles[angleKey];
            
            // Êõ¥Êñ∞HUD
            if (armManualControl.showStatus) {
                updateArmStatusDisplay();
            }
            
            // Êõ¥Êñ∞Êú´Á´Ø‰ΩçÁΩÆ
            const eeElem = document.getElementById('ee-x');
            if (eeElem) updateEndEffectorPosition();
        }
        
        // Â∫îÁî®ËΩ¥ËßíÂ∫¶Âà∞3DÊ®°Âûã
        function applyAxisAngle(axisNum) {
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return;
            
            const angle = THREE.MathUtils.degToRad(armManualControl.currentAngles[`axis${axisNum}`]);
            
            if (axisNum === 1) {
                armBase.rotation.y = angle;
            } else if (axisNum === 2) {
                const axis2 = armBase.getObjectByName('axis2_shoulder');
                axis2.rotation.z = angle;
            } else if (axisNum === 3) {
                const axis2 = armBase.getObjectByName('axis2_shoulder');
                const axis3 = axis2.getObjectByName('axis3_elbow');
                axis3.rotation.z = angle;
            } else if (axisNum === 4) {
                const axis2 = armBase.getObjectByName('axis2_shoulder');
                const axis3 = axis2.getObjectByName('axis3_elbow');
                const axis4 = axis3.getObjectByName('axis4_wrist');
                axis4.rotation.z = angle;
            }
        }
        
        // Êõ¥Êñ∞ËΩ¥ÊòæÁ§∫
        function updateAxisDisplay(axisNum) {
            let angle = armManualControl.currentAngles[`axis${axisNum}`];
            
            // ËΩ¥1ÊòæÁ§∫Êó∂ÂΩí‰∏ÄÂåñÂà∞-180~180Ôºå‰ΩÜ‰øùÊåÅÂéüÂßãÂÄº
            if (axisNum === 1) {
                let displayAngle = angle % 360;
                if (displayAngle > 180) displayAngle -= 360;
                if (displayAngle < -180) displayAngle += 360;
                angle = displayAngle;
            }
            
            const elem = document.getElementById(`axis${axisNum}-value`);
            if (elem) elem.textContent = `${angle.toFixed(0)}¬∞`;
        }
        
        // Êõ¥Êñ∞Áä∂ÊÄÅHUDÊòæÁ§∫
        function updateArmStatusDisplay() {
            // ËΩ¥1ÊòæÁ§∫ÂΩí‰∏ÄÂåñËßíÂ∫¶
            let axis1Display = armManualControl.currentAngles.axis1 % 360;
            if (axis1Display > 180) axis1Display -= 360;
            if (axis1Display < -180) axis1Display += 360;
            
            document.getElementById('arm-axis1-display').textContent = `${axis1Display.toFixed(0)}¬∞`;
            document.getElementById('arm-axis2-display').textContent = `${armManualControl.currentAngles.axis2.toFixed(0)}¬∞`;
            document.getElementById('arm-axis3-display').textContent = `${armManualControl.currentAngles.axis3.toFixed(0)}¬∞`;
            document.getElementById('arm-axis4-display').textContent = `${armManualControl.currentAngles.axis4.toFixed(0)}¬∞`;
            document.getElementById('arm-gripper-display').textContent = armManualControl.gripperOpen ? 'Âº†ÂºÄ' : 'ÂêàÊã¢';
        }
        
        // ÊéßÂà∂ÊäìÊâã
        function controlGripper(open) {
            armManualControl.gripperOpen = open;
            
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return;
            
            const axis2 = armBase.getObjectByName('axis2_shoulder');
            if (!axis2) return;
            const axis3 = axis2.getObjectByName('axis3_elbow');
            if (!axis3) return;
            const axis4 = axis3.getObjectByName('axis4_wrist');
            if (!axis4) return;
            const gripper = axis4.getObjectByName('gripper');
            
            if (gripper) {
                const leftGrip = gripper.getObjectByName('left_gripper');
                const rightGrip = gripper.getObjectByName('right_gripper');
                
                if (leftGrip && rightGrip) {
                    if (open) {
                        leftGrip.position.x = -0.02;
                        rightGrip.position.x = 0.02;
                        const elem = document.getElementById('gripper-value');
                        if (elem) elem.textContent = 'Âº†ÂºÄ';
                    } else {
                        leftGrip.position.x = -0.015;
                        rightGrip.position.x = 0.015;
                        const elem = document.getElementById('gripper-value');
                        if (elem) elem.textContent = 'ÂêàÊã¢';
                    }
                }
            }
            
            // Êõ¥Êñ∞HUD
            if (armManualControl.showStatus) {
                updateArmStatusDisplay();
            }
        }
        
        // È¢ÑËÆæÂßøÊÄÅ
        function setPose(pose) {
            const poses = {
                home: { axis1: 0, axis2: 30, axis3: -45, axis4: 30 },
                ready: { axis1: 0, axis2: 60, axis3: -90, axis4: 45 },
                reach: { axis1: 0, axis2: 80, axis3: -100, axis4: 20 },
                vertical: { axis1: 0, axis2: 90, axis3: -90, axis4: 0 }
            };
            
            const targetAngles = poses[pose];
            if (targetAngles) {
                Object.assign(armManualControl.currentAngles, targetAngles);
                for (let i = 1; i <= 4; i++) {
                    applyAxisAngle(i);
                }
                updateAllSliders();
                updateEndEffectorPosition();
                showMessage(`Â∑≤ÂàáÊç¢Âà∞${pose === 'home' ? 'ÂàùÂßã' : pose === 'ready' ? 'ÂáÜÂ§á' : pose === 'reach' ? '‰º∏Â±ï' : 'ÂûÇÁõ¥'}ÂßøÊÄÅ`, 'success');
            }
        }
        
        // ËÆ°ÁÆóÂπ∂Êõ¥Êñ∞Êú´Á´Ø‰ΩçÁΩÆ
        function updateEndEffectorPosition() {
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return;
            
            const axis2 = armBase.getObjectByName('axis2_shoulder');
            const axis3 = axis2.getObjectByName('axis3_elbow');
            const axis4 = axis3.getObjectByName('axis4_wrist');
            const gripper = axis4.getObjectByName('gripper');
            
            if (gripper) {
                // Ëé∑Âèñ‰∏ñÁïåÂùêÊ†á
                const worldPos = new THREE.Vector3();
                gripper.getWorldPosition(worldPos);
                
                // ËΩ¨Êç¢‰∏∫Áõ∏ÂØπÂ∞èËΩ¶ÁöÑÂùêÊ†á
                const cartPos = cart.position;
                const relativePos = worldPos.clone().sub(cartPos);
                
                document.getElementById('ee-x').textContent = relativePos.x.toFixed(2);
                document.getElementById('ee-y').textContent = relativePos.y.toFixed(2);
                document.getElementById('ee-z').textContent = relativePos.z.toFixed(2);
            }
        }
        
        // ========== ÂàùÂßãÂåñ ==========
        function init() {
            // ÂàõÂª∫Âú∫ÊôØ
            scene = new THREE.Scene();
            
            // ÂàõÂª∫Â§©Á©∫ÔºàÊ∏êÂèòËÉåÊôØÔºâ
            createSky();
            
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
            
            // ÂàõÂª∫Áõ∏Êú∫
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(4, 2.5, 4);
            
            // ÂàõÂª∫Ê∏≤ÊüìÂô®
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // OrbitControlsÔºà‰ªÖÂú®Ëá™Áî±Ê®°Âºè‰ΩøÁî®Ôºâ
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enabled = false;
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            
            // ÂÖâÁÖß
            setupLighting();
            
            // ÂàõÂª∫Âú∞Èù¢
            createGround();
            
            // ÂàõÂª∫ÂÜúÁî∞
            createFarm();
            
            // ÂàõÂª∫Â∞èËΩ¶
            createCart();
            
            // ÂàõÂª∫ÂàùÂßãË£ÖÂ§áËåÉÂõ¥ÊåáÁ§∫Âô®
            createRangeIndicator('laser');
            
            // Âä†ËΩΩ‰ªøÁúüÁä∂ÊÄÅ
            loadGameState();
            
            // ‰∫ã‰ª∂ÁõëÂê¨
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onMouseClick);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            
            // Èº†Ê†áÈîÅÂÆö‰∫ã‰ª∂
            renderer.domElement.addEventListener('click', () => {
                if (!mouseControl.isLocked && cameraMode !== 'free') {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onMouseWheel, { passive: false });
            
            // ÈöêËóèÊéßÂà∂ÊèêÁ§∫Ôºà5ÁßíÂêéÔºâ
            setTimeout(() => {
                document.getElementById('controls-hint').classList.add('hidden');
            }, 5000);
            
            // ÂºÄÂßãÂä®ÁîªÂæ™ÁéØ
            animate();
            
            console.log('‚úÖ ‰ªøÁúüÂàùÂßãÂåñÂÆåÊàê');
        }
        
        // ========== Â§©Á©∫Á≥ªÁªü ==========
        function createSky() {
            // ÂàõÂª∫Â§©Á©∫Á©πÈ°∂ÔºàÊ∏êÂèòÊïàÊûúÔºâ
            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `;
            
            const uniforms = {
                topColor: { value: new THREE.Color(0x0077ff) },     // Â§©ËìùËâ≤
                bottomColor: { value: new THREE.Color(0xffffff) },  // Âú∞Âπ≥Á∫øÁôΩËâ≤
                offset: { value: 33 },
                exponent: { value: 0.6 }
            };
            
            const skyGeo = new THREE.SphereGeometry(500, 32, 15);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);
        }
        
        // ========== ÂÖâÁÖßÁ≥ªÁªü ==========
        function setupLighting() {
            // ÁéØÂ¢ÉÂÖâ
            const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.6);
            scene.add(ambientLight);
            
            // Â§™Èò≥ÂÖâÔºà‰∏ªÂÖâÊ∫êÔºâ
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 15, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -10;
            sunLight.shadow.camera.right = 10;
            sunLight.shadow.camera.top = 10;
            sunLight.shadow.camera.bottom = -10;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            // Â°´ÂÖÖÂÖâÔºàÊ®°ÊãüÂ§©Á©∫ÂèçÂ∞ÑÔºâ
            const fillLight = new THREE.DirectionalLight(0xffa500, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);
            
            // ÂçäÁêÉÂÖâÔºàÊ®°ÊãüÁéØÂ¢ÉÂÖâÔºâ
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.4);
            scene.add(hemiLight);
        }
        
        // ========== ÂàõÂª∫Âú∞Èù¢ ==========
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B8E23,  // Ê©ÑÊ¶ÑÁªøËâ≤ÔºàÁ±ª‰ººËçâÂú∞Ôºâ
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        // ========== ÂàõÂª∫ÂÜúÁî∞ ==========
        function createFarm() {
            // Â¶ÇÊûú‰πãÂâçÂ∑≤ÁªèÂàõÂª∫ËøáÂÜúÁî∞ÔºåÂÖà‰ªéÂú∫ÊôØÁßªÈô§‰ª•ÈÅøÂÖçÈáçÂ§ç
            if (farm && scene) {
                scene.remove(farm);
            }
            farm = new THREE.Group();

            // Ê∏ÖÁêÜÊóßÁöÑÊ†áÁ≠æËµÑÊ∫ê
            if (gridLabelGroup) {
                gridLabelGroup.children.forEach(label => {
                    if (label.material && label.material.map) {
                        label.material.map.dispose();
                    }
                    if (label.material) {
                        label.material.dispose();
                    }
                });
            }

            gridLabelGroup = new THREE.Group();
            gridLabelGroup.name = 'grid_labels';

            // ÂàùÂßãÂåñÁΩëÊ†ºÊï∞ÊçÆ
            gridCells.length = 0;
            for (let row = 0; row < gridConfig.gridSize; row++) {
                gridCells[row] = [];
            }

            const colors = [0xD2691E, 0xCD853F];
            for (let row = 0; row < gridConfig.gridSize; row++) {
                for (let col = 0; col < gridConfig.gridSize; col++) {
                    const cellGeometry = new THREE.BoxGeometry(gridConfig.cellSize - 0.02, 0.01, gridConfig.cellSize - 0.02);
                    const colorIndex = (row + col) % 2;
                    const cellMaterial = new THREE.MeshStandardMaterial({
                        color: colors[colorIndex],
                        roughness: 0.9
                    });
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    const posX = gridConfig.offsetX + col * gridConfig.cellSize + gridConfig.cellSize / 2;
                    const posZ = gridConfig.offsetZ + row * gridConfig.cellSize + gridConfig.cellSize / 2;
                    cell.position.set(posX, 0.005, posZ);
                    cell.receiveShadow = true;
                    farm.add(cell);

                    const cellInfo = { row, col, x: posX, z: posZ };
                    gridCells[row][col] = cellInfo;

                    const label = createGridLabel(row, col, posX, posZ);
                    gridLabelGroup.add(label);
                }
            }

            farm.add(gridLabelGroup);
            scene.add(farm);
        }
        
        function createGridLabel(row, col, x, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // ËÉåÊôØ
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 4;
            const rectX = 12;
            const rectY = 12;
            const rectW = canvas.width - rectX * 2;
            const rectH = canvas.height - rectY * 2;
            const radius = 12;
            ctx.beginPath();
            ctx.moveTo(rectX + radius, rectY);
            ctx.lineTo(rectX + rectW - radius, rectY);
            ctx.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
            ctx.lineTo(rectX + rectW, rectY + rectH - radius);
            ctx.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
            ctx.lineTo(rectX + radius, rectY + rectH);
            ctx.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
            ctx.lineTo(rectX, rectY + radius);
            ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.font = 'bold 28px Arial';
            ctx.fillStyle = '#F8F8F8';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`(${row}, ${col})`, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, 0.08, z);
            sprite.scale.set(0.45, 0.25, 1);
            sprite.name = `grid_label_${row}_${col}`;
            sprite.userData = { row, col };
            return sprite;
        }
        
        // ========== ÂàõÂª∫Â∞èËΩ¶ ==========
        function createCart() {
            cart = new THREE.Group();
            
            // ËΩ¶Ë∫´
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.25);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x4169E1,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.125;
            body.castShadow = true;
            cart.add(body);
            
            // ËΩÆÂ≠ê
            const wheelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.03, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const wheelPositions = [
                [-0.12, 0.05, -0.1],
                [-0.12, 0.05, 0.1],
                [0.12, 0.05, -0.1],
                [0.12, 0.05, 0.1]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                cart.add(wheel);
            });
            
            // Êú∫Ê¢∞ËáÇÁ≥ªÁªüÔºàÊõ¥ÊòéÊòæÔºâ
            createRoboticArm(cart);
            
            // ÂàùÂßã‰ΩçÁΩÆ
            cart.position.set(0, 0, 0);
            scene.add(cart);
        }

        // ========== ÁΩëÊ†ºËá™Âä®Â∑°Ëà™ ==========
        function worldToGrid(x, z) {
            const col = Math.round((x - gridConfig.offsetX - gridConfig.cellSize / 2) / gridConfig.cellSize);
            const row = Math.round((z - gridConfig.offsetZ - gridConfig.cellSize / 2) / gridConfig.cellSize);
            return {
                row: THREE.MathUtils.clamp(row, 0, gridConfig.gridSize - 1),
                col: THREE.MathUtils.clamp(col, 0, gridConfig.gridSize - 1)
            };
        }

        function getCellCenter(row, col) {
            const safeRow = THREE.MathUtils.clamp(row, 0, gridConfig.gridSize - 1);
            const safeCol = THREE.MathUtils.clamp(col, 0, gridConfig.gridSize - 1);
            if (gridCells[safeRow] && gridCells[safeRow][safeCol]) {
                return gridCells[safeRow][safeCol];
            }
            const x = gridConfig.offsetX + safeCol * gridConfig.cellSize + gridConfig.cellSize / 2;
            const z = gridConfig.offsetZ + safeRow * gridConfig.cellSize + gridConfig.cellSize / 2;
            return { row: safeRow, col: safeCol, x, z };
        }

        function generateCoveragePath(startRow, startCol) {
            const path = [];
            for (let row = 0; row < gridConfig.gridSize; row++) {
                if (row % 2 === 0) {
                    for (let col = 0; col < gridConfig.gridSize; col++) {
                        path.push(getCellCenter(row, col));
                    }
                } else {
                    for (let col = gridConfig.gridSize - 1; col >= 0; col--) {
                        path.push(getCellCenter(row, col));
                    }
                }
            }

            const startIndex = path.findIndex(cell => cell.row === startRow && cell.col === startCol);
            if (startIndex > 0) {
                return path.slice(startIndex).concat(path.slice(0, startIndex));
            }
            return path;
        }

        function startAutoTraverse() {
            if (!gridCells.length) {
                showMessage('‚ö†Ô∏è ÂÜúÁî∞Â∞öÊú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÂºÄÂßãËá™Âä®Â∑°Ëà™', 'warning');
                return;
            }
            const startCell = worldToGrid(cart.position.x, cart.position.z);
            const path = generateCoveragePath(startCell.row, startCell.col);
            if (!path.length) {
                showMessage('‚ö†Ô∏è Êó†Ê≥ïÁîüÊàêÂ∑°Ëà™Ë∑ØÂæÑ', 'warning');
                return;
            }
            autoTraverse.path = path;
            autoTraverse.currentIndex = 0;
            autoTraverse.active = true;
            showMessage('üöó Ëá™Âä®Â∑°Ëà™ÂºÄÂßãÔºöÂ∞èËΩ¶Â∞ÜË¶ÜÁõñÊâÄÊúâÂÜúÁî∞Ê†ºÂ≠ê', 'info');
        }

        function stopAutoTraverse(reason) {
            if (!autoTraverse.active) return;
            autoTraverse.active = false;
            autoTraverse.path = [];
            autoTraverse.currentIndex = 0;

            if (reason === 'completed') {
                showMessage('‚úÖ Ëá™Âä®Â∑°Ëà™ÂÆåÊàêÔºåÊâÄÊúâÊ†ºÂ≠êÂ∑≤Ë¶ÜÁõñ', 'success');
            } else if (reason === 'manual control') {
                showMessage('üõë ÊâãÂä®Êìç‰ΩúÊ£ÄÊµãÂà∞ÔºåËá™Âä®Â∑°Ëà™Â∑≤ÂèñÊ∂à', 'warning');
            } else if (reason === 'manual stop') {
                showMessage('üõë Ëá™Âä®Â∑°Ëà™Â∑≤ÂÅúÊ≠¢', 'warning');
            }
        }
        
        // ========== Ë¥™ÂøÉÁÆóÊ≥ïËá™Âä®Êí≠ÁßçÁ≥ªÁªü ==========
        let autoPlantState = {
            isRunning: false,
            totalPlanted: 0,
            startCoins: 0,
            isMoving: false,
            targetPosition: { x: 0, z: 0 }
        };
        
        // ========== ÂÆåÊï¥Ëá™Âä®ÂåñÂÜúÂú∫Á≥ªÁªü ==========
        let autoFarmState = {
            isRunning: false,
            currentPhase: '',  // planting, first_water, scan_weeds, remove_weeds, water_remaining, final_scan, spray_pests, water_growth, harvest
            seeds: [],         // ÁßçÂ≠êÂàóË°®
            weeds: [],         // ÊùÇËçâ‰ΩçÁΩÆ
            pests: [],         // ÂÆ≥Ëô´Ê§çÁâ©
            watered: [],       // Â∑≤ÊµáÊ∞¥ÁöÑÁßçÂ≠ê
            mature: [],        // ÊàêÁÜüÊ§çÁâ©
            currentIndex: 0,
            stats: {
                planted: 0,
                weeds_removed: 0,
                watered: 0,
                pests_sprayed: 0,
                harvested: 0
            }
        };
        
        // ËÆ°ÁÆó‰∏§ÁÇπ‰πãÈó¥ÁöÑË∑ùÁ¶ª
        function calculateDistance(x1, z1, x2, z2) {
            return Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
        }
        
        // ÊâæÂà∞Ë∑ùÁ¶ªÂΩìÂâç‰ΩçÁΩÆÊúÄËøëÁöÑÁ©∫Âú∞
        function findNearestEmptyPlot(currentX, currentZ, emptyPlots) {
            let nearestPlot = null;
            let minDistance = Infinity;
            
            for (const plot of emptyPlots) {
                const distance = calculateDistance(currentX, currentZ, plot.position.x, plot.position.z);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPlot = plot;
                }
            }
            
            return { plot: nearestPlot, distance: minDistance };
        }
        
        // Âπ≥ÊªëÁßªÂä®Â∞èËΩ¶Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
        function smoothMoveCart(targetX, targetZ, duration = 800, callback) {
            const startX = cart.position.x;
            const startZ = cart.position.z;
            const startTime = Date.now();
            
            autoPlantState.isMoving = true;
            
            function animate() {
                if (!autoPlantState.isRunning) {
                    autoPlantState.isMoving = false;
                    return;
                }
                
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1.0);
                
                // ‰ΩøÁî®ÁºìÂä®ÂáΩÊï∞Ôºàease-in-outÔºâ
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Êõ¥Êñ∞‰ΩçÁΩÆ
                cart.position.x = startX + (targetX - startX) * eased;
                cart.position.z = startZ + (targetZ - startZ) * eased;
                
                if (progress < 1.0) {
                    requestAnimationFrame(animate);
                } else {
                    cart.position.x = targetX;
                    cart.position.z = targetZ;
                    autoPlantState.isMoving = false;
                    if (callback) callback();
                }
            }
            
            animate();
        }
        
        // ÈÄöÁî®Âπ≥ÊªëÁßªÂä®ÂáΩÊï∞Ôºà‰∏ç‰æùËµñautoPlantState.isRunningÔºâ
        function moveCartTo(targetX, targetZ, duration = 800, callback) {
            const startX = cart.position.x;
            const startZ = cart.position.z;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1.0);
                
                // ‰ΩøÁî®ÁºìÂä®ÂáΩÊï∞Ôºàease-in-outÔºâ
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Êõ¥Êñ∞‰ΩçÁΩÆ
                cart.position.x = startX + (targetX - startX) * eased;
                cart.position.z = startZ + (targetZ - startZ) * eased;
                
                if (progress < 1.0) {
                    requestAnimationFrame(animate);
                } else {
                    cart.position.x = targetX;
                    cart.position.z = targetZ;
                    if (callback) callback();
                }
            }
            
            animate();
        }
        
        // TÈîÆËß¶ÂèëÔºöÂºÄÂßãË¥™ÂøÉÊí≠Áßç
        function startGreedyPlanting() {
            console.log('üå± [TÈîÆ] ÂêØÂä®Ë¥™ÂøÉÁÆóÊ≥ïËá™Âä®Êí≠Áßç');
            
            // Èò≤Ê≠¢ÈáçÂ§çËøêË°å
            if (autoPlantState.isRunning) {
                console.log('‚ö†Ô∏è Êí≠ÁßçÁ≥ªÁªüÊ≠£Âú®ËøêË°å‰∏≠');
                showMessage('‚ö†Ô∏è Êí≠ÁßçÁ≥ªÁªüÊ≠£Âú®ËøêË°å‰∏≠...', 'warning');
                return;
            }
            
            // Ê£ÄÊü•ÈáëÂ∏Å
            if (gameState.coins < 5) {
                console.log('‚ùå ÈáëÂ∏Å‰∏çË∂≥ÔºàÈúÄË¶Å5ÈáëÂ∏ÅÔºâ');
                showMessage('‚ùå ÈáëÂ∏Å‰∏çË∂≥ÔºÅÊØèÈ¢óÁßçÂ≠êÈúÄË¶Å5ÈáëÂ∏Å', 'error');
                return;
            }
            
            // Ëé∑ÂèñÊâÄÊúâÁ©∫Âú∞
            const emptyPlots = gameState.plants.filter(p => p.is_empty && !p.is_removed);
            
            if (emptyPlots.length === 0) {
                console.log('‚ö†Ô∏è Ê≤°ÊúâÂèØÊí≠ÁßçÁöÑÁ©∫Âú∞');
                showMessage('‚ö†Ô∏è Ê≤°ÊúâÂèØÊí≠ÁßçÁöÑÁ©∫Âú∞ÔºÅ', 'warning');
                return;
            }
            
            // ËÆ°ÁÆóÂèØÊí≠ÁßçÊï∞Èáè
            const maxCanPlant = Math.floor(gameState.coins / 5);
            const targetCount = Math.min(maxCanPlant, emptyPlots.length);
            
            console.log(`üìä Êí≠ÁßçËÆ°Âàí: ${targetCount}ÂùóÂú∞ (ÈáëÂ∏Å:${gameState.coins}, Á©∫Âú∞:${emptyPlots.length})`);
            showMessage(`üå± ÂºÄÂßãË¥™ÂøÉÊí≠ÁßçÔºÅÁõÆÊ†á: ${targetCount}ÂùóÂú∞`, 'success');
            
            // ÂàùÂßãÂåñÁä∂ÊÄÅ
            autoPlantState.isRunning = true;
            autoPlantState.totalPlanted = 0;
            autoPlantState.startCoins = gameState.coins;
            
            // ÂºÄÂßãÊí≠ÁßçÂæ™ÁéØ
            plantNextNearest();
        }
        
        // ÈÄíÂΩíÂáΩÊï∞ÔºöÊí≠ÁßçÊúÄËøëÁöÑÁ©∫Âú∞
        function plantNextNearest() {
            // Ê£ÄÊü•ÊòØÂê¶ËøòÂú®ËøêË°å
            if (!autoPlantState.isRunning) {
                console.log('üõë Êí≠ÁßçÁ≥ªÁªüÂ∑≤ÂÅúÊ≠¢');
                return;
            }
            
            // Ê£ÄÊü•ÈáëÂ∏Å
            if (gameState.coins < 5) {
                console.log(`üí∞ ÈáëÂ∏Å‰∏çË∂≥ÔºåÂÅúÊ≠¢Êí≠Áßç`);
                showMessage(`üéâ Êí≠ÁßçÂÆåÊàêÔºÅÂÖ±Êí≠Áßç ${autoPlantState.totalPlanted} ÂùóÂú∞ÔºàÈáëÂ∏Å‰∏çË∂≥Ôºâ`, 'success');
                autoPlantState.isRunning = false;
                
                // üöÄ Ëá™Âä®ÊµÅÁ®ãÔºöÊµáÊ∞¥ ‚Üí Êâ´Êèè ‚Üí Ê∏ÖÈô§ÊùÇËçâ
                console.log('üöÄ ÂêØÂä®Ëá™Âä®ÊµÅÁ®ãÔºöÊµáÊ∞¥ ‚Üí Êâ´Êèè ‚Üí Ê∏ÖÈô§ÊùÇËçâ');
                setTimeout(async () => {
                    // Ê≠•È™§1: ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÂπ∂ÊµáÊ∞¥
                    console.log('üíß [Ê≠•È™§1] ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÂπ∂ÊµáÊ∞¥...');
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    await new Promise(resolve => {
                        moveCartTo(0, 0, 800, resolve);
                    });
                    
                    console.log('üíß Âà∞Ëææ‰∏≠ÂøÉ‰ΩçÁΩÆÔºåÂºÄÂßãÊµáÊ∞¥...');
                    await useWaterAuto();
                    console.log('‚úÖ ÊµáÊ∞¥ÂÆåÊàêÔºÅ');
                    
                    // Á≠âÂæÖÁßçÂ≠êÂèëËäΩ
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Ê≠•È™§2: Âà∑Êñ∞Áä∂ÊÄÅÂπ∂Êâ´ÊèèÊùÇËçâ
                    console.log('üîç [Ê≠•È™§2] Êâ´ÊèèÊùÇËçâ...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞Êâ´ÊèèÂ∑•ÂÖ∑
                    switchEquipment('scanner');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑Êâ´ÊèèÔºàÂíåÊµáÊ∞¥‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                    // Áî±‰∫éÊâ´ÊèèÊòØÊâáÂΩ¢Âå∫ÂüüÔºåÈúÄË¶ÅÊóãËΩ¨Â∞èËΩ¶Âà∞‰∏çÂêåÊñπÂêëÊù•Ë¶ÜÁõñÊâÄÊúâÂå∫Âüü
                    console.log('   ÂºÄÂßãÊâ´ÊèèÊâÄÊúâÊ§çÁâ©...');
                    
                    const weeds = [];
                    const scanDirections = [0, Math.PI/2, Math.PI, -Math.PI/2]; // Âõõ‰∏™ÊñπÂêë
                    
                    for (const angle of scanDirections) {
                        // ÊóãËΩ¨Â∞èËΩ¶Âà∞ÊåáÂÆöÊñπÂêë
                        cart.rotation.y = angle;
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑Ôºâ
                        await useScannerAuto();
                        
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Âà∑Êñ∞Áä∂ÊÄÅÔºå‰ªégameState‰∏≠Ëé∑ÂèñÊâÄÊúâÊ§çÁâ©‰ø°ÊÅØÔºàÊâ´ÊèèÂêéÁä∂ÊÄÅÂ∑≤Êõ¥Êñ∞Ôºâ
                    await refreshGameState();
                    const allPlants = gameState.plants.filter(p => !p.is_empty && !p.is_removed);
                    
                    // ÊâæÂá∫ÊùÇËçâ
                    for (const plant of allPlants) {
                        if (plant.is_weed) {
                            weeds.push({
                                id: plant.id,
                                position: plant.position
                            });
                            console.log(`   ‚úì ÂèëÁé∞ÊùÇËçâ: ${plant.id} ‰ΩçÁΩÆ(${plant.position.x.toFixed(2)}, ${plant.position.z.toFixed(2)})`);
                        }
                    }
                    
                    console.log(`   Êâ´ÊèèÂÆåÊàêÔºåÂèëÁé∞ ${weeds.length} Ê†™ÊùÇËçâ`);
                    
                    if (weeds.length === 0) {
                        console.log('‚úÖ Ê≤°ÊúâÊùÇËçâÔºåÊµÅÁ®ãÂÆåÊàêÔºÅ');
                        return;
                    }
                    
                    // Ê≠•È™§3: ÂàáÊç¢Âà∞ÊøÄÂÖâÂ∑•ÂÖ∑Âπ∂Ê∏ÖÈô§ÊùÇËçâ
                    console.log(`üî´ [Ê≠•È™§3] Ê∏ÖÈô§ ${weeds.length} Ê†™ÊùÇËçâ...`);
                    switchEquipment('laser');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    for (const weed of weeds) {
                        console.log(`   Ê∏ÖÈô§ÊùÇËçâ: ${weed.id} ‰ΩçÁΩÆ(${weed.position.x.toFixed(2)}, ${weed.position.z.toFixed(2)})`);
                        
                        // ËÆ°ÁÆóÊùÇËçâÈôÑËøëÁöÑ‰ΩçÁΩÆÔºàË∑ùÁ¶ª0.8Á±≥ÔºåÈÅøÂÖçÂéãÂà∞ÊùÇËçâÔºâ
                        const offsetDistance = 0.8;
                        // ËÆ°ÁÆó‰ªéÂΩìÂâç‰ΩçÁΩÆÂà∞ÊùÇËçâÁöÑÊñπÂêë
                        const currentX = cart.position.x;
                        const currentZ = cart.position.z;
                        const dx = weed.position.x - currentX;
                        const dz = weed.position.z - currentZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        let nearX, nearZ;
                        if (distance > 0) {
                            // ÁßªÂä®Âà∞ÊùÇËçâÈôÑËøëÔºàË∑ùÁ¶ª0.8Á±≥Ôºâ
                            const ratio = (distance - offsetDistance) / distance;
                            nearX = currentX + dx * ratio;
                            nearZ = currentZ + dz * ratio;
                        } else {
                            // Â¶ÇÊûúÂ∑≤ÁªèÂú®ÊùÇËçâ‰ΩçÁΩÆÔºåÁßªÂä®Âà∞Âè≥ÂâçÊñπ
                            nearX = weed.position.x + offsetDistance * 0.707; // cos(45¬∞)
                            nearZ = weed.position.z + offsetDistance * 0.707; // sin(45¬∞)
                        }
                        
                        console.log(`   ÁßªÂä®Âà∞ÈôÑËøë‰ΩçÁΩÆ: (${nearX.toFixed(2)}, ${nearZ.toFixed(2)})`);
                        
                        // ÁßªÂä®Âà∞ÊùÇËçâÈôÑËøë
                        await new Promise(resolve => {
                            moveCartTo(nearX, nearZ, 600, resolve);
                        });
                        
                        // Á≠âÂæÖÁßªÂä®ÂÆåÊàê
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // ‰ΩøÁî®ÊøÄÂÖâÂ∑•ÂÖ∑ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                        await useAutoLaser();
                        
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    console.log('‚úÖ ÊùÇËçâÊ∏ÖÈô§ÂÆåÊàêÔºÅ');
                    
                    // Ê≠•È™§4: ÁªôÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠êÊµáÊ∞¥
                    console.log('üíß [Ê≠•È™§4] ÁªôÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠êÊµáÊ∞¥...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÊµáÊ∞¥Â∑•ÂÖ∑
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠ê
                    const unwateredSeeds = gameState.plants.filter(p => p.is_seed && !p.is_weed && !p.is_removed);
                    console.log(`   ÊâæÂà∞ ${unwateredSeeds.length} È¢óÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠ê`);
                    
                    if (unwateredSeeds.length > 0) {
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÊµáÊ∞¥
                        const waterRange = equipmentConfig.water.range; // 2.2
                        let remainingSeeds = [...unwateredSeeds];
                        let wateringRound = 0;
                        
                        while (remainingSeeds.length > 0 && wateringRound < 50) {
                            wateringRound++;
                            
                            // ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÁßçÂ≠êÁöÑ‰ΩçÁΩÆ
                            let bestPosition = null;
                            let maxCoverage = 0;
                            let coveredSeeds = [];
                            
                            for (const seed of remainingSeeds) {
                                const seedsInRange = remainingSeeds.filter(s => 
                                    calculateDistance(seed.position.x, seed.position.z, s.position.x, s.position.z) <= waterRange
                                );
                                
                                if (seedsInRange.length > maxCoverage) {
                                    maxCoverage = seedsInRange.length;
                                    bestPosition = { x: seed.position.x, z: seed.position.z };
                                    coveredSeeds = seedsInRange;
                                }
                            }
                            
                            if (!bestPosition) break;
                            
                            // ÁßªÂä®Âà∞ÊúÄ‰ºò‰ΩçÁΩÆ
                            await new Promise(resolve => {
                                moveCartTo(bestPosition.x, bestPosition.z, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ÊâßË°åÊµáÊ∞¥
                            await useWaterAuto();
                            
                            // ‰ªéÂæÖÊµáÊ∞¥ÂàóË°®‰∏≠ÁßªÈô§
                            remainingSeeds = remainingSeeds.filter(s => 
                                !coveredSeeds.some(cs => cs.id === s.id)
                            );
                            
                            // Âà∑Êñ∞Áä∂ÊÄÅ
                            await refreshGameState();
                            remainingSeeds = remainingSeeds.filter(s => {
                                const updated = gameState.plants.find(p => p.id === s.id);
                                return updated && updated.is_seed && !updated.is_weed;
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 400));
                        }
                        
                        console.log(`‚úÖ Ë°•ÂÖÖÊµáÊ∞¥ÂÆåÊàêÔºÅ`);
                        
                        // Á≠âÂæÖÁßçÂ≠êÂèëËäΩ
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    // Ê≠•È™§5: ÂÜçÊ¨°Êâ´ÊèèÊùÇËçâ
                    console.log('üîç [Ê≠•È™§5] ÂÜçÊ¨°Êâ´ÊèèÊùÇËçâ...');
                    await refreshGameState();
                    
                    // ÂÖàÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÔºåÁ°Æ‰øùËÉΩÊâ´ÊèèÂà∞Êï¥‰∏™ÂÜúÁî∞
                    console.log('   ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆËøõË°åÊâ´Êèè...');
                    await new Promise(resolve => {
                        moveCartTo(0, 0, 800, resolve);
                    });
                    
                    // ÂàáÊç¢Âà∞Êâ´ÊèèÂ∑•ÂÖ∑
                    switchEquipment('scanner');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑Êâ´ÊèèÔºàÂõõ‰∏™ÊñπÂêëÔºâ
                    const scanDirs = [0, Math.PI/2, Math.PI, -Math.PI/2];
                    
                    for (const angle of scanDirs) {
                        cart.rotation.y = angle;
                        await new Promise(resolve => setTimeout(resolve, 200));
                        await useScannerAuto();
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Âà∑Êñ∞Áä∂ÊÄÅÔºåÊâæÂá∫ÊùÇËçâ
                    await refreshGameState();
                    const newWeeds = gameState.plants.filter(p => p.is_weed && !p.is_removed);
                    console.log(`   Êâ´ÊèèÂÆåÊàêÔºåÂèëÁé∞ ${newWeeds.length} Ê†™Êñ∞ÊùÇËçâ`);
                    
                    if (newWeeds.length > 0) {
                        // Ê≠•È™§6: ÂÜçÊ¨°Ê∏ÖÈô§ÊùÇËçâ
                        console.log(`üî´ [Ê≠•È™§6] Ê∏ÖÈô§ ${newWeeds.length} Ê†™Êñ∞ÊùÇËçâ...`);
                        switchEquipment('laser');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        for (const weed of newWeeds) {
                            console.log(`   Ê∏ÖÈô§ÊùÇËçâ: ${weed.id} ‰ΩçÁΩÆ(${weed.position.x.toFixed(2)}, ${weed.position.z.toFixed(2)})`);
                            
                            // ËÆ°ÁÆóÊùÇËçâÈôÑËøëÁöÑ‰ΩçÁΩÆ
                            const offsetDistance = 0.8;
                            const currentX = cart.position.x;
                            const currentZ = cart.position.z;
                            const dx = weed.position.x - currentX;
                            const dz = weed.position.z - currentZ;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            let nearX, nearZ;
                            if (distance > 0) {
                                const ratio = (distance - offsetDistance) / distance;
                                nearX = currentX + dx * ratio;
                                nearZ = currentZ + dz * ratio;
                            } else {
                                nearX = weed.position.x + offsetDistance * 0.707;
                                nearZ = weed.position.z + offsetDistance * 0.707;
                            }
                            
                            await new Promise(resolve => {
                                moveCartTo(nearX, nearZ, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 300));
                            await useAutoLaser();
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                        console.log('‚úÖ Êñ∞ÊùÇËçâÊ∏ÖÈô§ÂÆåÊàêÔºÅ');
                    } else {
                        console.log('‚úÖ Ê≤°ÊúâÊñ∞ÊùÇËçâÔºÅ');
                    }
                    
                    // Ê≠•È™§7: ÂúüÂ£§Êé¢ÊµãÔºàÈÄê‰∏™Ê†ºÂ≠êÊé¢ÊµãÔºâ
                    console.log('üß™ [Ê≠•È™§7] ÂºÄÂßãÂúüÂ£§Êé¢Êµã...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÂúüÂ£§Êé¢ÊµãÂô®
                    switchEquipment('soil');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊ§çÁâ©ÔºàÈúÄË¶ÅÊé¢ÊµãÁöÑÊ†ºÂ≠êÔºâ
                    const allPlantsToDetect = gameState.plants.filter(p => !p.is_empty && !p.is_removed);
                    console.log(`   ÈúÄË¶ÅÊé¢Êµã ${allPlantsToDetect.length} ‰∏™Ê†ºÂ≠ê`);
                    
                    let detectedCount = 0;
                    
                    // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ÊúÄËøëÁöÑÊú™Êé¢ÊµãÊ§çÁâ©
                    while (allPlantsToDetect.length > 0 && detectedCount < 100) {
                        const currentX = cart.position.x;
                        const currentZ = cart.position.z;
                        
                        // ÊâæÂà∞ÊúÄËøëÁöÑÊ§çÁâ©
                        let nearestPlant = null;
                        let minDistance = Infinity;
                        
                        for (const plant of allPlantsToDetect) {
                            const distance = calculateDistance(currentX, currentZ, plant.position.x, plant.position.z);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestPlant = plant;
                            }
                        }
                        
                        if (!nearestPlant) break;
                        
                        console.log(`   Êé¢Êµã: ${nearestPlant.id} ‰ΩçÁΩÆ(${nearestPlant.position.x.toFixed(2)}, ${nearestPlant.position.z.toFixed(2)})`);
                        
                        // ÁßªÂä®Âà∞Ê§çÁâ©‰ΩçÁΩÆ
                        await new Promise(resolve => {
                            moveCartTo(nearestPlant.position.x, nearestPlant.position.z, 600, resolve);
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        // ‰ΩøÁî®ÂúüÂ£§Êé¢ÊµãÂô®ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                        await useSoilProbeAuto();
                        
                        // ‰ªéÂæÖÊé¢ÊµãÂàóË°®‰∏≠ÁßªÈô§
                        const index = allPlantsToDetect.findIndex(p => p.id === nearestPlant.id);
                        if (index > -1) {
                            allPlantsToDetect.splice(index, 1);
                        }
                        
                        detectedCount++;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    console.log(`‚úÖ ÂúüÂ£§Êé¢ÊµãÂÆåÊàêÔºÅÂÖ±Êé¢Êµã ${detectedCount} ‰∏™Ê†ºÂ≠ê`);
                    
                    // Ê≠•È™§8: ÁªôÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©Âñ∑Ê¥íÂÜúËçØ
                    console.log('üß¥ [Ê≠•È™§8] ÂºÄÂßãÂñ∑Ê¥íÂÜúËçØ...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÂÜúËçØÂñ∑Ê¥íÂô®
                    switchEquipment('spray');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©
                    const pestPlants = gameState.plants.filter(p => p.has_pests && !p.is_removed);
                    console.log(`   ÊâæÂà∞ ${pestPlants.length} Ê†™ÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©`);
                    
                    if (pestPlants.length > 0) {
                        let sprayedCount = 0;
                        
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ÊúÄËøëÁöÑÊú™Âñ∑Ê¥íÊ§çÁâ©
                        const remainingPests = [...pestPlants];
                        
                        while (remainingPests.length > 0 && sprayedCount < 100) {
                            const currentX = cart.position.x;
                            const currentZ = cart.position.z;
                            
                            // ÊâæÂà∞ÊúÄËøëÁöÑÊ§çÁâ©
                            let nearestPlant = null;
                            let minDistance = Infinity;
                            
                            for (const plant of remainingPests) {
                                const distance = calculateDistance(currentX, currentZ, plant.position.x, plant.position.z);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestPlant = plant;
                                }
                            }
                            
                            if (!nearestPlant) break;
                            
                            console.log(`   Âñ∑Ê¥í: ${nearestPlant.id} ‰ΩçÁΩÆ(${nearestPlant.position.x.toFixed(2)}, ${nearestPlant.position.z.toFixed(2)})`);
                            
                            // ËÆ°ÁÆóÊ§çÁâ©ÈôÑËøëÁöÑ‰ΩçÁΩÆÔºàË∑ùÁ¶ª0.8Á±≥ÔºåÈÅøÂÖçÂéãÂà∞Ê§çÁâ©Ôºâ
                            const offsetDistance = 0.8;
                            const dx = nearestPlant.position.x - currentX;
                            const dz = nearestPlant.position.z - currentZ;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            let nearX, nearZ;
                            if (distance > 0) {
                                const ratio = (distance - offsetDistance) / distance;
                                nearX = currentX + dx * ratio;
                                nearZ = currentZ + dz * ratio;
                            } else {
                                nearX = nearestPlant.position.x + offsetDistance * 0.707;
                                nearZ = nearestPlant.position.z + offsetDistance * 0.707;
                            }
                            
                            // ÁßªÂä®Âà∞Ê§çÁâ©ÈôÑËøë
                            await new Promise(resolve => {
                                moveCartTo(nearX, nearZ, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ÊóãËΩ¨Â∞èËΩ¶ÊúùÂêëÊ§çÁâ©ÔºàÁ°Æ‰øùÊ§çÁâ©Âú®ÊâáÂΩ¢ËåÉÂõ¥ÂÜÖÔºâ
                            const targetAngle = Math.atan2(
                                nearestPlant.position.x - nearX,
                                nearestPlant.position.z - nearZ
                            );
                            cart.rotation.y = targetAngle;
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ‰ΩøÁî®ÂÜúËçØÂñ∑Ê¥íÂô®ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                            await useSprayAuto();
                            
                            // ‰ªéÂæÖÂñ∑Ê¥íÂàóË°®‰∏≠ÁßªÈô§
                            const index = remainingPests.findIndex(p => p.id === nearestPlant.id);
                            if (index > -1) {
                                remainingPests.splice(index, 1);
                            }
                            
                            sprayedCount++;
                            
                            // Âà∑Êñ∞Áä∂ÊÄÅÔºåÊõ¥Êñ∞ÂÆ≥Ëô´‰ø°ÊÅØ
                            await refreshGameState();
                            const updatedPests = gameState.plants.filter(p => p.has_pests && !p.is_removed);
                            remainingPests.length = 0;
                            remainingPests.push(...updatedPests.filter(p => 
                                pestPlants.some(pp => pp.id === p.id)
                            ));
                            
                            await new Promise(resolve => setTimeout(resolve, 400));
                        }
                        
                        console.log(`‚úÖ ÂÜúËçØÂñ∑Ê¥íÂÆåÊàêÔºÅÂÖ±Â§ÑÁêÜ ${sprayedCount} Ê†™Ê§çÁâ©`);
                    } else {
                        console.log('‚úÖ Ê≤°ÊúâÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©ÔºÅ');
                    }
                    
                    // Ê≠•È™§9: ÊåÅÁª≠ÊµáÊ∞¥Áõ¥Âà∞ÊâÄÊúâÊ§çÁâ©ÊàêÁÜü
                    console.log('üíß [Ê≠•È™§9] ÊåÅÁª≠ÊµáÊ∞¥Áõ¥Âà∞ÊâÄÊúâÊ§çÁâ©ÊàêÁÜü...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÊµáÊ∞¥Â∑•ÂÖ∑
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const waterRange = equipmentConfig.water.range; // 2.2
                    let maxRounds = 15; // ÊúÄÂ§öÊµáÊ∞¥15ËΩÆ
                    let round = 0;
                    
                    while (round < maxRounds) {
                        await refreshGameState();
                        
                        const plants = gameState.plants.filter(p => p.is_vegetable && !p.is_removed);
                        const maturePlants = plants.filter(p => p.growth_stage >= 3);
                        
                        console.log(`   Á¨¨${round + 1}ËΩÆÊµáÊ∞¥: ${plants.length}Ê†™Ê§çÁâ©, ${maturePlants.length}Ê†™ÊàêÁÜü`);
                        
                        if (maturePlants.length === plants.length && plants.length > 0) {
                            console.log('   ‚úÖ ÊâÄÊúâÊ§çÁâ©Â∑≤ÊàêÁÜüÔºÅ');
                            break;
                        }
                        
                        // ÊµáÊ∞¥ÊâÄÊúâÊú™ÊàêÁÜüÁöÑÊ§çÁâ© - ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ï
                        let immaturePlants = plants.filter(p => p.growth_stage < 3);
                        let wateringRound = 0;
                        
                        while (immaturePlants.length > 0 && wateringRound < 20) {
                            wateringRound++;
                            
                            let bestPosition = null;
                            let maxCoverage = 0;
                            let coveredPlants = [];
                            
                            for (const plant of immaturePlants) {
                                const plantsInRange = immaturePlants.filter(p => 
                                    calculateDistance(plant.position.x, plant.position.z, p.position.x, p.position.z) <= waterRange
                                );
                                
                                if (plantsInRange.length > maxCoverage) {
                                    maxCoverage = plantsInRange.length;
                                    bestPosition = { x: plant.position.x, z: plant.position.z };
                                    coveredPlants = plantsInRange;
                                }
                            }
                            
                            if (!bestPosition) break;
                            
                            await new Promise(resolve => {
                                moveCartTo(bestPosition.x, bestPosition.z, 400, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 150));
                            await useWaterAuto();
                            
                            immaturePlants = immaturePlants.filter(p => 
                                !coveredPlants.some(cp => cp.id === p.id)
                            );
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                        round++;
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    console.log(`‚úÖ ÊåÅÁª≠ÊµáÊ∞¥ÂÆåÊàêÔºÅ`);
                    
                    // Ê≠•È™§10: Êî∂Ëé∑ÊàêÁÜüÊ§çÁâ©Ôºà‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºåËßÑÂàíÁúÅÂäõË∑ØÂæÑÔºâ
                    console.log('üåæ [Ê≠•È™§10] ÂºÄÂßãÊî∂Ëé∑ÊàêÁÜüÊ§çÁâ©...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞Êú∫Ê¢∞ËáÇ
                    switchEquipment('arm');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊàêÁÜüÊ§çÁâ©
                    const maturePlants = gameState.plants.filter(p => 
                        p.is_vegetable && !p.is_removed && p.growth_stage >= 3
                    );
                    console.log(`   ÊàêÁÜüÊ§çÁâ©: ${maturePlants.length}Ê†™`);
                    
                    if (maturePlants.length === 0) {
                        console.log('‚úÖ Ê≤°ÊúâÊàêÁÜüÊ§çÁâ©ÔºÅ');
                    } else {
                        // ËÆ°ÁÆóÂÜúÁî∞Ê†ºÂ≠ê‰∏≠ÂøÉ‰ΩçÁΩÆÔºà8x8ÁΩëÊ†ºÔºåÊØè‰∏™Ê†ºÂ≠ê0.5Á±≥Ôºâ
                        const cellSize = 0.5;
                        const offsetX = -2.0;
                        const offsetZ = -2.0;
                        const armRange = equipmentConfig.arm.range; // 0.9Á±≥
                        
                        // Ëé∑ÂèñÊâÄÊúâÊ†ºÂ≠ê‰∏≠ÂøÉ‰ΩçÁΩÆ
                        const gridCenters = [];
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 8; col++) {
                                const x = offsetX + col * cellSize + cellSize / 2;
                                const z = offsetZ + row * cellSize + cellSize / 2;
                                gridCenters.push({ x, z, row, col });
                            }
                        }
                        
                        let remainingPlants = [...maturePlants];
                        let harvestRound = 0;
                        let totalHarvested = 0;
                        
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊú™Êî∂Ëé∑Ê§çÁâ©ÁöÑÊ†ºÂ≠ê‰∏≠ÂøÉ
                        while (harvestRound < 100) {
                            // ‚ö†Ô∏è Áõ¥Êé•‰ªéÊú¨Âú∞gameState.plantsËé∑ÂèñÊàêÁÜüÊ§çÁâ©ÂàóË°®Ôºå‰∏çÈúÄË¶ÅÂà∑Êñ∞Áä∂ÊÄÅ
                            // useArmHarvestAuto()Â∑≤ÁªèÊõ¥Êñ∞‰∫ÜÊú¨Âú∞Áä∂ÊÄÅÔºåÂà∑Êñ∞‰ºöÂØºËá¥Ê§çÁâ©Ë¢´ÈáçÊñ∞ÂàõÂª∫
                            const currentMature = gameState.plants.filter(p => 
                                p.is_vegetable && !p.is_removed && p.growth_stage >= 3 && !p.is_empty
                            );
                            
                            if (currentMature.length === 0) {
                                console.log('   ÊâÄÊúâÊ§çÁâ©Â∑≤Êî∂Ëé∑ÂÆåÊàêÔºÅ');
                                break;
                            }
                            
                            remainingPlants = currentMature;
                            harvestRound++;
                            
                            let bestCenter = null;
                            let maxCoverage = 0;
                            let coveredPlants = [];
                            
                            // ÈÅçÂéÜÊâÄÊúâÊ†ºÂ≠ê‰∏≠ÂøÉÔºåÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊ§çÁâ©ÁöÑ‰ΩçÁΩÆ
                            for (const center of gridCenters) {
                                const plantsInRange = remainingPlants.filter(p => 
                                    calculateDistance(center.x, center.z, p.position.x, p.position.z) <= armRange
                                );
                                
                                if (plantsInRange.length > maxCoverage) {
                                    maxCoverage = plantsInRange.length;
                                    bestCenter = center;
                                    coveredPlants = plantsInRange;
                                }
                            }
                            
                            if (!bestCenter || maxCoverage === 0) break;
                            
                            console.log(`   Êî∂Ëé∑ÁÇπ${harvestRound}: Ê†ºÂ≠ê(${bestCenter.row},${bestCenter.col}) Ë¶ÜÁõñ${maxCoverage}Ê†™Ê§çÁâ©`);
                            
                            // ÁßªÂä®Âà∞Ê†ºÂ≠ê‰∏≠ÂøÉ
                            await new Promise(resolve => {
                                moveCartTo(bestCenter.x, bestCenter.z, 600, resolve);
                            });
                            
                            // ÊóãËΩ¨ËΩ¶Ë∫´‰∏éÁΩëÊ†ºÂπ≥Ë°åÔºà0Â∫¶ÔºåÊúùÂåóÔºâ
                            cart.rotation.y = 0;
                            await new Promise(resolve => setTimeout(resolve, 300));
                            
                            // Âæ™ÁéØÊî∂Ëé∑ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©ÔºåÁõ¥Âà∞ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊ§çÁâ©
                            const totalHarvestedRef = { value: totalHarvested };
                            const localHarvestCount = await harvestPlantsInRange(armRange, totalHarvestedRef);
                            totalHarvested = totalHarvestedRef.value;
                            
                            // ‰ªéÂæÖÊî∂Ëé∑ÂàóË°®‰∏≠ÁßªÈô§Â∑≤Êî∂Ëé∑ÁöÑÊ§çÁâ©ÔºàÂ∑≤Âú®Âæ™ÁéØ‰∏≠Âà∑Êñ∞Áä∂ÊÄÅÔºâ
                            // remainingPlants ‰ºöÂú®‰∏ãÊ¨°Âæ™ÁéØÂºÄÂßãÊó∂ÈÄöËøáÂà∑Êñ∞Áä∂ÊÄÅÊõ¥Êñ∞
                            
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                        
                        console.log(`‚úÖ Êî∂Ëé∑ÂÆåÊàêÔºÅÂÖ±Êî∂Ëé∑ ${totalHarvested} Ê†™Ê§çÁâ©`);
                    }
                    
                    console.log('üéâ ÂÆåÊï¥ÊµÅÁ®ãÂÆåÊàêÔºÅ');
                }, 1000);
                return;
            }
            
            // Ëé∑ÂèñÊâÄÊúâÁ©∫Âú∞
            const emptyPlots = gameState.plants.filter(p => p.is_empty && !p.is_removed);
            
            if (emptyPlots.length === 0) {
                console.log(`‚úÖ ÊâÄÊúâÁ©∫Âú∞Â∑≤Êí≠ÁßçÂÆåÊØï`);
                showMessage(`üéâ Êí≠ÁßçÂÆåÊàêÔºÅÂÖ±Êí≠Áßç ${autoPlantState.totalPlanted} ÂùóÂú∞ÔºàÂÖ®ÈÉ®ÂÆåÊàêÔºâ`, 'success');
                autoPlantState.isRunning = false;
                
                // üöÄ Ëá™Âä®ÊµÅÁ®ãÔºöÊµáÊ∞¥ ‚Üí Êâ´Êèè ‚Üí Ê∏ÖÈô§ÊùÇËçâ
                console.log('üöÄ ÂêØÂä®Ëá™Âä®ÊµÅÁ®ãÔºöÊµáÊ∞¥ ‚Üí Êâ´Êèè ‚Üí Ê∏ÖÈô§ÊùÇËçâ');
                setTimeout(async () => {
                    // Ê≠•È™§1: ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÂπ∂ÊµáÊ∞¥
                    console.log('üíß [Ê≠•È™§1] ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÂπ∂ÊµáÊ∞¥...');
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    await new Promise(resolve => {
                        moveCartTo(0, 0, 800, resolve);
                    });
                    
                    console.log('üíß Âà∞Ëææ‰∏≠ÂøÉ‰ΩçÁΩÆÔºåÂºÄÂßãÊµáÊ∞¥...');
                    await useWaterAuto();
                    console.log('‚úÖ ÊµáÊ∞¥ÂÆåÊàêÔºÅ');
                    
                    // Á≠âÂæÖÁßçÂ≠êÂèëËäΩ
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Ê≠•È™§2: Âà∑Êñ∞Áä∂ÊÄÅÂπ∂Êâ´ÊèèÊùÇËçâ
                    console.log('üîç [Ê≠•È™§2] Êâ´ÊèèÊùÇËçâ...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞Êâ´ÊèèÂ∑•ÂÖ∑
                    switchEquipment('scanner');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑Êâ´ÊèèÔºàÂíåÊµáÊ∞¥‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                    // Áî±‰∫éÊâ´ÊèèÊòØÊâáÂΩ¢Âå∫ÂüüÔºåÈúÄË¶ÅÊóãËΩ¨Â∞èËΩ¶Âà∞‰∏çÂêåÊñπÂêëÊù•Ë¶ÜÁõñÊâÄÊúâÂå∫Âüü
                    console.log('   ÂºÄÂßãÊâ´ÊèèÊâÄÊúâÊ§çÁâ©...');
                    
                    const weeds = [];
                    const scanDirections = [0, Math.PI/2, Math.PI, -Math.PI/2]; // Âõõ‰∏™ÊñπÂêë
                    
                    for (const angle of scanDirections) {
                        // ÊóãËΩ¨Â∞èËΩ¶Âà∞ÊåáÂÆöÊñπÂêë
                        cart.rotation.y = angle;
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑Ôºâ
                        await useScannerAuto();
                        
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Âà∑Êñ∞Áä∂ÊÄÅÔºå‰ªégameState‰∏≠Ëé∑ÂèñÊâÄÊúâÊ§çÁâ©‰ø°ÊÅØÔºàÊâ´ÊèèÂêéÁä∂ÊÄÅÂ∑≤Êõ¥Êñ∞Ôºâ
                    await refreshGameState();
                    const allPlants = gameState.plants.filter(p => !p.is_empty && !p.is_removed);
                    
                    // ÊâæÂá∫ÊùÇËçâ
                    for (const plant of allPlants) {
                        if (plant.is_weed) {
                            weeds.push({
                                id: plant.id,
                                position: plant.position
                            });
                            console.log(`   ‚úì ÂèëÁé∞ÊùÇËçâ: ${plant.id} ‰ΩçÁΩÆ(${plant.position.x.toFixed(2)}, ${plant.position.z.toFixed(2)})`);
                        }
                    }
                    
                    console.log(`   Êâ´ÊèèÂÆåÊàêÔºåÂèëÁé∞ ${weeds.length} Ê†™ÊùÇËçâ`);
                    
                    if (weeds.length === 0) {
                        console.log('‚úÖ Ê≤°ÊúâÊùÇËçâÔºåÊµÅÁ®ãÂÆåÊàêÔºÅ');
                        return;
                    }
                    
                    // Ê≠•È™§3: ÂàáÊç¢Âà∞ÊøÄÂÖâÂ∑•ÂÖ∑Âπ∂Ê∏ÖÈô§ÊùÇËçâ
                    console.log(`üî´ [Ê≠•È™§3] Ê∏ÖÈô§ ${weeds.length} Ê†™ÊùÇËçâ...`);
                    switchEquipment('laser');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    for (const weed of weeds) {
                        console.log(`   Ê∏ÖÈô§ÊùÇËçâ: ${weed.id} ‰ΩçÁΩÆ(${weed.position.x.toFixed(2)}, ${weed.position.z.toFixed(2)})`);
                        
                        // ËÆ°ÁÆóÊùÇËçâÈôÑËøëÁöÑ‰ΩçÁΩÆÔºàË∑ùÁ¶ª0.8Á±≥ÔºåÈÅøÂÖçÂéãÂà∞ÊùÇËçâÔºâ
                        const offsetDistance = 0.8;
                        // ËÆ°ÁÆó‰ªéÂΩìÂâç‰ΩçÁΩÆÂà∞ÊùÇËçâÁöÑÊñπÂêë
                        const currentX = cart.position.x;
                        const currentZ = cart.position.z;
                        const dx = weed.position.x - currentX;
                        const dz = weed.position.z - currentZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        let nearX, nearZ;
                        if (distance > 0) {
                            // ÁßªÂä®Âà∞ÊùÇËçâÈôÑËøëÔºàË∑ùÁ¶ª0.8Á±≥Ôºâ
                            const ratio = (distance - offsetDistance) / distance;
                            nearX = currentX + dx * ratio;
                            nearZ = currentZ + dz * ratio;
                        } else {
                            // Â¶ÇÊûúÂ∑≤ÁªèÂú®ÊùÇËçâ‰ΩçÁΩÆÔºåÁßªÂä®Âà∞Âè≥ÂâçÊñπ
                            nearX = weed.position.x + offsetDistance * 0.707; // cos(45¬∞)
                            nearZ = weed.position.z + offsetDistance * 0.707; // sin(45¬∞)
                        }
                        
                        console.log(`   ÁßªÂä®Âà∞ÈôÑËøë‰ΩçÁΩÆ: (${nearX.toFixed(2)}, ${nearZ.toFixed(2)})`);
                        
                        // ÁßªÂä®Âà∞ÊùÇËçâÈôÑËøë
                        await new Promise(resolve => {
                            moveCartTo(nearX, nearZ, 600, resolve);
                        });
                        
                        // Á≠âÂæÖÁßªÂä®ÂÆåÊàê
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // ‰ΩøÁî®ÊøÄÂÖâÂ∑•ÂÖ∑ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                        await useAutoLaser();
                        
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    console.log('‚úÖ ÊùÇËçâÊ∏ÖÈô§ÂÆåÊàêÔºÅ');
                    
                    // Ê≠•È™§4: ÁªôÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠êÊµáÊ∞¥
                    console.log('üíß [Ê≠•È™§4] ÁªôÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠êÊµáÊ∞¥...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÊµáÊ∞¥Â∑•ÂÖ∑
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠ê
                    const unwateredSeeds = gameState.plants.filter(p => p.is_seed && !p.is_weed && !p.is_removed);
                    console.log(`   ÊâæÂà∞ ${unwateredSeeds.length} È¢óÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠ê`);
                    
                    if (unwateredSeeds.length > 0) {
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÊµáÊ∞¥
                        const waterRange = equipmentConfig.water.range; // 2.2
                        let remainingSeeds = [...unwateredSeeds];
                        let wateringRound = 0;
                        
                        while (remainingSeeds.length > 0 && wateringRound < 50) {
                            wateringRound++;
                            
                            // ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÁßçÂ≠êÁöÑ‰ΩçÁΩÆ
                            let bestPosition = null;
                            let maxCoverage = 0;
                            let coveredSeeds = [];
                            
                            for (const seed of remainingSeeds) {
                                const seedsInRange = remainingSeeds.filter(s => 
                                    calculateDistance(seed.position.x, seed.position.z, s.position.x, s.position.z) <= waterRange
                                );
                                
                                if (seedsInRange.length > maxCoverage) {
                                    maxCoverage = seedsInRange.length;
                                    bestPosition = { x: seed.position.x, z: seed.position.z };
                                    coveredSeeds = seedsInRange;
                                }
                            }
                            
                            if (!bestPosition) break;
                            
                            // ÁßªÂä®Âà∞ÊúÄ‰ºò‰ΩçÁΩÆ
                            await new Promise(resolve => {
                                moveCartTo(bestPosition.x, bestPosition.z, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ÊâßË°åÊµáÊ∞¥
                            await useWaterAuto();
                            
                            // ‰ªéÂæÖÊµáÊ∞¥ÂàóË°®‰∏≠ÁßªÈô§
                            remainingSeeds = remainingSeeds.filter(s => 
                                !coveredSeeds.some(cs => cs.id === s.id)
                            );
                            
                            // Âà∑Êñ∞Áä∂ÊÄÅ
                            await refreshGameState();
                            remainingSeeds = remainingSeeds.filter(s => {
                                const updated = gameState.plants.find(p => p.id === s.id);
                                return updated && updated.is_seed && !updated.is_weed;
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 400));
                        }
                        
                        console.log(`‚úÖ Ë°•ÂÖÖÊµáÊ∞¥ÂÆåÊàêÔºÅ`);
                        
                        // Á≠âÂæÖÁßçÂ≠êÂèëËäΩ
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    // Ê≠•È™§5: ÂÜçÊ¨°Êâ´ÊèèÊùÇËçâ
                    console.log('üîç [Ê≠•È™§5] ÂÜçÊ¨°Êâ´ÊèèÊùÇËçâ...');
                    await refreshGameState();
                    
                    // ÂÖàÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆÔºåÁ°Æ‰øùËÉΩÊâ´ÊèèÂà∞Êï¥‰∏™ÂÜúÁî∞
                    console.log('   ÁßªÂä®Âà∞‰∏≠ÂøÉ‰ΩçÁΩÆËøõË°åÊâ´Êèè...');
                    await new Promise(resolve => {
                        moveCartTo(0, 0, 800, resolve);
                    });
                    
                    // ÂàáÊç¢Âà∞Êâ´ÊèèÂ∑•ÂÖ∑
                    switchEquipment('scanner');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // ‰ΩøÁî®Êâ´ÊèèÂ∑•ÂÖ∑Êâ´ÊèèÔºàÂõõ‰∏™ÊñπÂêëÔºâ
                    const scanDirs = [0, Math.PI/2, Math.PI, -Math.PI/2];
                    
                    for (const angle of scanDirs) {
                        cart.rotation.y = angle;
                        await new Promise(resolve => setTimeout(resolve, 200));
                        await useScannerAuto();
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Âà∑Êñ∞Áä∂ÊÄÅÔºåÊâæÂá∫ÊùÇËçâ
                    await refreshGameState();
                    const newWeeds = gameState.plants.filter(p => p.is_weed && !p.is_removed);
                    console.log(`   Êâ´ÊèèÂÆåÊàêÔºåÂèëÁé∞ ${newWeeds.length} Ê†™Êñ∞ÊùÇËçâ`);
                    
                    if (newWeeds.length > 0) {
                        // Ê≠•È™§6: ÂÜçÊ¨°Ê∏ÖÈô§ÊùÇËçâ
                        console.log(`üî´ [Ê≠•È™§6] Ê∏ÖÈô§ ${newWeeds.length} Ê†™Êñ∞ÊùÇËçâ...`);
                        switchEquipment('laser');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        for (const weed of newWeeds) {
                            console.log(`   Ê∏ÖÈô§ÊùÇËçâ: ${weed.id} ‰ΩçÁΩÆ(${weed.position.x.toFixed(2)}, ${weed.position.z.toFixed(2)})`);
                            
                            // ËÆ°ÁÆóÊùÇËçâÈôÑËøëÁöÑ‰ΩçÁΩÆ
                            const offsetDistance = 0.8;
                            const currentX = cart.position.x;
                            const currentZ = cart.position.z;
                            const dx = weed.position.x - currentX;
                            const dz = weed.position.z - currentZ;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            let nearX, nearZ;
                            if (distance > 0) {
                                const ratio = (distance - offsetDistance) / distance;
                                nearX = currentX + dx * ratio;
                                nearZ = currentZ + dz * ratio;
                            } else {
                                nearX = weed.position.x + offsetDistance * 0.707;
                                nearZ = weed.position.z + offsetDistance * 0.707;
                            }
                            
                            await new Promise(resolve => {
                                moveCartTo(nearX, nearZ, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 300));
                            await useAutoLaser();
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                        console.log('‚úÖ Êñ∞ÊùÇËçâÊ∏ÖÈô§ÂÆåÊàêÔºÅ');
                    } else {
                        console.log('‚úÖ Ê≤°ÊúâÊñ∞ÊùÇËçâÔºÅ');
                    }
                    
                    // Ê≠•È™§7: ÂúüÂ£§Êé¢ÊµãÔºàÈÄê‰∏™Ê†ºÂ≠êÊé¢ÊµãÔºâ
                    console.log('üß™ [Ê≠•È™§7] ÂºÄÂßãÂúüÂ£§Êé¢Êµã...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÂúüÂ£§Êé¢ÊµãÂô®
                    switchEquipment('soil');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊ§çÁâ©ÔºàÈúÄË¶ÅÊé¢ÊµãÁöÑÊ†ºÂ≠êÔºâ
                    const allPlantsToDetect = gameState.plants.filter(p => !p.is_empty && !p.is_removed);
                    console.log(`   ÈúÄË¶ÅÊé¢Êµã ${allPlantsToDetect.length} ‰∏™Ê†ºÂ≠ê`);
                    
                    let detectedCount = 0;
                    
                    // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ÊúÄËøëÁöÑÊú™Êé¢ÊµãÊ§çÁâ©
                    while (allPlantsToDetect.length > 0 && detectedCount < 100) {
                        const currentX = cart.position.x;
                        const currentZ = cart.position.z;
                        
                        // ÊâæÂà∞ÊúÄËøëÁöÑÊ§çÁâ©
                        let nearestPlant = null;
                        let minDistance = Infinity;
                        
                        for (const plant of allPlantsToDetect) {
                            const distance = calculateDistance(currentX, currentZ, plant.position.x, plant.position.z);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestPlant = plant;
                            }
                        }
                        
                        if (!nearestPlant) break;
                        
                        console.log(`   Êé¢Êµã: ${nearestPlant.id} ‰ΩçÁΩÆ(${nearestPlant.position.x.toFixed(2)}, ${nearestPlant.position.z.toFixed(2)})`);
                        
                        // ÁßªÂä®Âà∞Ê§çÁâ©‰ΩçÁΩÆ
                        await new Promise(resolve => {
                            moveCartTo(nearestPlant.position.x, nearestPlant.position.z, 600, resolve);
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                        // ‰ΩøÁî®ÂúüÂ£§Êé¢ÊµãÂô®ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                        await useSoilProbeAuto();
                        
                        // ‰ªéÂæÖÊé¢ÊµãÂàóË°®‰∏≠ÁßªÈô§
                        const index = allPlantsToDetect.findIndex(p => p.id === nearestPlant.id);
                        if (index > -1) {
                            allPlantsToDetect.splice(index, 1);
                        }
                        
                        detectedCount++;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    console.log(`‚úÖ ÂúüÂ£§Êé¢ÊµãÂÆåÊàêÔºÅÂÖ±Êé¢Êµã ${detectedCount} ‰∏™Ê†ºÂ≠ê`);
                    
                    // Ê≠•È™§8: ÁªôÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©Âñ∑Ê¥íÂÜúËçØ
                    console.log('üß¥ [Ê≠•È™§8] ÂºÄÂßãÂñ∑Ê¥íÂÜúËçØ...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÂÜúËçØÂñ∑Ê¥íÂô®
                    switchEquipment('spray');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©
                    const pestPlants = gameState.plants.filter(p => p.has_pests && !p.is_removed);
                    console.log(`   ÊâæÂà∞ ${pestPlants.length} Ê†™ÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©`);
                    
                    if (pestPlants.length > 0) {
                        let sprayedCount = 0;
                        
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ÊúÄËøëÁöÑÊú™Âñ∑Ê¥íÊ§çÁâ©
                        const remainingPests = [...pestPlants];
                        
                        while (remainingPests.length > 0 && sprayedCount < 100) {
                            const currentX = cart.position.x;
                            const currentZ = cart.position.z;
                            
                            // ÊâæÂà∞ÊúÄËøëÁöÑÊ§çÁâ©
                            let nearestPlant = null;
                            let minDistance = Infinity;
                            
                            for (const plant of remainingPests) {
                                const distance = calculateDistance(currentX, currentZ, plant.position.x, plant.position.z);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestPlant = plant;
                                }
                            }
                            
                            if (!nearestPlant) break;
                            
                            console.log(`   Âñ∑Ê¥í: ${nearestPlant.id} ‰ΩçÁΩÆ(${nearestPlant.position.x.toFixed(2)}, ${nearestPlant.position.z.toFixed(2)})`);
                            
                            // ËÆ°ÁÆóÊ§çÁâ©ÈôÑËøëÁöÑ‰ΩçÁΩÆÔºàË∑ùÁ¶ª0.8Á±≥ÔºåÈÅøÂÖçÂéãÂà∞Ê§çÁâ©Ôºâ
                            const offsetDistance = 0.8;
                            const dx = nearestPlant.position.x - currentX;
                            const dz = nearestPlant.position.z - currentZ;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            let nearX, nearZ;
                            if (distance > 0) {
                                const ratio = (distance - offsetDistance) / distance;
                                nearX = currentX + dx * ratio;
                                nearZ = currentZ + dz * ratio;
                            } else {
                                nearX = nearestPlant.position.x + offsetDistance * 0.707;
                                nearZ = nearestPlant.position.z + offsetDistance * 0.707;
                            }
                            
                            // ÁßªÂä®Âà∞Ê§çÁâ©ÈôÑËøë
                            await new Promise(resolve => {
                                moveCartTo(nearX, nearZ, 600, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ÊóãËΩ¨Â∞èËΩ¶ÊúùÂêëÊ§çÁâ©ÔºàÁ°Æ‰øùÊ§çÁâ©Âú®ÊâáÂΩ¢ËåÉÂõ¥ÂÜÖÔºâ
                            const targetAngle = Math.atan2(
                                nearestPlant.position.x - nearX,
                                nearestPlant.position.z - nearZ
                            );
                            cart.rotation.y = targetAngle;
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            
                            // ‰ΩøÁî®ÂÜúËçØÂñ∑Ê¥íÂô®ÔºàÂíåuseWaterAuto()‰∏ÄÊ†∑ÔºåÁõ¥Êé•Ë∞ÉÁî®Â∑•ÂÖ∑ÂáΩÊï∞Ôºâ
                            await useSprayAuto();
                            
                            // ‰ªéÂæÖÂñ∑Ê¥íÂàóË°®‰∏≠ÁßªÈô§
                            const index = remainingPests.findIndex(p => p.id === nearestPlant.id);
                            if (index > -1) {
                                remainingPests.splice(index, 1);
                            }
                            
                            sprayedCount++;
                            
                            // Âà∑Êñ∞Áä∂ÊÄÅÔºåÊõ¥Êñ∞ÂÆ≥Ëô´‰ø°ÊÅØ
                            await refreshGameState();
                            const updatedPests = gameState.plants.filter(p => p.has_pests && !p.is_removed);
                            remainingPests.length = 0;
                            remainingPests.push(...updatedPests.filter(p => 
                                pestPlants.some(pp => pp.id === p.id)
                            ));
                            
                            await new Promise(resolve => setTimeout(resolve, 400));
                        }
                        
                        console.log(`‚úÖ ÂÜúËçØÂñ∑Ê¥íÂÆåÊàêÔºÅÂÖ±Â§ÑÁêÜ ${sprayedCount} Ê†™Ê§çÁâ©`);
                    } else {
                        console.log('‚úÖ Ê≤°ÊúâÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©ÔºÅ');
                    }
                    
                    // Ê≠•È™§9: ÊåÅÁª≠ÊµáÊ∞¥Áõ¥Âà∞ÊâÄÊúâÊ§çÁâ©ÊàêÁÜü
                    console.log('üíß [Ê≠•È™§9] ÊåÅÁª≠ÊµáÊ∞¥Áõ¥Âà∞ÊâÄÊúâÊ§çÁâ©ÊàêÁÜü...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞ÊµáÊ∞¥Â∑•ÂÖ∑
                    switchEquipment('water');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const waterRange = equipmentConfig.water.range; // 2.2
                    let maxRounds = 15; // ÊúÄÂ§öÊµáÊ∞¥15ËΩÆ
                    let round = 0;
                    
                    while (round < maxRounds) {
                        await refreshGameState();
                        
                        const plants = gameState.plants.filter(p => p.is_vegetable && !p.is_removed);
                        const maturePlants = plants.filter(p => p.growth_stage >= 3);
                        
                        console.log(`   Á¨¨${round + 1}ËΩÆÊµáÊ∞¥: ${plants.length}Ê†™Ê§çÁâ©, ${maturePlants.length}Ê†™ÊàêÁÜü`);
                        
                        if (maturePlants.length === plants.length && plants.length > 0) {
                            console.log('   ‚úÖ ÊâÄÊúâÊ§çÁâ©Â∑≤ÊàêÁÜüÔºÅ');
                            break;
                        }
                        
                        // ÊµáÊ∞¥ÊâÄÊúâÊú™ÊàêÁÜüÁöÑÊ§çÁâ© - ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ï
                        let immaturePlants = plants.filter(p => p.growth_stage < 3);
                        let wateringRound = 0;
                        
                        while (immaturePlants.length > 0 && wateringRound < 20) {
                            wateringRound++;
                            
                            let bestPosition = null;
                            let maxCoverage = 0;
                            let coveredPlants = [];
                            
                            for (const plant of immaturePlants) {
                                const plantsInRange = immaturePlants.filter(p => 
                                    calculateDistance(plant.position.x, plant.position.z, p.position.x, p.position.z) <= waterRange
                                );
                                
                                if (plantsInRange.length > maxCoverage) {
                                    maxCoverage = plantsInRange.length;
                                    bestPosition = { x: plant.position.x, z: plant.position.z };
                                    coveredPlants = plantsInRange;
                                }
                            }
                            
                            if (!bestPosition) break;
                            
                            await new Promise(resolve => {
                                moveCartTo(bestPosition.x, bestPosition.z, 400, resolve);
                            });
                            
                            await new Promise(resolve => setTimeout(resolve, 150));
                            await useWaterAuto();
                            
                            immaturePlants = immaturePlants.filter(p => 
                                !coveredPlants.some(cp => cp.id === p.id)
                            );
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                        round++;
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    console.log(`‚úÖ ÊåÅÁª≠ÊµáÊ∞¥ÂÆåÊàêÔºÅ`);
                    
                    // Ê≠•È™§10: Êî∂Ëé∑ÊàêÁÜüÊ§çÁâ©Ôºà‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºåËßÑÂàíÁúÅÂäõË∑ØÂæÑÔºâ
                    console.log('üåæ [Ê≠•È™§10] ÂºÄÂßãÊî∂Ëé∑ÊàêÁÜüÊ§çÁâ©...');
                    await refreshGameState();
                    
                    // ÂàáÊç¢Âà∞Êú∫Ê¢∞ËáÇ
                    switchEquipment('arm');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Ëé∑ÂèñÊâÄÊúâÊàêÁÜüÊ§çÁâ©
                    const maturePlants = gameState.plants.filter(p => 
                        p.is_vegetable && !p.is_removed && p.growth_stage >= 3
                    );
                    console.log(`   ÊàêÁÜüÊ§çÁâ©: ${maturePlants.length}Ê†™`);
                    
                    if (maturePlants.length === 0) {
                        console.log('‚úÖ Ê≤°ÊúâÊàêÁÜüÊ§çÁâ©ÔºÅ');
                    } else {
                        // ËÆ°ÁÆóÂÜúÁî∞Ê†ºÂ≠ê‰∏≠ÂøÉ‰ΩçÁΩÆÔºà8x8ÁΩëÊ†ºÔºåÊØè‰∏™Ê†ºÂ≠ê0.5Á±≥Ôºâ
                        const cellSize = 0.5;
                        const offsetX = -2.0;
                        const offsetZ = -2.0;
                        const armRange = equipmentConfig.arm.range; // 0.9Á±≥
                        
                        // Ëé∑ÂèñÊâÄÊúâÊ†ºÂ≠ê‰∏≠ÂøÉ‰ΩçÁΩÆ
                        const gridCenters = [];
                        for (let row = 0; row < 8; row++) {
                            for (let col = 0; col < 8; col++) {
                                const x = offsetX + col * cellSize + cellSize / 2;
                                const z = offsetZ + row * cellSize + cellSize / 2;
                                gridCenters.push({ x, z, row, col });
                            }
                        }
                        
                        let remainingPlants = [...maturePlants];
                        let harvestRound = 0;
                        let totalHarvested = 0;
                        
                        // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊú™Êî∂Ëé∑Ê§çÁâ©ÁöÑÊ†ºÂ≠ê‰∏≠ÂøÉ
                        while (harvestRound < 100) {
                            // ‚ö†Ô∏è Áõ¥Êé•‰ªéÊú¨Âú∞gameState.plantsËé∑ÂèñÊàêÁÜüÊ§çÁâ©ÂàóË°®Ôºå‰∏çÈúÄË¶ÅÂà∑Êñ∞Áä∂ÊÄÅ
                            // useArmHarvestAuto()Â∑≤ÁªèÊõ¥Êñ∞‰∫ÜÊú¨Âú∞Áä∂ÊÄÅÔºåÂà∑Êñ∞‰ºöÂØºËá¥Ê§çÁâ©Ë¢´ÈáçÊñ∞ÂàõÂª∫
                            const currentMature = gameState.plants.filter(p => 
                                p.is_vegetable && !p.is_removed && p.growth_stage >= 3 && !p.is_empty
                            );
                            
                            if (currentMature.length === 0) {
                                console.log('   ÊâÄÊúâÊ§çÁâ©Â∑≤Êî∂Ëé∑ÂÆåÊàêÔºÅ');
                                break;
                            }
                            
                            remainingPlants = currentMature;
                            harvestRound++;
                            
                            let bestCenter = null;
                            let maxCoverage = 0;
                            let coveredPlants = [];
                            
                            // ÈÅçÂéÜÊâÄÊúâÊ†ºÂ≠ê‰∏≠ÂøÉÔºåÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊ§çÁâ©ÁöÑ‰ΩçÁΩÆ
                            for (const center of gridCenters) {
                                const plantsInRange = remainingPlants.filter(p => 
                                    calculateDistance(center.x, center.z, p.position.x, p.position.z) <= armRange
                                );
                                
                                if (plantsInRange.length > maxCoverage) {
                                    maxCoverage = plantsInRange.length;
                                    bestCenter = center;
                                    coveredPlants = plantsInRange;
                                }
                            }
                            
                            if (!bestCenter || maxCoverage === 0) break;
                            
                            console.log(`   Êî∂Ëé∑ÁÇπ${harvestRound}: Ê†ºÂ≠ê(${bestCenter.row},${bestCenter.col}) Ë¶ÜÁõñ${maxCoverage}Ê†™Ê§çÁâ©`);
                            
                            // ÁßªÂä®Âà∞Ê†ºÂ≠ê‰∏≠ÂøÉ
                            await new Promise(resolve => {
                                moveCartTo(bestCenter.x, bestCenter.z, 600, resolve);
                            });
                            
                            // ÊóãËΩ¨ËΩ¶Ë∫´‰∏éÁΩëÊ†ºÂπ≥Ë°åÔºà0Â∫¶ÔºåÊúùÂåóÔºâ
                            cart.rotation.y = 0;
                            await new Promise(resolve => setTimeout(resolve, 300));
                            
                            // Âæ™ÁéØÊî∂Ëé∑ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©ÔºåÁõ¥Âà∞ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊ§çÁâ©
                            const totalHarvestedRef = { value: totalHarvested };
                            const localHarvestCount = await harvestPlantsInRange(armRange, totalHarvestedRef);
                            totalHarvested = totalHarvestedRef.value;
                            
                            // ‰ªéÂæÖÊî∂Ëé∑ÂàóË°®‰∏≠ÁßªÈô§Â∑≤Êî∂Ëé∑ÁöÑÊ§çÁâ©ÔºàÂ∑≤Âú®Âæ™ÁéØ‰∏≠Âà∑Êñ∞Áä∂ÊÄÅÔºâ
                            // remainingPlants ‰ºöÂú®‰∏ãÊ¨°Âæ™ÁéØÂºÄÂßãÊó∂ÈÄöËøáÂà∑Êñ∞Áä∂ÊÄÅÊõ¥Êñ∞
                            
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                        
                        console.log(`‚úÖ Êî∂Ëé∑ÂÆåÊàêÔºÅÂÖ±Êî∂Ëé∑ ${totalHarvested} Ê†™Ê§çÁâ©`);
                    }
                    
                    console.log('üéâ ÂÆåÊï¥ÊµÅÁ®ãÂÆåÊàêÔºÅ');
                }, 1000);
                return;
            }
            
            // Ëé∑ÂèñÂΩìÂâçÂ∞èËΩ¶‰ΩçÁΩÆ
            const currentX = cart.position.x;
            const currentZ = cart.position.z;
            
            // Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊâæÂà∞ÊúÄËøëÁöÑÁ©∫Âú∞
            const { plot, distance } = findNearestEmptyPlot(currentX, currentZ, emptyPlots);
            
            if (!plot) {
                console.error('‚ùå Êâæ‰∏çÂà∞ÂèØÊí≠ÁßçÁöÑÂú∞Âùó');
                autoPlantState.isRunning = false;
                return;
            }
            
            const remaining = Math.min(Math.floor(gameState.coins / 5), emptyPlots.length);
            console.log(`\nüéØ [Ë¥™ÂøÉ] ÈÄâÊã©ÊúÄËøëÂú∞Âùó: (${plot.row},${plot.col}), Ë∑ùÁ¶ª=${distance.toFixed(2)}, Ââ©‰Ωô=${remaining}`);
            showMessage(`üöó ÁßªÂä®Âà∞ÊúÄËøëÂú∞Âùó (${plot.row},${plot.col}) Ë∑ùÁ¶ª:${distance.toFixed(1)}m`, 'info');
            
            // ËÆ°ÁÆóÁßªÂä®Êó∂Èó¥ÔºàÊ†πÊçÆË∑ùÁ¶ªË∞ÉÊï¥Ôºå‰ΩÜÊúâ‰∏ä‰∏ãÈôêÔºâ
            const moveDuration = Math.min(Math.max(distance * 400, 500), 1500);
            console.log(`   ÂºÄÂßãÁßªÂä®: (${plot.position.x.toFixed(2)}, ${plot.position.z.toFixed(2)}), ËÄóÊó∂ ${moveDuration}ms`);
            
            // Âπ≥ÊªëÁßªÂä®Â∞èËΩ¶Âà∞ÁõÆÊ†á‰ΩçÁΩÆ
            smoothMoveCart(plot.position.x, plot.position.z, moveDuration, () => {
                console.log(`   ‚úÖ Âà∞ËææÁõÆÊ†á‰ΩçÁΩÆ`);
                console.log(`   üå± ÂºÄÂßãÊí≠Áßç...`);
                
                // Ë∞ÉÁî®Êí≠ÁßçAPI
                fetch('/api/action/plant', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ row: plot.row, col: plot.col })
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        autoPlantState.totalPlanted++;
                        const used = autoPlantState.startCoins - gameState.coins + 5; // +5Âõ†‰∏∫ËøòÊ≤°Âà∑Êñ∞
                        console.log(`   ‚úÖ Êí≠ÁßçÊàêÂäüÔºÅÂ∑≤ÂÆåÊàê ${autoPlantState.totalPlanted} ÂùóÔºåËä±Ë¥π ${used} ÈáëÂ∏Å`);
                        showMessage(`‚úÖ Êí≠ÁßçÊàêÂäü #${autoPlantState.totalPlanted} | Ââ©‰ΩôÈáëÂ∏Å: ${gameState.coins - 5}`, 'success');
                        
                        // Âà∑Êñ∞‰ªøÁúüÁä∂ÊÄÅÔºà‰∏çÈáçÁΩÆ‰ªøÁúüÔºâ
                        return refreshGameState();
                    } else {
                        throw new Error(result.message || 'Êí≠ÁßçÂ§±Ë¥•');
                    }
                })
                .then(() => {
                    console.log(`   üîÑ Áä∂ÊÄÅÂ∑≤Âà∑Êñ∞ÔºåÁªßÁª≠ÂØªÊâæ‰∏ã‰∏Ä‰∏™ÁõÆÊ†á...`);
                    // ÁªßÁª≠Êí≠Áßç‰∏ã‰∏ÄÂùóÂú∞
                    setTimeout(plantNextNearest, 300);
                })
                .catch(error => {
                    console.error(`   ‚ùå ÈîôËØØ: ${error.message}`);
                    showMessage(`‚ùå Êí≠ÁßçÂá∫Èîô: ${error.message}`, 'error');
                    autoPlantState.isRunning = false;
                });
            });
        }
        
        // ÂÅúÊ≠¢Êí≠ÁßçÔºàÂèØÁî®‰∫éÊåâÈîÆÂèñÊ∂àÔºâ
        function stopGreedyPlanting() {
            if (autoPlantState.isRunning) {
                autoPlantState.isRunning = false;
                console.log(`üõë Êí≠ÁßçÂ∑≤ÊâãÂä®ÂÅúÊ≠¢ÔºåÂÖ±Êí≠Áßç ${autoPlantState.totalPlanted} Âùó`);
                showMessage(`üõë Êí≠ÁßçÂ∑≤ÂÅúÊ≠¢ÔºÅÂ∑≤Êí≠Áßç ${autoPlantState.totalPlanted} ÂùóÂú∞`, 'warning');
            }
        }
        
        // ========== ÂÆåÊï¥Ëá™Âä®ÂåñÂÜúÂú∫ÊéßÂà∂Á≥ªÁªü ==========
        
        // ÂêØÂä®ÂÆåÊï¥Ëá™Âä®ÂåñÊµÅÁ®ãÔºàYÈîÆËß¶ÂèëÔºâ
        async function startFullAutoFarm() {
            if (autoFarmState.isRunning) {
                showMessage('‚ö†Ô∏è Ëá™Âä®ÂåñÂÜúÂú∫Ê≠£Âú®ËøêË°å‰∏≠...', 'warning');
                return;
            }
            
            console.log('ü§ñ [ÂÆåÊï¥Ëá™Âä®Âåñ] ÂêØÂä®ÂÆåÊï¥Ëá™Âä®ÂåñÂÜúÂú∫Á≥ªÁªü');
            showMessage('ü§ñ ÂêØÂä®ÂÆåÊï¥Ëá™Âä®ÂåñÂÜúÂú∫ÔºÅ', 'success');
            
            autoFarmState.isRunning = true;
            autoFarmState.currentPhase = 'planting';
            autoFarmState.currentIndex = 0;
            
            // ÈáçÁΩÆÁªüËÆ°
            autoFarmState.stats = {
                planted: 0,
                weeds_removed: 0,
                watered: 0,
                pests_sprayed: 0,
                harvested: 0
            };
            
            // ÂºÄÂßãÁ¨¨‰∏ÄÈò∂ÊÆµÔºöÊí≠Áßç
            await phaseAutomatic();
        }
        
        // Ëá™Âä®ÂåñÊµÅÁ®ãÊéßÂà∂Âô®
        async function phaseAutomatic() {
            if (!autoFarmState.isRunning) return;
            
            console.log(`\nüîÑ [Èò∂ÊÆµÂàáÊç¢] ÂΩìÂâçÈò∂ÊÆµ: ${autoFarmState.currentPhase}`);
            
            switch(autoFarmState.currentPhase) {
                case 'planting':
                    await phasePlanting();
                    break;
                case 'first_water':
                    await phaseFirstWater();
                    break;
                case 'scan_weeds':
                    await phaseScanWeeds();
                    break;
                case 'remove_weeds':
                    await phaseRemoveWeeds();
                    break;
                case 'water_remaining':
                    await phaseWaterRemaining();
                    break;
                case 'loop_check':
                    await phaseLoopCheck();
                    break;
                case 'final_scan':
                    await phaseFinalScan();
                    break;
                case 'spray_pests':
                    await phaseSprayPests();
                    break;
                case 'water_growth':
                    await phaseWaterGrowth();
                    break;
                case 'harvest':
                    await phaseHarvest();
                    break;
                case 'complete':
                    phaseComplete();
                    break;
            }
        }
        
        // Èò∂ÊÆµ1ÔºöËá™Âä®Êí≠Áßç
        async function phasePlanting() {
            console.log('üå± [Èò∂ÊÆµ1] ÂºÄÂßãËá™Âä®Êí≠Áßç...');
            showMessage('üå± Èò∂ÊÆµ1: Ëá™Âä®Êí≠Áßç‰∏≠...', 'info');
            
            // Ë∞ÉÁî®Áé∞ÊúâÁöÑË¥™ÂøÉÊí≠ÁßçÂáΩÊï∞
            await new Promise(resolve => {
                // ‰∏¥Êó∂‰øÆÊîπÊí≠ÁßçÂÆåÊàêÂõûË∞É
                const originalPlanting = startGreedyPlanting;
                startGreedyPlanting();
                
                // Á≠âÂæÖÊí≠ÁßçÂÆåÊàê
                const checkInterval = setInterval(() => {
                    if (!autoPlantState.isRunning) {
                        clearInterval(checkInterval);
                        autoFarmState.stats.planted = autoPlantState.totalPlanted;
                        console.log(`‚úÖ [Èò∂ÊÆµ1] Êí≠ÁßçÂÆåÊàêÔºÅÂÖ±${autoFarmState.stats.planted}Âùó`);
                        autoFarmState.currentPhase = 'first_water';
                        resolve();
                        setTimeout(phaseAutomatic, 1000);
                    }
                }, 500);
            });
        }
        
        // Èò∂ÊÆµ2: Á¨¨‰∏ÄÊ¨°ÊµáÊ∞¥ÔºàË¥™ÂøÉÁÆóÊ≥ï‰ºòÂåñÔºâ
        async function phaseFirstWater() {
            console.log('üíß [Èò∂ÊÆµ2] ÂºÄÂßãÁ¨¨‰∏ÄÊ¨°ÊµáÊ∞¥...');
            showMessage('üíß Èò∂ÊÆµ2: Êô∫ËÉΩÊµáÊ∞¥‰∏≠...', 'info');
            
            // ÂàáÊç¢Âà∞ÊµáÊ∞¥Âô®
            switchEquipment('water');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Ëé∑ÂèñÊâÄÊúâÁßçÂ≠ê
            await refreshGameState();
            let remainingSeeds = gameState.plants.filter(p => p.is_seed && !p.is_weed);
            console.log(`   ÊâæÂà∞ ${remainingSeeds.length} È¢óÁßçÂ≠êÈúÄË¶ÅÊµáÊ∞¥`);
            
            const waterRange = equipmentConfig.water.range; // 2.2
            let wateredCount = 0;
            let wateringRound = 0;
            
            // Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊú™ÊµáÊ∞¥ÁßçÂ≠êÁöÑ‰ΩçÁΩÆ
            while (remainingSeeds.length > 0 && wateringRound < 50) {
                wateringRound++;
                
                // ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÁßçÂ≠êÁöÑ‰ΩçÁΩÆ
                let bestPosition = null;
                let maxCoverage = 0;
                let coveredSeeds = [];
                
                // ÈÅçÂéÜÊâÄÊúâÊú™ÊµáÊ∞¥ÁöÑÁßçÂ≠êÔºå‰ª•ÊØè‰∏™ÁßçÂ≠ê‰∏∫‰∏≠ÂøÉËÆ°ÁÆóË¶ÜÁõñÊï∞
                for (const seed of remainingSeeds) {
                    const seedsInRange = remainingSeeds.filter(s => 
                        calculateDistance(seed.position.x, seed.position.z, s.position.x, s.position.z) <= waterRange
                    );
                    
                    if (seedsInRange.length > maxCoverage) {
                        maxCoverage = seedsInRange.length;
                        bestPosition = { x: seed.position.x, z: seed.position.z };
                        coveredSeeds = seedsInRange;
                    }
                }
                
                if (!bestPosition || maxCoverage === 0) break;
                
                console.log(`   ÊµáÊ∞¥ÁÇπ${wateringRound}: (${bestPosition.x.toFixed(2)}, ${bestPosition.z.toFixed(2)}) Ë¶ÜÁõñ${maxCoverage}È¢óÁßçÂ≠ê`);
                
                // ÁßªÂä®Âà∞ÊúÄ‰ºò‰ΩçÁΩÆ
                await new Promise(resolve => {
                    smoothMoveCart(bestPosition.x, bestPosition.z, 600, resolve);
                });
                
                // Á≠âÂæÖÁßªÂä®ÂÆåÊàê
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // ÊâßË°åÊµáÊ∞¥ÔºàËøô‰ºöÊµáÁÅåËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©Ôºâ
                await useWaterAuto();
                wateredCount += maxCoverage;
                
                // ‰ªéÂæÖÊµáÊ∞¥ÂàóË°®‰∏≠ÁßªÈô§Â∑≤ÊµáÊ∞¥ÁöÑÁßçÂ≠ê
                remainingSeeds = remainingSeeds.filter(s => 
                    !coveredSeeds.some(cs => cs.id === s.id)
                );
                
                // Êõ¥Êñ∞Â∑≤ÊµáÊ∞¥ÂàóË°®
                coveredSeeds.forEach(s => {
                    if (!autoFarmState.watered.includes(s.id)) {
                        autoFarmState.watered.push(s.id);
                    }
                });
                
                // Âà∑Êñ∞‰ªøÁúüÁä∂ÊÄÅ‰ª•Êõ¥Êñ∞Ê§çÁâ©Áä∂ÊÄÅ
                await refreshGameState();
                remainingSeeds = remainingSeeds.filter(s => {
                    const updated = gameState.plants.find(p => p.id === s.id);
                    return updated && updated.is_seed && !updated.is_weed;
                });
                
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ2] Á¨¨‰∏ÄÊ¨°ÊµáÊ∞¥ÂÆåÊàêÔºÅÂÖ±${wateringRound}‰∏™ÊµáÊ∞¥ÁÇπÔºåÊµáÊ∞¥${wateredCount}È¢óÁßçÂ≠ê`);
            autoFarmState.stats.watered += wateredCount;
            autoFarmState.currentPhase = 'scan_weeds';
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ3: Êâ´ÊèèÊùÇËçâ
        async function phaseScanWeeds() {
            console.log('üîç [Èò∂ÊÆµ3] Êâ´ÊèèÊùÇËçâÂíåÂÆ≥Ëô´...');
            showMessage('üîç Èò∂ÊÆµ3: Êâ´ÊèèÊùÇËçâ‰∏≠...', 'info');
            
            // ÂàáÊç¢Âà∞Êâ´Êèè‰ª™
            switchEquipment('scanner');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Âà∑Êñ∞Áä∂ÊÄÅ
            await refreshGameState();
            
            // ÂàÜÊûêÊ§çÁâ©Áä∂ÊÄÅ
            autoFarmState.weeds = gameState.plants.filter(p => p.is_weed && !p.is_removed);
            autoFarmState.seeds = gameState.plants.filter(p => p.is_seed && !p.is_weed);
            autoFarmState.pests = gameState.plants.filter(p => p.has_pests);
            
            console.log(`   ÊùÇËçâ: ${autoFarmState.weeds.length}`);
            console.log(`   Êú™ÂèëËäΩÁßçÂ≠ê: ${autoFarmState.seeds.length}`);
            console.log(`   ÂÆ≥Ëô´: ${autoFarmState.pests.length}`);
            
            if (autoFarmState.weeds.length > 0) {
                autoFarmState.currentPhase = 'remove_weeds';
            } else if (autoFarmState.seeds.length > 0) {
                autoFarmState.currentPhase = 'water_remaining';
            } else {
                autoFarmState.currentPhase = 'final_scan';
            }
            
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ4: Ê∏ÖÈô§ÊùÇËçâ
        async function phaseRemoveWeeds() {
            console.log(`üî´ [Èò∂ÊÆµ4] Ê∏ÖÈô§ÊùÇËçâ... (${autoFarmState.weeds.length}Ê†™)`);
            showMessage(`üî´ Èò∂ÊÆµ4: Ê∏ÖÈô§${autoFarmState.weeds.length}Ê†™ÊùÇËçâ...`, 'info');
            
            // ÂàáÊç¢Âà∞ÊøÄÂÖâ
            switchEquipment('laser');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            for (const weed of autoFarmState.weeds) {
                console.log(`   Ê∏ÖÈô§ÊùÇËçâ: ${weed.id} ‰ΩçÁΩÆ(${weed.position.x.toFixed(2)}, ${weed.position.z.toFixed(2)})`);
                
                // ÁßªÂä®Âà∞ÊùÇËçâÈôÑËøë
                await new Promise(resolve => {
                    smoothMoveCart(weed.position.x, weed.position.z, 600, resolve);
                });
                
                // ‰ΩøÁî®ÊøÄÂÖâÔºàËá™Âä®ÁûÑÂáÜÔºâ
                await fetch('/api/action/laser_fire', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                autoFarmState.stats.weeds_removed++;
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ4] ÊùÇËçâÊ∏ÖÈô§ÂÆåÊàêÔºÅÊ∏ÖÈô§ ${autoFarmState.stats.weeds_removed} Ê†™`);
            
            // Âà∑Êñ∞Áä∂ÊÄÅ
            await refreshGameState();
            autoFarmState.seeds = gameState.plants.filter(p => p.is_seed && !p.is_weed);
            
            if (autoFarmState.seeds.length > 0) {
                autoFarmState.currentPhase = 'water_remaining';
            } else {
                autoFarmState.currentPhase = 'final_scan';
            }
            
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ5: Ë°•ÂÖÖÊµáÊ∞¥ÔºàË¥™ÂøÉÁÆóÊ≥ï‰ºòÂåñÔºâ
        async function phaseWaterRemaining() {
            console.log(`üíß [Èò∂ÊÆµ5] Ë°•ÂÖÖÊµáÊ∞¥Êú™ÂèëËäΩÁöÑÁßçÂ≠ê... (${autoFarmState.seeds.length}È¢ó)`);
            showMessage(`üíß Èò∂ÊÆµ5: Êô∫ËÉΩÊµáÊ∞¥${autoFarmState.seeds.length}È¢óÂâ©‰ΩôÁßçÂ≠ê...`, 'info');
            
            // ÂàáÊç¢Âà∞ÊµáÊ∞¥Âô®
            switchEquipment('water');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Âà∑Êñ∞Áä∂ÊÄÅËé∑ÂèñÊúÄÊñ∞ÁöÑÁßçÂ≠êÂàóË°®
            await refreshGameState();
            let remainingSeeds = gameState.plants.filter(p => p.is_seed && !p.is_weed);
            
            const waterRange = equipmentConfig.water.range; // 2.2
            let wateredCount = 0;
            let wateringRound = 0;
            
            // Ë¥™ÂøÉÁÆóÊ≥ïÔºöÊØèÊ¨°ÊâæÂà∞ËÉΩË¶ÜÁõñÊúÄÂ§öÊú™ÊµáÊ∞¥ÁßçÂ≠êÁöÑ‰ΩçÁΩÆ
            while (remainingSeeds.length > 0 && wateringRound < 50) {
                wateringRound++;
                
                let bestPosition = null;
                let maxCoverage = 0;
                let coveredSeeds = [];
                
                for (const seed of remainingSeeds) {
                    const seedsInRange = remainingSeeds.filter(s => 
                        calculateDistance(seed.position.x, seed.position.z, s.position.x, s.position.z) <= waterRange
                    );
                    
                    if (seedsInRange.length > maxCoverage) {
                        maxCoverage = seedsInRange.length;
                        bestPosition = { x: seed.position.x, z: seed.position.z };
                        coveredSeeds = seedsInRange;
                    }
                }
                
                if (!bestPosition) break;
                
                console.log(`   Ë°•ÂÖÖÊµáÊ∞¥ÁÇπ${wateringRound}: Ë¶ÜÁõñ${maxCoverage}È¢óÁßçÂ≠ê`);
                
                await new Promise(resolve => {
                    smoothMoveCart(bestPosition.x, bestPosition.z, 500, resolve);
                });
                
                await new Promise(resolve => setTimeout(resolve, 200));
                await useWaterAuto();
                
                wateredCount += maxCoverage;
                autoFarmState.stats.watered += maxCoverage;
                
                remainingSeeds = remainingSeeds.filter(s => 
                    !coveredSeeds.some(cs => cs.id === s.id)
                );
                
                // Âà∑Êñ∞‰ªøÁúüÁä∂ÊÄÅ‰ª•Êõ¥Êñ∞Ê§çÁâ©Áä∂ÊÄÅ
                await refreshGameState();
                remainingSeeds = remainingSeeds.filter(s => {
                    const updated = gameState.plants.find(p => p.id === s.id);
                    return updated && updated.is_seed && !updated.is_weed;
                });
                
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ5] Ë°•ÂÖÖÊµáÊ∞¥ÂÆåÊàêÔºÅÊµáÊ∞¥ ${wateredCount} È¢ó`);
            autoFarmState.currentPhase = 'loop_check';
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ6: Âæ™ÁéØÊ£ÄÊü•
        async function phaseLoopCheck() {
            console.log('üîÑ [Èò∂ÊÆµ6] Âæ™ÁéØÊ£ÄÊü•...');
            showMessage('üîÑ Èò∂ÊÆµ6: Ê£ÄÊü•ÂèëËäΩÁä∂ÊÄÅ...', 'info');
            
            // Âà∑Êñ∞Áä∂ÊÄÅ
            await refreshGameState();
            
            // Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÊú™ÂèëËäΩÁöÑÁßçÂ≠ê
            const remainingSeeds = gameState.plants.filter(p => p.is_seed && !p.is_weed);
            const newWeeds = gameState.plants.filter(p => p.is_weed && !p.is_removed);
            
            console.log(`   Êú™ÂèëËäΩÁßçÂ≠ê: ${remainingSeeds.length}`);
            console.log(`   Êñ∞ÁîüÊùÇËçâ: ${newWeeds.length}`);
            
            if (newWeeds.length > 0 || remainingSeeds.length > 0) {
                console.log('   ‚Üí ËøîÂõûÊâ´ÊèèÈò∂ÊÆµ');
                autoFarmState.currentPhase = 'scan_weeds';
            } else {
                console.log('   ‚Üí ÊâÄÊúâÁßçÂ≠êÂ∑≤ÂèëËäΩÔºåËøõÂÖ•ÊúÄÁªàÊâ´Êèè');
                autoFarmState.currentPhase = 'final_scan';
            }
            
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ7: ÊúÄÁªàÊâ´Êèè
        async function phaseFinalScan() {
            console.log('üß™ [Èò∂ÊÆµ7] ÊúÄÁªàÊâ´ÊèèÂúüÂ£§ÂíåÂÆ≥Ëô´...');
            showMessage('üß™ Èò∂ÊÆµ7: Êâ´ÊèèÂúüÂ£§Áä∂ÊÄÅ...', 'info');
            
            // ÂàáÊç¢Âà∞ÂúüÂ£§Êé¢ÊµãÂô®
            switchEquipment('soil');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Âà∑Êñ∞Áä∂ÊÄÅ
            await refreshGameState();
            
            // Ëé∑ÂèñÊâÄÊúâÊ§çÁâ©
            const plants = gameState.plants.filter(p => p.is_vegetable && !p.is_removed);
            autoFarmState.pests = plants.filter(p => p.has_pests);
            
            console.log(`   Ê§çÁâ©ÊÄªÊï∞: ${plants.length}`);
            console.log(`   ÊúâÂÆ≥Ëô´ÁöÑÊ§çÁâ©: ${autoFarmState.pests.length}`);
            
            if (autoFarmState.pests.length > 0) {
                autoFarmState.currentPhase = 'spray_pests';
            } else {
                autoFarmState.currentPhase = 'water_growth';
            }
            
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ8: Âñ∑Ê¥íÂÜúËçØ
        async function phaseSprayPests() {
            console.log(`üß¥ [Èò∂ÊÆµ8] Âñ∑Ê¥íÂÜúËçØ... (${autoFarmState.pests.length}Ê†™ÊúâÂÆ≥Ëô´)`);
            showMessage(`üß¥ Èò∂ÊÆµ8: Âñ∑Ê¥íÂÜúËçØ‰∏≠...`, 'info');
            
            // ÂàáÊç¢Âà∞Âñ∑ÈõæÂô®
            switchEquipment('spray');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            for (const plant of autoFarmState.pests) {
                console.log(`   Âñ∑Ê¥í: ${plant.id}`);
                
                // ÁßªÂä®Âà∞Ê§çÁâ©ÈôÑËøë
                await new Promise(resolve => {
                    smoothMoveCart(plant.position.x, plant.position.z, 600, resolve);
                });
                
                // Âñ∑Ê¥íÂÜúËçØ
                await fetch('/api/action/spray', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                autoFarmState.stats.pests_sprayed++;
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ8] ÂÜúËçØÂñ∑Ê¥íÂÆåÊàêÔºÅÂ§ÑÁêÜ ${autoFarmState.stats.pests_sprayed} Ê†™`);
            autoFarmState.currentPhase = 'water_growth';
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ9: ÊåÅÁª≠ÊµáÊ∞¥‰øÉËøõÊàêÁÜü
        async function phaseWaterGrowth() {
            console.log('üíß [Èò∂ÊÆµ9] ÊåÅÁª≠ÊµáÊ∞¥‰øÉËøõÊàêÁÜü...');
            showMessage('üíß Èò∂ÊÆµ9: ÊµáÊ∞¥‰øÉËøõÊàêÁÜü‰∏≠...', 'info');
            
            // ÂàáÊç¢Âà∞ÊµáÊ∞¥Âô®
            switchEquipment('water');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // ÊåÅÁª≠ÊµáÊ∞¥Áõ¥Âà∞ÊâÄÊúâÊ§çÁâ©ÊàêÁÜü
            let maxRounds = 10; // ÊúÄÂ§öÊµáÊ∞¥10ËΩÆ
            let round = 0;
            
            while (round < maxRounds) {
                await refreshGameState();
                
                const plants = gameState.plants.filter(p => p.is_vegetable && !p.is_removed);
                const maturePlants = plants.filter(p => p.growth_stage >= 3);
                
                console.log(`   Á¨¨${round + 1}ËΩÆÊµáÊ∞¥: ${plants.length}Ê†™Ê§çÁâ©, ${maturePlants.length}Ê†™ÊàêÁÜü`);
                
                if (maturePlants.length === plants.length) {
                    console.log('   ‚úÖ ÊâÄÊúâÊ§çÁâ©Â∑≤ÊàêÁÜüÔºÅ');
                    break;
                }
                
                // ÊµáÊ∞¥ÊâÄÊúâÊú™ÊàêÁÜüÁöÑÊ§çÁâ© - ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ï
                let immaturePlants = plants.filter(p => p.growth_stage < 3);
                const waterRange = equipmentConfig.water.range; // 2.2
                let wateringRound = 0;
                
                while (immaturePlants.length > 0 && wateringRound < 20) {
                    wateringRound++;
                    
                    let bestPosition = null;
                    let maxCoverage = 0;
                    let coveredPlants = [];
                    
                    for (const plant of immaturePlants) {
                        const plantsInRange = immaturePlants.filter(p => 
                            calculateDistance(plant.position.x, plant.position.z, p.position.x, p.position.z) <= waterRange
                        );
                        
                        if (plantsInRange.length > maxCoverage) {
                            maxCoverage = plantsInRange.length;
                            bestPosition = { x: plant.position.x, z: plant.position.z };
                            coveredPlants = plantsInRange;
                        }
                    }
                    
                    if (!bestPosition) break;
                    
                    await new Promise(resolve => {
                        smoothMoveCart(bestPosition.x, bestPosition.z, 400, resolve);
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 150));
                    await useWaterAuto();
                    
                    immaturePlants = immaturePlants.filter(p => 
                        !coveredPlants.some(cp => cp.id === p.id)
                    );
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                round++;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ9] ÊµáÊ∞¥‰øÉËøõÊàêÁÜüÂÆåÊàêÔºÅ`);
            autoFarmState.currentPhase = 'harvest';
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ10: Êî∂Ëé∑
        async function phaseHarvest() {
            console.log('üåæ [Èò∂ÊÆµ10] ÂºÄÂßãÊî∂Ëé∑...');
            showMessage('üåæ Èò∂ÊÆµ10: Êî∂Ëé∑‰∏≠...', 'info');
            
            // ÂàáÊç¢Âà∞Êú∫Ê¢∞ËáÇ
            switchEquipment('arm');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Âà∑Êñ∞Áä∂ÊÄÅ
            await refreshGameState();
            
            const maturePlants = gameState.plants.filter(p => 
                p.is_vegetable && !p.is_removed && p.growth_stage >= 3
            );
            
            console.log(`   ÊàêÁÜüÊ§çÁâ©: ${maturePlants.length}Ê†™`);
            autoFarmState.mature = maturePlants;
            
            for (const plant of maturePlants) {
                console.log(`   Êî∂Ëé∑: ${plant.id} at (${plant.position.x.toFixed(2)}, ${plant.position.z.toFixed(2)})`);
                
                // ÁßªÂä®Âà∞Ê§çÁâ©‰ΩçÁΩÆ
                await new Promise(resolve => {
                    smoothMoveCart(plant.position.x, plant.position.z, 600, resolve);
                });
                
                // Êî∂Ëé∑
                await fetch('/api/action/harvest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plant_id: plant.id })
                });
                
                autoFarmState.stats.harvested++;
                showMessage(`üåæ Â∑≤Êî∂Ëé∑ ${autoFarmState.stats.harvested}/${maturePlants.length}`, 'success');
                
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            console.log(`‚úÖ [Èò∂ÊÆµ10] Êî∂Ëé∑ÂÆåÊàêÔºÅÊî∂Ëé∑ ${autoFarmState.stats.harvested} Ê†™`);
            autoFarmState.currentPhase = 'complete';
            setTimeout(phaseAutomatic, 1000);
        }

        // Èò∂ÊÆµ11: ÂÆåÊàê
        function phaseComplete() {
            console.log('üéâ [Èò∂ÊÆµ11] ÂÆåÊï¥Ëá™Âä®ÂåñÊµÅÁ®ãÂÆåÊàêÔºÅ');
            
            const summary = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë        üéâ Ëá™Âä®ÂåñÂÜúÂú∫ÂÆåÊàêÔºÅ                                  ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìä ÁªüËÆ°Êï∞ÊçÆ:
   üå± Êí≠Áßç: ${autoFarmState.stats.planted} Âùó
   üî´ Èô§Ëçâ: ${autoFarmState.stats.weeds_removed} Ê†™
   üíß ÊµáÊ∞¥: ${autoFarmState.stats.watered} Ê¨°
   üß¥ Âñ∑ËçØ: ${autoFarmState.stats.pests_sprayed} Ê†™
   üåæ Êî∂Ëé∑: ${autoFarmState.stats.harvested} Ê†™

‚úÖ ÂÖ®ÊµÅÁ®ãÂÆåÊàêÔºÅ
`;
            
            console.log(summary);
            showMessage('üéâ Ëá™Âä®ÂåñÂÜúÂú∫ÂÆåÊàêÔºÅ', 'success');
            
            // ËøîÂõûÂéüÁÇπ
            smoothMoveCart(0, 0, 1000, () => {
                console.log('üè† ËøîÂõûÂéüÁÇπ');
            });
            
            autoFarmState.isRunning = false;
        }
        

        function updateAutoTraverse(deltaTime) {
            if (!autoTraverse.active || autoTraverse.path.length === 0) {
                return null;
            }

            if (autoTraverse.currentIndex >= autoTraverse.path.length) {
                stopAutoTraverse('completed');
                return null;
            }

            const targetCell = autoTraverse.path[autoTraverse.currentIndex];
            const targetPos = new THREE.Vector3(targetCell.x, cart.position.y, targetCell.z);
            const toTarget = targetPos.clone().sub(cart.position);
            toTarget.y = 0;

            const distance = toTarget.length();
            if (distance < autoTraverse.threshold) {
                autoTraverse.currentIndex += 1;
                if (autoTraverse.currentIndex >= autoTraverse.path.length) {
                    stopAutoTraverse('completed');
                    return null;
                }
                return updateAutoTraverse(deltaTime);
            }

            const direction = toTarget.normalize();

            const desiredYaw = Math.atan2(direction.x, -direction.z);
            const currentYaw = cart.rotation.y;
            let deltaYaw = desiredYaw - currentYaw;
            deltaYaw = Math.atan2(Math.sin(deltaYaw), Math.cos(deltaYaw));
            const maxTurn = rotationSpeed * 1.5 * deltaTime;
            const clamped = Math.max(-maxTurn, Math.min(maxTurn, deltaYaw));
            cart.rotation.y += clamped;

            const adaptiveSpeed = Math.min(autoTraverse.speed, Math.max(0.6, distance * 1.2));

            return {
                direction,
                speed: adaptiveSpeed,
                target: targetCell
            };
        }
        
        // ========== ÂàõÂª∫ÂõõËΩ¥Êú∫Ê¢∞ËáÇ ==========
        function createRoboticArm(parent) {
            // ÊùêË¥®ÂÆö‰πâ
            const armMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF6B35,  // Ê©ôËâ≤‰∏ª‰Ωì
                metalness: 0.8,
                roughness: 0.2
            });
            const jointMaterial = new THREE.MeshStandardMaterial({
                color: 0x2C3E50,  // Ê∑±ÁÅ∞Ëâ≤ÂÖ≥ËäÇ
                metalness: 0.9,
                roughness: 0.1
            });
            const gripperMaterial = new THREE.MeshStandardMaterial({
                color: 0xE74C3C,  // Á∫¢Ëâ≤ÊäìÊâã
                metalness: 0.7,
                roughness: 0.3
            });
            
            // ========== ËΩ¥1: Âü∫Â∫ßÊóãËΩ¨ËΩ¥Ôºà360Â∫¶Ôºâ ==========
            const axis1 = new THREE.Group();
            axis1.name = 'axis1_base';
            axis1.position.y = 0.2;
            
            // Âü∫Â∫ßÂ∫ïÁõòÔºàÂ§ßÂúÜÁõòÔºâ
            const basePlate = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.1, 0.05, 32),
                armMaterial
            );
            basePlate.position.y = 0;
            basePlate.castShadow = true;
            axis1.add(basePlate);
            
            // ÊóãËΩ¨ËΩ¥ÊâøÔºàÊ∑±Ëâ≤Ôºâ
            const bearing = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.08, 16),
                jointMaterial
            );
            bearing.position.y = 0.06;
            bearing.castShadow = true;
            axis1.add(bearing);
            
            // ========== ËΩ¥2: ËÇ©ÂÖ≥ËäÇÔºà‰øØ‰ª∞Ôºâ ==========
            const axis2 = new THREE.Group();
            axis2.name = 'axis2_shoulder';
            axis2.position.y = 0.1;
            
            // ËÇ©ÂÖ≥ËäÇÁêÉ‰Ωì
            const shoulder = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 16, 16),
                jointMaterial
            );
            shoulder.castShadow = true;
            axis2.add(shoulder);
            
            // Â§ßËáÇÔºàËæÉÈïøÔºåÂä†Èïø20%Ôºâ
            const upperArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.22, 0.04),
                armMaterial
            );
            upperArm.position.set(0, 0.11, 0);
            upperArm.castShadow = true;
            axis2.add(upperArm);
            
            // ========== ËΩ¥3: ËÇòÂÖ≥ËäÇÔºà‰øØ‰ª∞Ôºâ ==========
            const axis3 = new THREE.Group();
            axis3.name = 'axis3_elbow';
            axis3.position.y = 0.22;
            
            // ËÇòÂÖ≥ËäÇÁêÉ‰Ωì
            const elbow = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 16, 16),
                jointMaterial
            );
            elbow.castShadow = true;
            axis3.add(elbow);
            
            // Â∞èËáÇÔºà‰∏≠Á≠âÈïøÂ∫¶ÔºåÂä†Èïø20%Ôºâ
            const forearm = new THREE.Mesh(
                new THREE.BoxGeometry(0.035, 0.18, 0.035),
                armMaterial
            );
            forearm.position.set(0, 0.09, 0);
            forearm.castShadow = true;
            axis3.add(forearm);
            
            // ========== ËΩ¥4: ËÖïÂÖ≥ËäÇÔºàÊóãËΩ¨+‰øØ‰ª∞Ôºâ ==========
            const axis4 = new THREE.Group();
            axis4.name = 'axis4_wrist';
            axis4.position.y = 0.18;
            
            // ËÖïÂÖ≥ËäÇÁêÉ‰Ωì
            const wrist = new THREE.Mesh(
                new THREE.SphereGeometry(0.035, 12, 12),
                jointMaterial
            );
            wrist.castShadow = true;
            axis4.add(wrist);
            
            // ÊâãËÖïËøûÊé•‰ª∂
            const wristLink = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.05, 12),
                armMaterial
            );
            wristLink.position.y = 0.025;
            wristLink.castShadow = true;
            axis4.add(wristLink);
            
            // ========== ÊäìÊâãÁªÑ ==========
            const gripperGroup = new THREE.Group();
            gripperGroup.name = 'gripper';
            gripperGroup.position.y = 0.05;
            
            // üéØ ÊäìÊâãÊú´Á´Ø‰ΩçÁΩÆÊ†áËÆ∞ÔºàÁî®‰∫éÁ≤æÁ°ÆË∑üË∏™ÔºåÂä†Èïø25%Ôºâ
            const tipMarker = new THREE.Object3D();
            tipMarker.name = 'tip_marker';
            tipMarker.position.set(0, 0, -0.10);  // ÊäìÊâãÊú´Á´Ø‰ΩçÁΩÆ
            gripperGroup.add(tipMarker);
            
            // Â∑¶Â§πÁà™ÔºàÂä†Èïø20%Ôºâ
            const leftGripper = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.084, 0.01),
                gripperMaterial
            );
            leftGripper.name = 'left_gripper';
            leftGripper.position.set(-0.02, 0.042, 0);
            leftGripper.castShadow = true;
            gripperGroup.add(leftGripper);
            
            // Âè≥Â§πÁà™ÔºàÂä†Èïø20%Ôºâ
            const rightGripper = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.084, 0.01),
                gripperMaterial
            );
            rightGripper.name = 'right_gripper';
            rightGripper.position.set(0.02, 0.042, 0);
            rightGripper.castShadow = true;
            gripperGroup.add(rightGripper);
            
            axis4.add(gripperGroup);
            
            // ========== ÊøÄÂÖâÂèëÂ∞ÑÂô®ÔºàÂÆâË£ÖÂú®ÊäìÊâãÂâçÊñπÔºâ==========
            const laserEmitter = new THREE.Group();
            laserEmitter.name = 'laser_emitter';
            
            // ÊøÄÂÖâÂèëÂ∞ÑÂô®‰∏ª‰ΩìÔºàÁ∫¢Ëâ≤ÂúÜÊü±Ôºâ
            const emitterBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.06, 16),
                new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.3
                })
            );
            emitterBody.rotation.z = Math.PI / 2;
            emitterBody.position.set(0, 0.02, -0.05);
            emitterBody.castShadow = true;
            laserEmitter.add(emitterBody);
            
            // ÊøÄÂÖâÈïúÂ§¥ÔºàÂèëÂÖâÁöÑÁ∫¢Ëâ≤ÂúÜÔºâ
            const emitterLens = new THREE.Mesh(
                new THREE.CircleGeometry(0.012, 16),
                new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 1.0
                })
            );
            emitterLens.rotation.y = -Math.PI / 2;
            emitterLens.position.set(0, 0.02, -0.08);
            laserEmitter.add(emitterLens);
            
            axis4.add(laserEmitter);
            
            // ========== ÊåáÁ§∫ÁÅØ ==========
            const indicator = new THREE.Mesh(
                new THREE.SphereGeometry(0.018, 8, 8),
                new THREE.MeshStandardMaterial({
                    color: 0x00FF00,
                    emissive: 0x00FF00,
                    emissiveIntensity: 0.5
                })
            );
            indicator.position.set(0, 0.12, 0.06);
            indicator.name = 'arm_indicator';
            indicator.visible = false;
            axis1.add(indicator);
            
            // ========== Â±ÇÁ∫ßÁªÑË£Ö ==========
            axis3.add(axis4);  // ËÖïÂÖ≥ËäÇËøûÊé•Âà∞Â∞èËáÇ
            axis2.add(axis3);  // ËÇòÂÖ≥ËäÇËøûÊé•Âà∞Â§ßËáÇ
            axis1.add(axis2);  // ËÇ©ÂÖ≥ËäÇËøûÊé•Âà∞Âü∫Â∫ß
            
            // Ê∑ªÂä†Âà∞Â∞èËΩ¶
            axis1.name = 'robotic_arm';
            parent.add(axis1);
            
            // ÂàùÂßãÂßøÊÄÅÔºàËá™ÁÑ∂Êî∂Ëµ∑Ôºâ
            axis2.rotation.z = Math.PI / 6;   // ËÇ©ÂÖ≥ËäÇÂâçÂÄæ30Â∫¶
            axis3.rotation.z = -Math.PI / 4;  // ËÇòÂÖ≥ËäÇÂºØÊõ≤45Â∫¶
            axis4.rotation.z = Math.PI / 6;   // ËÖïÂÖ≥ËäÇÂâçÂÄæ30Â∫¶
        }
        
        // ========== ÈáçÁΩÆ‰ªøÁúü ==========
        async function resetGame() {
            try {
                const response = await fetch('/api/game/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                
                if (data.success) {
                    console.log('‰ªøÁúüÂ∑≤ÈáçÁΩÆ‰∏∫ÂàùÂßãÁä∂ÊÄÅ');
                    return true;
                }
            } catch (error) {
                console.error('ÈáçÁΩÆ‰ªøÁúüÂ§±Ë¥•:', error);
                return false;
            }
        }
        
        // ========== Âä†ËΩΩ‰ªøÁúüÁä∂ÊÄÅ ==========
        async function loadGameState() {
            try {
                // ÂÖàÈáçÁΩÆ‰ªøÁúüÂà∞ÂàùÂßãÁä∂ÊÄÅ
                await resetGame();
                
                // ÂÜçÂä†ËΩΩ‰ªøÁúüÁä∂ÊÄÅ
                const response = await fetch('/api/game/state');
                const data = await response.json();
                
                if (data.success) {
                    gameState = data.state;
                    updateUI();
                    createPlants();
                }
            } catch (error) {
                console.error('Âä†ËΩΩ‰ªøÁúüÁä∂ÊÄÅÂ§±Ë¥•:', error);
            }
        }
        
        // Âè™Âà∑Êñ∞‰ªøÁúüÁä∂ÊÄÅÔºå‰∏çÈáçÁΩÆ‰ªøÁúüÔºàÁî®‰∫éËá™Âä®Êí≠ÁßçÁ≠âÂú∫ÊôØÔºâ
        async function refreshGameState() {
            try {
                // ‚ö†Ô∏è ÂÖ≥ÈîÆÔºö‰øùÂ≠òÂΩìÂâçË£ÖÂ§áÔºåÂõ†‰∏∫ÊúçÂä°Âô®Á´ØËøîÂõûÁöÑÊòØcurrent_equipmentÔºà‰∏ãÂàíÁ∫øÔºâÔºåÂâçÁ´Ø‰ΩøÁî®ÁöÑÊòØcurrentEquipmentÔºàÈ©ºÂ≥∞Ôºâ
                const currentEquipment = gameState.currentEquipment;
                
                const response = await fetch('/api/game/state');
                const data = await response.json();
                
                if (data.success) {
                    gameState = data.state;
                    // ÊÅ¢Â§çÂΩìÂâçË£ÖÂ§áÔºàÂ¶ÇÊûúÊúçÂä°Âô®Á´ØÊúâcurrent_equipmentÔºåÂàô‰ΩøÁî®ÂÆÉÔºåÂê¶Âàô‰ΩøÁî®‰øùÂ≠òÁöÑÂÄºÔºâ
                    if (data.state.current_equipment) {
                        gameState.currentEquipment = data.state.current_equipment;
                    } else {
                        gameState.currentEquipment = currentEquipment || 'laser';
                    }
                    updateUI();
                    createPlants();
                }
            } catch (error) {
                console.error('Âà∑Êñ∞‰ªøÁúüÁä∂ÊÄÅÂ§±Ë¥•:', error);
            }
        }
        
        // Ê£ÄÊü•Ê§çÁâ©ÊòØÂê¶Âú®‰∏ä‰∏ãÂ∑¶Âè≥ÊñπÂêëÔºàÈùûÂØπËßíÁ∫øÔºâ
        function isCardinalDirection(cartPos, plantPos) {
            const dx = Math.abs(plantPos.x - cartPos.x);
            const dz = Math.abs(plantPos.z - cartPos.z);
            const threshold = 0.1; // ÂÆπÂ∑ÆÔºåÂõ†‰∏∫ÁΩëÊ†ºÊòØ0.5Á±≥
            
            // ‰∏ä‰∏ãÂ∑¶Âè≥ÔºöÂÖ∂‰∏≠‰∏Ä‰∏™ÊñπÂêëÊé•Ëøë0ÔºåÂè¶‰∏Ä‰∏™ÊñπÂêëÂ§ß‰∫é0
            // ÊéíÈô§ÂØπËßíÁ∫øÔºö‰∏§‰∏™ÊñπÂêëÈÉΩ‰∏çÊé•Ëøë0
            return (dx < threshold && dz > threshold) || (dz < threshold && dx > threshold);
        }
        
        // ========== Êî∂Ëé∑ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©ÔºàÂæ™ÁéØÁõ¥Âà∞ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊàêÁÜüÊ§çÁâ©Ôºâ==========
        async function harvestPlantsInRange(armRange, totalHarvestedRef) {
            let localHarvestCount = 0;
            let maxLocalHarvest = 20; // Èò≤Ê≠¢Êó†ÈôêÂæ™ÁéØ
            
            while (localHarvestCount < maxLocalHarvest) {
                console.log(`\n[DEBUG HARVEST LOOP] ========== Êî∂Ëé∑Âæ™ÁéØÁ¨¨ ${localHarvestCount + 1} Ê¨° ==========`);
                
                // ‚ö†Ô∏è ÂÖ≥ÈîÆÔºö‰∏çÈúÄË¶ÅÂà∑Êñ∞Áä∂ÊÄÅÔºåuseArmHarvestAuto()Â∑≤ÁªèÊõ¥Êñ∞‰∫ÜÊú¨Âú∞Áä∂ÊÄÅÂíåÊ®°Âûã
                // ÂíåÊâãÂä®Êî∂Ëé∑‰∏ÄÊ†∑ÔºåÂè™Ë∞ÉÁî®useArmHarvestAuto()Âç≥ÂèØÔºå‰∏çÂà∑Êñ∞Áä∂ÊÄÅ
                console.log('[DEBUG HARVEST LOOP] 1. Ê£ÄÊü•ËåÉÂõ¥ÂÜÖÊàêÁÜüÊ§çÁâ©Ôºà‰∏çÂà∑Êñ∞Áä∂ÊÄÅÔºâ...');
                
                // Ê£ÄÊü•ËåÉÂõ¥ÂÜÖÊòØÂê¶ËøòÊúâÊàêÁÜüÊ§çÁâ©Ôºà‰ªéfarm.childrenÊ£ÄÊü•Ôºâ
                const cartPos = cart.position;
                let hasMaturePlant = false;
                let maturePlantCount = 0;
                
                console.log(`[DEBUG HARVEST LOOP] 4. Ê£ÄÊü•ËåÉÂõ¥ÂÜÖÊàêÁÜüÊ§çÁâ© (Â∞èËΩ¶‰ΩçÁΩÆ: x=${cartPos.x.toFixed(2)}, z=${cartPos.z.toFixed(2)}, ËåÉÂõ¥: ${armRange}m)...`);
                
                farm.children.forEach(child => {
                    if (!child.userData || !child.userData.id || child.userData.is_removed) return;
                    if (child.userData.is_empty) return; // Ë∑≥ËøáÁ©∫Âú∞
                    if (!child.userData.is_vegetable) return;
                    if (child.userData.growth_stage !== 3) return;
                    
                    const dist = cartPos.distanceTo(child.position);
                    // ‚ö†Ô∏è Âè™Ê£ÄÊü•‰∏ä‰∏ãÂ∑¶Âè≥ÊñπÂêëÁöÑÊ§çÁâ©ÔºåÊéíÈô§ÂØπËßíÁ∫ø
                    if (dist <= armRange && isCardinalDirection(cartPos, child.position)) {
                        hasMaturePlant = true;
                        maturePlantCount++;
                        console.log(`[DEBUG HARVEST LOOP]    - ÊâæÂà∞ÊàêÁÜüÊ§çÁâ©Ôºà‰∏ä‰∏ãÂ∑¶Âè≥Ôºâ: ${child.userData.id}, Ë∑ùÁ¶ª: ${dist.toFixed(2)}m`);
                    } else if (dist <= armRange) {
                        console.log(`[DEBUG HARVEST LOOP]    - Ë∑≥ËøáÂØπËßíÁ∫øÊ§çÁâ©: ${child.userData.id}, Ë∑ùÁ¶ª: ${dist.toFixed(2)}m`);
                    }
                });
                
                console.log(`[DEBUG HARVEST LOOP] 5. ËåÉÂõ¥ÂÜÖÊàêÁÜüÊ§çÁâ©Êï∞Èáè: ${maturePlantCount}`);
                
                if (!hasMaturePlant) {
                    console.log(`[DEBUG HARVEST LOOP] 6. ‚ùå Ê≤°ÊúâÊàêÁÜüÊ§çÁâ©ÔºåËØ•‰ΩçÁΩÆÊî∂Ëé∑ÂÆåÊàêÔºåÂÖ±Êî∂Ëé∑ ${localHarvestCount} Ê†™`);
                    break;
                }
                
                console.log(`[DEBUG HARVEST LOOP] 6. ‚úÖ ÊâæÂà∞ ${maturePlantCount} Ê†™ÊàêÁÜüÊ§çÁâ©ÔºåÂºÄÂßãÊî∂Ëé∑...`);
                console.log(`   üîÑ ÂºÄÂßãÊî∂Ëé∑Á¨¨ ${localHarvestCount + 1} Ê†™Ê§çÁâ©...`);
                
                // Ê£ÄÊü•ÂΩìÂâçË£ÖÂ§á
                console.log(`[DEBUG HARVEST LOOP] 7. ÂΩìÂâçË£ÖÂ§á: ${gameState.currentEquipment}`);
                
                // ‰ΩøÁî®Êú∫Ê¢∞ËáÇÊî∂Ëé∑ÔºàÁúüÊ≠£Ê®°ÊãüÁî®Êà∑Êåâ‰∏ãÁ©∫Ê†ºÈîÆ‰∫ã‰ª∂Ôºâ
                console.log('[DEBUG HARVEST LOOP] 8. Ê®°ÊãüÊåâ‰∏ãÁ©∫Ê†ºÈîÆ‰∫ã‰ª∂...');
                // ÂàõÂª∫ÁúüÂÆûÁöÑÈîÆÁõò‰∫ã‰ª∂Âπ∂Ëß¶ÂèëÔºåÂÆåÂÖ®Ê®°ÊãüÁî®Êà∑Êìç‰Ωú
                const spaceEvent = new KeyboardEvent('keydown', {
                    key: ' ',
                    code: 'Space',
                    keyCode: 32,
                    which: 32,
                    bubbles: true,
                    cancelable: true
                });
                // Ëß¶Âèë‰∫ã‰ª∂ÔºåËÆ© onKeyDown Â§ÑÁêÜÔºàÂíåÁî®Êà∑ÊâãÂä®ÊåâÁ©∫Ê†ºÈîÆÂÆåÂÖ®‰∏ÄÊ†∑Ôºâ
                document.dispatchEvent(spaceEvent);
                // Á≠âÂæÖ useAutoEquipment ÂºÄÂßãÊâßË°åÔºàÂõ†‰∏∫ÂÆÉÊòØÂºÇÊ≠•ÁöÑÔºåÈúÄË¶Å‰∏ÄÁÇπÊó∂Èó¥ÂêØÂä®Ôºâ
                await new Promise(resolve => setTimeout(resolve, 200));
                console.log('[DEBUG HARVEST LOOP] 9. Á©∫Ê†ºÈîÆ‰∫ã‰ª∂Â∑≤Ëß¶ÂèëÔºåÁ≠âÂæÖÊî∂Ëé∑Âä®ÁîªÂÆåÊàê...');
                
                // Á≠âÂæÖÊî∂Ëé∑Âä®ÁîªÂíåAPIË∞ÉÁî®ÂÆåÊàêÔºàÊî∂Ëé∑Âä®ÁîªÊÄªÊó∂ÈïøÁ∫¶5-6ÁßíÔºâ
                console.log('[DEBUG HARVEST LOOP] 10. Á≠âÂæÖÊî∂Ëé∑Âä®ÁîªÂíåAPIË∞ÉÁî®ÂÆåÊàê (6Áßí)...');
                await new Promise(resolve => setTimeout(resolve, 6000));
                
                // ‚ö†Ô∏è ÂÖ≥ÈîÆÔºöuseArmHarvestAutoÂ∑≤ÁªèÊâãÂä®Êõ¥Êñ∞‰∫ÜgameState.plantsÂπ∂ÁßªÈô§‰∫ÜÊ§çÁâ©Ê®°Âûã
                // ‰∏çÈúÄË¶ÅÁ´ãÂç≥Âà∑Êñ∞Áä∂ÊÄÅÔºåÂõ†‰∏∫useArmHarvestAutoÂ∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÁä∂ÊÄÅÊõ¥Êñ∞
                // Âè™Âú®Âæ™ÁéØÂºÄÂßãÊó∂Âà∑Êñ∞Áä∂ÊÄÅÂç≥ÂèØÔºàÁ¨¨2104Ë°åÔºâ
                console.log('[DEBUG HARVEST LOOP] 11. Êî∂Ëé∑ÂÆåÊàêÔºåuseArmHarvestAutoÂ∑≤Êõ¥Êñ∞Áä∂ÊÄÅÂíåÊ®°Âûã');
                
                // Á≠âÂæÖÁä∂ÊÄÅÂêåÊ≠•
                await new Promise(resolve => setTimeout(resolve, 300));
                
                if (totalHarvestedRef) totalHarvestedRef.value++;
                localHarvestCount++;
                
                console.log(`[DEBUG HARVEST LOOP] 12. ‚úÖ Â∑≤Êî∂Ëé∑ ${localHarvestCount} Ê†™ÔºåÁªßÁª≠Ê£ÄÊü•ÊòØÂê¶ËøòÊúâÊ§çÁâ©...`);
                console.log(`[DEBUG HARVEST LOOP] ========== Êî∂Ëé∑Âæ™ÁéØÁ¨¨ ${localHarvestCount} Ê¨°ÁªìÊùü ==========\n`);
            }
            
            return localHarvestCount;
        }
        
        // ========== ÂàõÂª∫Ê§çÁâ© ==========
        function createPlants() {
            // Ê∏ÖÁ©∫ÊóßÊ§çÁâ©ÔºàÂà∑Êñ∞Êó∂ÈáçË¶ÅÔºÅÔºâ
            // Âè™Âà†Èô§Ê§çÁâ©Ôºå‰øùÁïôÂÜúÁî∞Ê†ºÂ≠ê
            const plantsToRemove = [];
            farm.children.forEach(child => {
                // ÂÜúÁî∞Ê†ºÂ≠êÊòØBoxGeometryÁöÑMeshÔºåÊ§çÁâ©ÊòØGroup
                if (child.type === 'Group') {
                    plantsToRemove.push(child);
                }
            });
            
            plantsToRemove.forEach(plant => {
                farm.remove(plant);
                // Ê∏ÖÁêÜÂá†‰Ωï‰ΩìÂíåÊùêË¥®
                if (plant.children) {
                    plant.children.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(m => m.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    });
                }
            });
            
            // ÂàõÂª∫Êñ∞Ê§çÁâ©ÔºàÂåÖÊã¨Á©∫Âú∞ÔºåÂõ†‰∏∫ÊâãÂä®Êí≠ÁßçÈúÄË¶ÅÊü•ÊâæÁ©∫Âú∞Ôºâ
            gameState.plants.forEach(plantData => {
                if (plantData.is_removed) return;
                // ‰∏çÂÜçË∑≥ËøáÁ©∫Âú∞ÔºåÂõ†‰∏∫ÊâãÂä®Êí≠ÁßçÈúÄË¶ÅÂú®farm.children‰∏≠Êü•ÊâæÁ©∫Âú∞
                
                // ‚ö†Ô∏è Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®ËØ•‰ΩçÁΩÆÁöÑÊ§çÁâ©ÔºàÈÅøÂÖçÈáçÂ§çÂàõÂª∫Ôºâ
                const existingPlant = farm.children.find(child => 
                    child.userData && 
                    child.userData.id === plantData.id &&
                    child.type === 'Group'
                );
                
                if (existingPlant) {
                    // Â¶ÇÊûúÂ∑≤Â≠òÂú®ÔºåÊõ¥Êñ∞ÂÖ∂userDataÔºå‰ΩÜ‰∏çÈáçÊñ∞ÂàõÂª∫Ê®°Âûã
                    existingPlant.userData = plantData;
                    // Â¶ÇÊûúÊòØÁ©∫Âú∞ÔºåÁ°Æ‰øùÊ®°ÂûãÊòØÁ©∫ÁöÑ
                    if (plantData.is_empty && existingPlant.children.length > 0) {
                        // Ê∏ÖÁ©∫Ê®°Âûã
                        while (existingPlant.children.length > 0) {
                            const child = existingPlant.children[0];
                            existingPlant.remove(child);
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    }
                    return; // Ë∑≥ËøáÂàõÂª∫Ôºå‰ΩøÁî®Â∑≤Â≠òÂú®ÁöÑÊ®°Âûã
                }
                
                const plant = createPlantModel(plantData);
                plant.position.set(
                    plantData.position.x,
                    plantData.position.y,
                    plantData.position.z
                );
                plant.userData = plantData;
                farm.add(plant);
            });
        }
        
        // Êõ¥Êñ∞Ê§çÁâ©ÁöÑÊûúÂÆûÊï∞ÈáèÊ†áÁ≠æ
        function updateFruitLabel(plantGroup, health) {
            // Âè™ÊúâÈùûÊùÇËçâ‰∏îÂÆåÂÖ®ÊàêÁÜüÔºàÈò∂ÊÆµ3ÔºâÁöÑÊ§çÁâ©ÊâçÊúâÊûúÂÆû
            if (plantGroup.userData.is_weed || plantGroup.userData.growth_stage < 3) {
                return;
            }
            
            // ËÆ°ÁÆóÊûúÂÆûÊï∞ÈáèÔºà‰∏éÊúçÂä°Âô®Á´ØÁõ∏ÂêåÁöÑÈÄªËæëÔºâ
            let fruitCount = 0;
            if (health >= 90) fruitCount = 5;
            else if (health >= 75) fruitCount = 4;
            else if (health >= 60) fruitCount = 3;
            else if (health >= 40) fruitCount = 2;
            else fruitCount = 1;
            
            // Êü•ÊâæÂπ∂Êõ¥Êñ∞Áé∞ÊúâÊ†áÁ≠æ
            const existingLabel = plantGroup.getObjectByName('fruit_label');
            if (existingLabel) {
                // ÁßªÈô§ÊóßÊ†áÁ≠æ
                plantGroup.remove(existingLabel);
                if (existingLabel.material.map) existingLabel.material.map.dispose();
                if (existingLabel.material) existingLabel.material.dispose();
            }
            
            // ÂàõÂª∫Êñ∞Ê†áÁ≠æ
            const stemHeight = plantGroup.userData.growth_stage === 3 ? 0.45 : 0.3;
            const topRadius = 0.15 * plantGroup.userData.growth_stage;
            createFruitCountLabel(plantGroup, fruitCount, stemHeight + topRadius);
        }
        
        // ÂàõÂª∫ÊûúÂÆûÊï∞ÈáèÊ†áÁ≠æ
        function createFruitCountLabel(plantGroup, fruitCount, height) {
            // ÂàõÂª∫ÁîªÂ∏É
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            // ÁªòÂà∂ËÉåÊôØÔºàÂçäÈÄèÊòéÂúÜËßíÁü©ÂΩ¢Ôºâ
            context.fillStyle = 'rgba(255, 215, 0, 0.9)';  // ÈáëËâ≤ËÉåÊôØ
            context.strokeStyle = 'rgba(255, 140, 0, 1)';   // Ê∑±Ê©ôËâ≤ËæπÊ°Ü
            context.lineWidth = 4;
            
            const rectX = 10;
            const rectY = 10;
            const rectW = 108;
            const rectH = 44;
            const radius = 8;
            
            context.beginPath();
            context.moveTo(rectX + radius, rectY);
            context.lineTo(rectX + rectW - radius, rectY);
            context.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
            context.lineTo(rectX + rectW, rectY + rectH - radius);
            context.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
            context.lineTo(rectX + radius, rectY + rectH);
            context.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
            context.lineTo(rectX, rectY + radius);
            context.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
            context.closePath();
            context.fill();
            context.stroke();
            
            // ÁªòÂà∂ÊûúÂÆûÂõæÊ†áÔºà‰ΩøÁî®emojiÔºâ
            context.font = 'bold 24px Arial';
            context.fillText('üçé', 18, 38);
            
            // ÁªòÂà∂Êï∞Èáè
            context.font = 'bold 28px Arial';
            context.fillStyle = '#8B4513';  // Ê£ïËâ≤ÊñáÂ≠ó
            context.textAlign = 'right';
            context.fillText('x' + fruitCount, 105, 40);
            
            // ÂàõÂª∫Á∫πÁêÜ
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            // ÂàõÂª∫ Sprite
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,  // ÂßãÁªàÊòæÁ§∫Âú®ÊúÄÂâçÈù¢
                depthWrite: false
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.y = height + 0.5;  // Âú®Ê§çÁâ©‰∏äÊñπ
            sprite.scale.set(0.8, 0.4, 1);     // ÈÄÇÂΩìÁöÑÂ§ßÂ∞è
            sprite.name = 'fruit_label';
            
            plantGroup.add(sprite);
        }
        
        function createPlantModel(plantData) {
            const group = new THREE.Group();
            
            // üîπ Á©∫Âú∞Ôºö‰∏çÊòæÁ§∫‰ªª‰ΩïÊ®°Âûã
            if (plantData.is_empty) {
                group.userData.is_empty = true;
                return group;
            }
            
            // üå± ÁßçÂ≠êÔºöÊòæÁ§∫Â∞èÊ£ïËâ≤ÁêÉ
            if (plantData.is_seed) {
                const seedGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const seedMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,  // Ê£ïËâ≤
                    roughness: 0.8,
                    metalness: 0.2
                });
                const seed = new THREE.Mesh(seedGeometry, seedMaterial);
                seed.position.y = 0.05;
                seed.castShadow = true;
                group.add(seed);
                
                group.userData.is_seed = true;
                return group;
            }
            
            // Ê†πÊçÆÁ±ªÂûãÈÄâÊã©È¢úËâ≤ÔºàÊàêÈïøÈò∂ÊÆµË∂äÈ´òÈ¢úËâ≤Ë∂äÊ∑±Ôºâ
            let color = plantData.is_weed ? 0x8B4513 : 0x32CD32;
            if (!plantData.is_weed) {
                // Ëî¨ËèúÊ†πÊçÆÊàêÈïøÈò∂ÊÆµË∞ÉÊï¥È¢úËâ≤
                if (plantData.growth_stage === 1) {
                    color = 0x7CFC00;  // ËçâÁªøËâ≤ÔºàÂπºËãóÔºâ
                } else if (plantData.growth_stage === 2) {
                    color = 0x32CD32;  // ÈÖ∏Ê©ôÁªøÔºàÊàêÈïø‰∏≠Ôºâ
                } else if (plantData.growth_stage === 3) {
                    color = 0x228B22;  // Ê£ÆÊûóÁªøÔºàÊàêÁÜüÔºâ
                }
            }
            
            // Ê†πÊçÆÊàêÈïøÈò∂ÊÆµË∞ÉÊï¥Â∞∫ÂØ∏
            const growthScale = plantData.growth_stage || 1;
            const baseSize = 1.0;
            const stemHeight = 0.08 * growthScale;
            const stemRadius = 0.005 * growthScale;
            const topRadius = 0.015 * growthScale;
            
            // ÁÆÄÂçïÁöÑÊ§çÁâ©Ê®°ÂûãÔºàÂúÜÊü±Ëåé + ÁêÉÂΩ¢È°∂Ôºâ
            const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius * 1.5, stemHeight, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({ color: color });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = stemHeight / 2;
            stem.castShadow = true;
            group.add(stem);
            
            const topGeometry = new THREE.SphereGeometry(topRadius, 8, 8);
            const top = new THREE.Mesh(topGeometry, stemMaterial);
            top.position.y = stemHeight;
            top.castShadow = true;
            group.add(top);
            
            // ÊàêÈïøÈò∂ÊÆµ3Ê∑ªÂä†È¢ùÂ§ñÁöÑÂè∂Â≠êÊïàÊûú
            if (plantData.growth_stage === 3 && !plantData.is_weed) {
                for (let i = 0; i < 4; i++) {
                    const leafGeometry = new THREE.SphereGeometry(topRadius * 0.6, 6, 6);
                    const leaf = new THREE.Mesh(leafGeometry, stemMaterial);
                    const angle = (i / 4) * Math.PI * 2;
                    leaf.position.x = Math.cos(angle) * topRadius * 0.8;
                    leaf.position.y = stemHeight * 0.8;
                    leaf.position.z = Math.sin(angle) * topRadius * 0.8;
                    leaf.scale.y = 0.5;
                    group.add(leaf);
                }
                
                // üçé Ê†πÊçÆÂÅ•Â∫∑Â∫¶Ê∑ªÂä†ÊûúÂÆû
                const health = plantData.health || 100;
                let fruitCount = 0;
                if (health >= 90) fruitCount = 5;
                else if (health >= 75) fruitCount = 4;
                else if (health >= 60) fruitCount = 3;
                else if (health >= 40) fruitCount = 2;
                else fruitCount = 1;
                
                // ÂàõÂª∫ÊûúÂÆûÔºàÈ≤úËâ≥ÁöÑÂ∞èÁêÉÔºâ
                const fruitColors = [0xFF6B6B, 0xFFD93D, 0xFF8C42, 0xFFA07A, 0xFF6347];
                for (let i = 0; i < fruitCount; i++) {
                    const fruitGeometry = new THREE.SphereGeometry(topRadius * 0.5, 8, 8);
                    const fruitMaterial = new THREE.MeshStandardMaterial({
                        color: fruitColors[i % fruitColors.length],
                        emissive: fruitColors[i % fruitColors.length],
                        emissiveIntensity: 0.3,
                        metalness: 0.1,
                        roughness: 0.7
                    });
                    const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
                    
                    // ÈöèÊú∫ÂàÜÂ∏ÉÂú®Ê§çÁâ©È°∂ÈÉ®Âë®Âõ¥
                    const angle = (i / fruitCount) * Math.PI * 2 + Math.random() * 0.5;
                    const radius = topRadius * (0.6 + Math.random() * 0.4);
                    fruit.position.x = Math.cos(angle) * radius;
                    fruit.position.y = stemHeight + topRadius * (0.3 + Math.random() * 0.4);
                    fruit.position.z = Math.sin(angle) * radius;
                    fruit.castShadow = true;
                    fruit.name = 'fruit';
                    group.add(fruit);
                }
                
                // Â≠òÂÇ®ÊûúÂÆûÊï∞ÈáèÂà∞userData
                group.userData.fruitCount = fruitCount;
                
                // üè∑Ô∏è ÂàõÂª∫ÊûúÂÆûÊï∞ÈáèÊ†áÁ≠æÔºà3DÊñáÊú¨Ôºâ
                createFruitCountLabel(group, fruitCount, stemHeight + topRadius);
            }
            
            // ÊùÇËçâÈò∂ÊÆµ3‰πüÊúâÁâπÊÆäÂΩ¢ÊÄÅÔºàÊõ¥Â§ß„ÄÅÊõ¥ËåÇÁõõÔºâ
            if (plantData.growth_stage === 3 && plantData.is_weed) {
                // Ê∑ªÂä†È¢ùÂ§ñÁöÑÊùÇËçâÊûùÊù°
                for (let i = 0; i < 6; i++) {
                    const branchGeometry = new THREE.SphereGeometry(topRadius * 0.4, 6, 6);
                    const branch = new THREE.Mesh(branchGeometry, stemMaterial);
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = topRadius * (1.0 + Math.random() * 0.3);
                    branch.position.x = Math.cos(angle) * radius;
                    branch.position.y = stemHeight * (0.5 + Math.random() * 0.5);
                    branch.position.z = Math.sin(angle) * radius;
                    branch.scale.y = 0.6;
                    group.add(branch);
                }
                
                group.userData.canSpread = true;  // Ê†áËÆ∞ÂèØ‰ª•Êâ©Êï£
            }
            
            return group;
        }
        
        // ========== Èº†Ê†áÈîÅÂÆöÊéßÂà∂ ==========
        function onPointerLockChange() {
            mouseControl.isLocked = document.pointerLockElement === renderer.domElement;
            
            const crosshair = document.querySelector('.crosshair');
            if (mouseControl.isLocked) {
                crosshair.classList.add('locked');
                showMessage('üîí Èº†Ê†áÂ∑≤ÈîÅÂÆö - ÊåâESCÈÄÄÂá∫', 'info');
            } else {
                crosshair.classList.remove('locked');
            }
        }
        
        function onMouseMove(event) {
            if (!mouseControl.isLocked) return;
            if (cameraMode === 'free' || cameraMode === 'birds_eye') return;
            
            // ËÆ°ÁÆóÁõÆÊ†áËßíÂ∫¶
            const targetYaw = mouseControl.yaw - event.movementX * mouseControl.sensitivity;
            const targetPitch = mouseControl.pitch - event.movementY * mouseControl.sensitivity;
            
            // Âπ≥ÊªëÊèíÂÄºÔºàËÆ©Èº†Ê†áÁßªÂä®Êõ¥È°∫ÊªëÔºâ
            mouseControl.yaw += (targetYaw - mouseControl.yaw) * (1 - mouseControl.smoothing);
            mouseControl.pitch += (targetPitch - mouseControl.pitch) * (1 - mouseControl.smoothing);
            
            // ÈôêÂà∂‰øØ‰ª∞Ëßí
            mouseControl.pitch = Math.max(-mouseControl.maxPitch, Math.min(mouseControl.maxPitch, mouseControl.pitch));
            
            // FPSÊ®°ÂºèÔºöÂ∞èËΩ¶ÊúùÂêëË∑üÈöèÈº†Ê†áÊ∞¥Âπ≥ËßíÂ∫¶
            if (cameraMode === 'first_person') {
                cart.rotation.y = mouseControl.yaw;
            }
        }
        
        // ========== Èº†Ê†áÊªöËΩÆÁº©Êîæ ==========
        function onMouseWheel(event) {
            event.preventDefault();
            
            // ÊªöËΩÆÂêë‰∏äÁº©Â∞èË∑ùÁ¶ªÔºàÊãâËøëÔºâÔºåÂêë‰∏ãÂ¢ûÂ§ßË∑ùÁ¶ªÔºàÊãâËøúÔºâ
            const delta = event.deltaY > 0 ? 1 : -1;
            cameraZoom.distance += delta * cameraZoom.zoomSpeed;
            
            // ÈôêÂà∂ËåÉÂõ¥
            cameraZoom.distance = Math.max(cameraZoom.minDistance, Math.min(cameraZoom.maxDistance, cameraZoom.distance));
            
            // ÊòæÁ§∫ÊèêÁ§∫
            showMessage(`üîç ËßÜË∑ù: ${cameraZoom.distance.toFixed(1)}m`, 'info');
        }
        
        // ========== ÈîÆÁõòÊéßÂà∂ ==========
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            
            // ESCËß£ÈîÅÈº†Ê†á
            if (event.key === 'Escape') {
                if (mouseControl.isLocked) {
                    document.exitPointerLock();
                }
                return;
            }
            
            // ÁßªÂä®ÊéßÂà∂
            if (key === 'w') keys.forward = true;
            if (key === 's') keys.backward = true;
            if (key === 'a') keys.left = true;
            if (key === 'd') keys.right = true;
            if (key === 'q') keys.rotateLeft = true;
            if (key === 'e') keys.rotateRight = true;
            
            // Á©∫Ê†ºÈîÆ - ÂàπËΩ¶ÊàñËß¶ÂèëË£ÖÂ§á
            if (key === ' ') {
                event.preventDefault();
                if (event.repeat) return;
                
                const config = equipmentConfig[gameState.currentEquipment];
                
                if (config && (config.interactionType === 'auto' || config.interactionType === 'scanner_cone')) {
                    useAutoEquipment();
                } else if (config && config.interactionType === 'auto_aim') {
                    useAutoLaser();
                } else if (config && config.interactionType === 'cone') {
                    useSprayAuto();
                } else if (config && config.interactionType === 'area') {
                    useWaterAuto();
                } else {
                    keys.brake = true;
                }
                return;
            }

            // TÈîÆ - Ë¥™ÂøÉÁÆóÊ≥ïËá™Âä®Êí≠Áßç
            if (key === 't') {
                if (event.repeat) return;
                startGreedyPlanting();
                return;
            }
            
            // YÈîÆ - ÂÆåÊï¥Ëá™Âä®ÂåñÂÜúÂú∫ÔºàÊí≠Áßç‚ÜíÈô§Ëçâ‚ÜíÊµáÊ∞¥‚ÜíÊî∂Ëé∑Ôºâ
            if (key === 'y') {
                if (event.repeat) return;
                startFullAutoFarm();
                return;
            }
            
            // ShiftÂÜ≤Âà∫ÔºàFPSÈ£éÊ†ºÔºâ
            if (key === 'shift') {
                keys.boost = true;
                moveState.isSprinting = true;
            }
            
            // CtrlËπ≤‰ºèÔºàFPSÈ£éÊ†ºÔºâ
            if (key === 'control') {
                moveState.isCrouching = !moveState.isCrouching;
                event.preventDefault();
            }
            
            // ËßÜËßíÂàáÊç¢
            if (event.key === 'F1') switchCameraMode('third_person');
            if (event.key === 'F2') switchCameraMode('first_person');
            if (event.key === 'F3') switchCameraMode('free');
            if (event.key === 'F4') switchCameraMode('birds_eye');
            
            // Ë£ÖÂ§áÂàáÊç¢
            if (key === '1') switchEquipment('laser');
            if (key === '2') switchEquipment('scanner');
            if (key === '3') switchEquipment('soil');
            if (key === '4') switchEquipment('spray');
            if (key === '5') switchEquipment('water');    // 5ÈîÆ - ÊµáÊ∞¥
            if (key === 'p') switchEquipment('planter');  // PÈîÆ - Êí≠ÁßçÂô® (Planter)
            if (key === 'h') switchEquipment('arm');      // HÈîÆ - Êú∫Ê¢∞ËáÇÊî∂Ëé∑ (Harvest)
        }
        
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            
            if (key === 'w') keys.forward = false;
            if (key === 's') keys.backward = false;
            if (key === 'a') keys.left = false;
            if (key === 'd') keys.right = false;
            if (key === 'q') keys.rotateLeft = false;
            if (key === 'e') keys.rotateRight = false;
            if (key === ' ') keys.brake = false;
            if (key === 'shift') {
                keys.boost = false;
                moveState.isSprinting = false;
            }
        }
        
        // ========== Êõ¥Êñ∞Â∞èËΩ¶ÔºàFPSÈ£éÊ†ºÔºâ==========
        function updateCart(deltaTime) {
            
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊâãÂä®ËæìÂÖ•
            const isManualInput = (
                keys.forward || keys.backward || keys.left || keys.right ||
                keys.rotateLeft || keys.rotateRight
            );
            
            // Â¶ÇÊûúÊ£ÄÊµãÂà∞ÊâãÂä®ËæìÂÖ•‰∏îËá™Âä®Â∑°Ëà™ÊøÄÊ¥ªÔºåÂÅúÊ≠¢Ëá™Âä®Â∑°Ëà™
            if (isManualInput && autoTraverse.active) {
                stopAutoTraverse('manual control');
            }
            
            // Á°ÆÂÆöÂΩìÂâçÊúÄÂ§ßÈÄüÂ∫¶
            let currentMaxSpeed = maxSpeed;
            if (moveState.isSprinting && keys.forward) {
                currentMaxSpeed = sprintSpeed;
            } else if (moveState.isCrouching) {
                currentMaxSpeed = crouchSpeed;
            }
            
            // Ê£ÄÊü•Ëá™Âä®Â∑°Ëà™
            let autoMove = null;
            if (autoTraverse.active && !isManualInput) {
                autoMove = updateAutoTraverse(deltaTime);
            }
            
            // FPSÊ®°ÂºèÔºö‰ΩøÁî®Áõ∏Êú∫ÊúùÂêë‰Ωú‰∏∫ÁßªÂä®ÊñπÂêë
            let moveDirection = new THREE.Vector3();
            
            // Â¶ÇÊûúËá™Âä®Â∑°Ëà™ÊøÄÊ¥ªÔºå‰ΩøÁî®Ëá™Âä®Â∑°Ëà™ÁöÑÊñπÂêë
            if (autoMove && autoMove.direction) {
                moveDirection.copy(autoMove.direction);
                currentMaxSpeed = autoMove.speed;
            } else if (cameraMode === 'first_person' && mouseControl.isLocked) {
                // ‰ΩøÁî®Èº†Ê†áÊúùÂêëÔºàÊ∞¥Âπ≥Ôºâ‰Ωú‰∏∫ÁßªÂä®ÊñπÂêë
                const forwardDir = new THREE.Vector3(
                    Math.sin(mouseControl.yaw),
                    0,
                    Math.cos(mouseControl.yaw)
                );
                const rightDir = new THREE.Vector3(
                    Math.sin(mouseControl.yaw - Math.PI / 2),
                    0,
                    Math.cos(mouseControl.yaw - Math.PI / 2)
                );
                
                if (keys.forward) moveDirection.add(forwardDir);
                if (keys.backward) moveDirection.sub(forwardDir.multiplyScalar(0.6));
                if (keys.left) moveDirection.add(rightDir);
                if (keys.right) moveDirection.sub(rightDir);
                
            } else {
                // ‰º†ÁªüÊ®°ÂºèÔºö‰ΩøÁî®Â∞èËΩ¶ÊúùÂêë
                if (keys.forward) {
                    const fwd = new THREE.Vector3(0, 0, -1);
                    fwd.applyQuaternion(cart.quaternion);
                    moveDirection.add(fwd);
                }
                if (keys.backward) {
                    const bwd = new THREE.Vector3(0, 0, 1);
                    bwd.applyQuaternion(cart.quaternion);
                    moveDirection.add(bwd.multiplyScalar(0.6));
                }
                if (keys.left) {
                    const left = new THREE.Vector3(-1, 0, 0);
                    left.applyQuaternion(cart.quaternion);
                    moveDirection.add(left);
                }
                if (keys.right) {
                    const right = new THREE.Vector3(1, 0, 0);
                    right.applyQuaternion(cart.quaternion);
                    moveDirection.add(right);
                }
                
                // ÊóãËΩ¨ÊéßÂà∂ÔºàÈùûFPSÊ®°ÂºèÔºâ
                if (keys.rotateLeft) cart.rotation.y += rotationSpeed * deltaTime;
                if (keys.rotateRight) cart.rotation.y -= rotationSpeed * deltaTime;
            }
            
            // ÂΩí‰∏ÄÂåñÁßªÂä®ÊñπÂêë
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
            }
            
            // ËÆ°ÁÆóÁõÆÊ†áÈÄüÂ∫¶ÂêëÈáè
            const targetVelocity = moveDirection.multiplyScalar(currentMaxSpeed);
            
            // Âπ≥ÊªëÊèíÂÄºÂà∞ÁõÆÊ†áÈÄüÂ∫¶ÔºàÊÉØÊÄßÁ≥ªÁªüÔºâ
            if (keys.brake) {
                // Âè™ÊúâÈùûËá™Âä®ÁßªÂä®Êó∂ÊâçÂÖÅËÆ∏ÊâãÂä®ÂàπËΩ¶
                cartVelocity.multiplyScalar(0.7); // ÂàπËΩ¶
            } else if (moveDirection.length() > 0) {
                // ÊúâËæìÂÖ•ÔºöÂä†ÈÄüÂà∞ÁõÆÊ†áÈÄüÂ∫¶ÔºàËá™Âä®ÁßªÂä®ÊàñÊâãÂä®ÁßªÂä®ÈÉΩÈÄÇÁî®Ôºâ
                cartVelocity.lerp(targetVelocity, acceleration * deltaTime);
            } else {
                // Êó†ËæìÂÖ•ÔºöÊë©Êì¶ÂáèÈÄü
                cartVelocity.multiplyScalar(Math.pow(friction, deltaTime * 60));
            }
            
            // Â∫îÁî®ÈÄüÂ∫¶
            cart.position.add(cartVelocity.clone().multiplyScalar(deltaTime));
            
            
            // ËÆ°ÁÆóÂÆûÈôÖÈÄüÂ∫¶ÔºàÁî®‰∫éÊòæÁ§∫ÂíåÊëáÊôÉÔºâ
            cartSpeed = cartVelocity.length();
            
            // Êõ¥Êñ∞ËßÜËßíÊëáÊôÉ
            if (headBob.enabled && cartSpeed > 0.1 && (keys.forward || keys.backward || keys.left || keys.right)) {
                headBob.time += deltaTime * headBob.frequency * (cartSpeed / maxSpeed);
            }
            
            // Êõ¥Êñ∞Áõ∏Êú∫È´òÂ∫¶ÔºàËπ≤‰ºèÂä®ÁîªÔºâ
            const targetHeight = moveState.isCrouching ? moveState.crouchHeight : moveState.normalHeight;
            moveState.currentHeight += (targetHeight - moveState.currentHeight) * 10 * deltaTime;
            
            // Êõ¥Êñ∞UI
            const speedKmH = (cartSpeed * 3.6).toFixed(0); // ËΩ¨Êç¢‰∏∫km/h
            const speedDisplay = moveState.isSprinting ? `${speedKmH} üèÉ` : 
                                moveState.isCrouching ? `${speedKmH} ü¶Ü` : 
                                `${speedKmH}`;
            document.getElementById('cart-speed').textContent = speedDisplay + ' km/h';
            document.getElementById('cart-position').textContent = 
                `(${cart.position.x.toFixed(1)}, ${cart.position.z.toFixed(1)})`;
        }
        
        // ========== Êõ¥Êñ∞Áõ∏Êú∫ ==========
        function updateCamera() {
            if (cameraMode === 'third_person') {
                // Á¨¨‰∏â‰∫∫Áß∞Ë∑üÈöè + Èº†Ê†áÊéßÂà∂
                if (mouseControl.isLocked) {
                    // ‰ΩøÁî®Èº†Ê†áÊéßÂà∂ÁöÑËßíÂ∫¶ÂíåÂèØÁº©ÊîæË∑ùÁ¶ª
                    const distance = cameraZoom.distance;
                    const height = 2.5;
                    
                    // ËÆ°ÁÆóÁõ∏Êú∫‰ΩçÁΩÆÔºàÂõ¥ÁªïÂ∞èËΩ¶ÊóãËΩ¨Ôºâ
                    const camX = Math.sin(mouseControl.yaw) * distance * Math.cos(mouseControl.pitch);
                    const camY = height + Math.sin(mouseControl.pitch) * distance;
                    const camZ = Math.cos(mouseControl.yaw) * distance * Math.cos(mouseControl.pitch);
                    
                    const targetPosition = cart.position.clone().add(new THREE.Vector3(camX, camY, camZ));
                    camera.position.lerp(targetPosition, 0.1);
                    
                    // Ê∑ªÂä†ÈúáÂä®ÂÅèÁßª
                    camera.position.add(cameraShakeOffset);
                    
                    // ÁúãÂêëÂ∞èËΩ¶
                    const lookAtPoint = cart.position.clone();
                    lookAtPoint.y += 0.5;
                    camera.lookAt(lookAtPoint);
                } else {
                    // ÈªòËÆ§Ë∑üÈöèÔºàÊó†Èº†Ê†áÊéßÂà∂Ôºâ
                    const offset = new THREE.Vector3(0, 2.5, 4);
                    offset.applyQuaternion(cart.quaternion);
                    const targetPosition = cart.position.clone().add(offset);
                    camera.position.lerp(targetPosition, 0.1);
                    
                    // Ê∑ªÂä†ÈúáÂä®ÂÅèÁßª
                    camera.position.add(cameraShakeOffset);
                    
                    const lookAtOffset = new THREE.Vector3(0, 0.5, -2);
                    lookAtOffset.applyQuaternion(cart.quaternion);
                    const lookAtPoint = cart.position.clone().add(lookAtOffset);
                    camera.lookAt(lookAtPoint);
                }
                
            } else if (cameraMode === 'first_person') {
                // Á¨¨‰∏Ä‰∫∫Áß∞ + Èº†Ê†áÊéßÂà∂ÔºàFPSÈ£éÊ†ºÔºâ
                const baseOffset = new THREE.Vector3(0, moveState.currentHeight, 0);
                
                // Ê∑ªÂä†ËßÜËßíÊëáÊôÉÊïàÊûúÔºàHead BobbingÔºâ
                if (headBob.enabled && cartSpeed > 0.1) {
                    headBob.currentOffset.y = Math.sin(headBob.time) * headBob.amplitude;
                    headBob.currentOffset.x = Math.cos(headBob.time * 0.5) * headBob.amplitude * 0.5;
                } else {
                    // Âπ≥ÊªëÂõûÂà∞‰∏≠ÂøÉ
                    headBob.currentOffset.multiplyScalar(0.9);
                }
                
                // Â∫îÁî®ÊâÄÊúâÂÅèÁßªÔºàÂü∫Á°Ä + ÊëáÊôÉ + ÈúáÂä®Ôºâ
                camera.position.copy(cart.position)
                    .add(baseOffset)
                    .add(headBob.currentOffset)
                    .add(cameraShakeOffset);
                
                if (mouseControl.isLocked) {
                    // ‰ΩøÁî®Èº†Ê†áÊéßÂà∂ËßÜËßíÔºàFPSÊ†áÂáÜÔºâ
                    const lookDirection = new THREE.Vector3(
                        Math.sin(mouseControl.yaw) * Math.cos(mouseControl.pitch),
                        Math.sin(mouseControl.pitch),
                        -Math.cos(mouseControl.yaw) * Math.cos(mouseControl.pitch)
                    );
                    const lookAtPoint = camera.position.clone().add(lookDirection);
                    camera.lookAt(lookAtPoint);
                } else {
                    // ÈªòËÆ§Ë∑üÈöèÂ∞èËΩ¶ÊñπÂêë
                    camera.quaternion.copy(cart.quaternion);
                }
                
            } else if (cameraMode === 'free') {
                // Ëá™Áî±Áõ∏Êú∫
                orbitControls.update();
                
            } else if (cameraMode === 'birds_eye') {
                // È∏üÁû∞
                camera.position.set(0, 8, 0);
                camera.lookAt(0, 0, 0);
            }
        }
        
        // ========== ÂàáÊç¢Áõ∏Êú∫Ê®°Âºè ==========
        function switchCameraMode(mode) {
            cameraMode = mode;
            orbitControls.enabled = (mode === 'free');
            
            // ÂàáÊç¢Âà∞Ëá™Áî±Áõ∏Êú∫ÊàñÈ∏üÁû∞Êó∂Ëß£ÈîÅÈº†Ê†á
            if (mode === 'free' || mode === 'birds_eye') {
                if (mouseControl.isLocked) {
                    document.exitPointerLock();
                }
            }
            
            // ÈáçÁΩÆÈº†Ê†áËßíÂ∫¶
            if (mode === 'third_person' || mode === 'first_person') {
                mouseControl.yaw = cart.rotation.y;  // ‰ΩøÁî®Â∞èËΩ¶ÂΩìÂâçÊúùÂêë
                mouseControl.pitch = 0;
            }
            
            // ÂàáÊç¢Âà∞Á¨¨‰∏Ä‰∫∫Áß∞Êó∂Ëá™Âä®ÈîÅÂÆöÈº†Ê†áÔºàCFÈ£éÊ†ºÔºâ
            if (mode === 'first_person' && !mouseControl.isLocked) {
                renderer.domElement.requestPointerLock();
            }
            
            const modeNames = {
                'third_person': 'Á¨¨‰∏â‰∫∫Áß∞ÔºàÁÇπÂáªÈîÅÂÆöÈº†Ê†áÔºâ',
                'first_person': 'Á¨¨‰∏Ä‰∫∫Áß∞ÔºàÁÇπÂáªÈîÅÂÆöÈº†Ê†áÔºâ',
                'free': 'Ëá™Áî±Áõ∏Êú∫',
                'birds_eye': 'È∏üÁû∞ËßÜËßí'
            };
            
            showMessage(modeNames[mode], 'info');
        }
        
        // ========== ÂàõÂª∫ÊøÄÂÖâÁûÑÂáÜËæÖÂä©Á∫ø ==========
        function createLaserAimLine() {
            try {
                console.log('üî¥ ÂàõÂª∫ÊøÄÂÖâÁûÑÂáÜÁ∫ø...');
                
            // ÁßªÈô§ÊóßÁöÑÁûÑÂáÜÁ∫ø
            if (laserAimLine) {
                scene.remove(laserAimLine);
                if (laserAimLine.geometry) laserAimLine.geometry.dispose();
                if (laserAimLine.material) laserAimLine.material.dispose();
                    laserAimLine = null;
            }
            if (laserAimDot) {
                scene.remove(laserAimDot);
                if (laserAimDot.geometry) laserAimDot.geometry.dispose();
                if (laserAimDot.material) laserAimDot.material.dispose();
                    laserAimDot = null;
            }
            
                // ÂàõÂª∫ÊøÄÂÖâÂ∞ÑÁ∫øÁ∫øÊù°ÔºàÂàùÂßãÂåñ‰∏ÄÊù°‰ªéÂéüÁÇπÂà∞ÂâçÊñπÁöÑÁ∫øÔºâ
            const lineGeometry = new THREE.BufferGeometry();
                const initialPositions = new Float32Array([
                    0, 0, 0,  // Ëµ∑ÁÇπ
                    1, 0, 0   // ÁªàÁÇπÔºàÂàùÂßã1Á±≥Ôºâ
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(initialPositions, 3));
                
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            
            laserAimLine = new THREE.Line(lineGeometry, lineMaterial);
            laserAimLine.frustumCulled = false;
                laserAimLine.visible = true;  // Á°Æ‰øùÂèØËßÅ
                laserAimLine.renderOrder = 999;  // Á°Æ‰øùÂú®ÊúÄ‰∏äÂ±ÇÊ∏≤Êüì
            scene.add(laserAimLine);
                console.log('‚úÖ ÊøÄÂÖâÁ∫øÂàõÂª∫ÊàêÂäüÔºåÂ∑≤Ê∑ªÂä†Âà∞Âú∫ÊôØ');
            } catch (error) {
                console.error('‚ùå ÂàõÂª∫ÊøÄÂÖâÁ∫øÂ§±Ë¥•:', error);
                laserAimLine = null;
                laserAimDot = null;
                return;
            }
            
            try {
            
            // ÂàõÂª∫ÁûÑÂáÜÁÇπÔºàÂçÅÂ≠óÔºâ- Â¢ûÂ§ßÂ∞∫ÂØ∏Êõ¥ÊòìÁûÑÂáÜ
            const dotGroup = new THREE.Group();
            
            // Ê∞¥Âπ≥Á∫øÔºàÂ¢ûÂ§ß50%Ôºâ
            const hLine = new THREE.Mesh(
                new THREE.PlaneGeometry(0.15, 0.015),
                new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                })
            );
            dotGroup.add(hLine);
            
            // ÂûÇÁõ¥Á∫øÔºàÂ¢ûÂ§ß50%Ôºâ
            const vLine = new THREE.Mesh(
                new THREE.PlaneGeometry(0.015, 0.15),
                new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                })
            );
            dotGroup.add(vLine);
            
            // ‰∏≠ÂøÉÁÇπÔºàÂ¢ûÂ§ß50%Ôºâ
            const centerDot = new THREE.Mesh(
                new THREE.CircleGeometry(0.03, 16),
                new THREE.MeshBasicMaterial({
                    color: 0xFFFF00,  // ÈªÑËâ≤‰∏≠ÂøÉÁÇπÊõ¥ÊòéÊòæ
                    transparent: true,
                    opacity: 0.95,
                    side: THREE.DoubleSide
                })
            );
            dotGroup.add(centerDot);
            
            laserAimDot = dotGroup;
                laserAimDot.visible = true;  // Á°Æ‰øùÂèØËßÅ
                laserAimDot.renderOrder = 1000;  // Á°Æ‰øùÂú®ÊøÄÂÖâÁ∫ø‰πã‰∏äÊ∏≤Êüì
            scene.add(laserAimDot);
                console.log('‚úÖ ÊøÄÂÖâÁûÑÂáÜÁÇπÂàõÂª∫ÊàêÂäüÔºåÂ∑≤Ê∑ªÂä†Âà∞Âú∫ÊôØ');
                console.log(`üìä [Ë∞ÉËØï] Âú∫ÊôØ‰∏≠ÂØπË±°Êï∞: ${scene.children.length}`);
            } catch (error) {
                console.error('‚ùå ÂàõÂª∫ÊøÄÂÖâÁûÑÂáÜÁÇπÂ§±Ë¥•:', error);
                // Âç≥‰ΩøÁûÑÂáÜÁÇπÂàõÂª∫Â§±Ë¥•Ôºå‰πü‰∏çÂΩ±ÂìçÂü∫Êú¨ÂäüËÉΩ
                laserAimDot = null;
            }
        }
        
        // ========== Êõ¥Êñ∞ÊøÄÂÖâÁûÑÂáÜÁ∫ø ==========
        // ÊøÄÂÖâÂáª‰∏≠ÁâπÊïà
        let laserHitEffect = null;
        
        function updateLaserAimLine() {
            try {
                if (!laserAimLine || !laserAimDot) {
                    console.warn('‚ö†Ô∏è [Ë∞ÉËØï] ÊøÄÂÖâÁûÑÂáÜÁ∫øÊàñÁûÑÂáÜÁÇπÊú™ÂàõÂª∫:', { laserAimLine: !!laserAimLine, laserAimDot: !!laserAimDot });
                    return;
                }
            
            // Ëé∑ÂèñÊú∫Ê¢∞ËáÇÊú´Á´Ø‰ΩçÁΩÆÔºàÊøÄÂÖâÂèëÂ∞ÑÂô®‰ΩçÁΩÆÔºâ
            const arm = cart.getObjectByName('robotic_arm');
            if (!arm) {
                console.warn('Êâæ‰∏çÂà∞Êú∫Ê¢∞ËáÇ');
                return;
            }
            
            // ÈÄíÂΩíÊü•ÊâæÊøÄÂÖâÂèëÂ∞ÑÂô®ÔºàÂõ†‰∏∫ÂÆÉÂú® axis4 ‰∏ãÈù¢Ôºâ
            let laserEmitter = null;
            arm.traverse((child) => {
                if (child.name === 'laser_emitter') {
                    laserEmitter = child;
                }
            });
            
            if (!laserEmitter) {
                console.warn('Êâæ‰∏çÂà∞ÊøÄÂÖâÂèëÂ∞ÑÂô®');
                return;
            }
            
            // Âº∫Âà∂Êõ¥Êñ∞‰∏ñÁïåÁü©ÈòµÔºàÁ°Æ‰øù‰ΩçÁΩÆÂíåÊóãËΩ¨ÊòØÊúÄÊñ∞ÁöÑÔºâ
            cart.updateMatrixWorld(true);
            
            // Ëé∑ÂèñÊøÄÂÖâÂèëÂ∞ÑÂô®ÁöÑ‰∏ñÁïå‰ΩçÁΩÆ
            const startPos = new THREE.Vector3();
            laserEmitter.getWorldPosition(startPos);
            
            // Ëé∑ÂèñÊøÄÂÖâÂèëÂ∞ÑÂô®ÁöÑ‰∏ñÁïåÊñπÂêëÔºàÊåáÂêëÂâçÊñπ-XÊñπÂêëÔºâ
            const direction = new THREE.Vector3(-1, 0, 0);
            const worldQuaternion = new THREE.Quaternion();
            laserEmitter.getWorldQuaternion(worldQuaternion);
            direction.applyQuaternion(worldQuaternion);
            direction.normalize();
            
            // üîß ÂÖ≥ÈîÆ‰øÆÂ§çÔºöËÆ°ÁÆóÂú∞Èù¢‰∫§ÁÇπÔºà‰∏•Ê†ºÊåâÁÖßÂèëÂ∞ÑÊñπÂêëÔºâ
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const rayForGround = new THREE.Ray(startPos, direction);
            let hitPoint = rayForGround.intersectPlane(groundPlane, new THREE.Vector3());
            
            // Â¶ÇÊûúÊ≤°ÊúâÂáª‰∏≠Âú∞Èù¢ÊàñË∂ÖÂá∫ËåÉÂõ¥Ôºå‰ΩøÁî®ÊúÄÂ§ßÂ∞ÑÁ®ã
            if (!hitPoint || hitPoint.distanceTo(startPos) > 5) {
                hitPoint = new THREE.Vector3().copy(startPos).add(direction.clone().multiplyScalar(5));
            }
            
            // Â∞ÑÁ∫øÊ£ÄÊµãÊ§çÁâ©ÔºàÁî®‰∫éÂáª‰∏≠ÁâπÊïàÔºâ
            const raycaster = new THREE.Raycaster(startPos, direction, 0, 5);
            raycaster.params.Points.threshold = 0.1;
            raycaster.params.Line.threshold = 0.1;
            raycaster.params.Mesh.threshold = 0.05;
            
            const plants = farm.children.filter(child => child.userData && child.userData.id && child.visible);
            const plantIntersects = raycaster.intersectObjects(plants, true);
            
            let hitPlant = null;
            
            if (plantIntersects.length > 0) {
                // Âáª‰∏≠‰∫ÜÊ§çÁâ© - Êõ¥Êñ∞Âáª‰∏≠ÁâπÊïàÔºå‰ΩÜ‰∏çÊîπÂèòÁûÑÂáÜÁÇπ‰ΩçÁΩÆ
                hitPlant = plantIntersects[0].object.parent;
                updateLaserHitEffect(plantIntersects[0].point, hitPlant);
            } else {
                // ÁßªÈô§Âáª‰∏≠ÁâπÊïà
                if (laserHitEffect) {
                    scene.remove(laserHitEffect);
                    if (laserHitEffect.geometry) laserHitEffect.geometry.dispose();
                    if (laserHitEffect.material) laserHitEffect.material.dispose();
                    laserHitEffect = null;
                }
            }
            
            // Êõ¥Êñ∞Â∞ÑÁ∫øÁ∫øÊù°
            const positions = new Float32Array([
                startPos.x, startPos.y, startPos.z,
                hitPoint.x, hitPoint.y, hitPoint.z
            ]);
            laserAimLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            laserAimLine.geometry.attributes.position.needsUpdate = true;
            
            // Êõ¥Êñ∞ÁûÑÂáÜÁÇπ‰ΩçÁΩÆÂíåÊúùÂêë
            laserAimDot.position.copy(hitPoint);
            laserAimDot.position.y = 0.02;  // Áï•È´ò‰∫éÂú∞Èù¢
            laserAimDot.lookAt(laserAimDot.position.x, laserAimDot.position.y + 1, laserAimDot.position.z);
            
            // ËÑâÂÜ≤Âä®Áîª
            const pulseIntensity = 0.7 + Math.sin(Date.now() * 0.005) * 0.3;
            laserAimLine.material.opacity = pulseIntensity * 0.6;
            laserAimDot.children.forEach(child => {
                if (child.material) {
                    child.material.opacity = pulseIntensity * 0.8;
                }
            });
            } catch (error) {
                console.error('‚ùå Êõ¥Êñ∞ÊøÄÂÖâÁûÑÂáÜÁ∫øÂ§±Ë¥•:', error);
                // Âá∫ÈîôÊó∂ÁßªÈô§ÊøÄÂÖâÁûÑÂáÜÁ∫øÔºåÈÅøÂÖçÊåÅÁª≠Êä•Èîô
                if (laserAimLine) {
                    scene.remove(laserAimLine);
                    laserAimLine = null;
                }
                if (laserAimDot) {
                    scene.remove(laserAimDot);
                    laserAimDot = null;
                }
            }
        }
        
        // Âú®Â±èÂπï‰∏äÊòæÁ§∫ÊøÄÂÖâË∞ÉËØï‰ø°ÊÅØ
        function updateLaserDebugInfo() {
            const arm = cart.getObjectByName('robotic_arm');
            let laserEmitter = null;
            if (arm) {
                arm.traverse((child) => {
                    if (child.name === 'laser_emitter') {
                        laserEmitter = child;
                    }
                });
            }
            
            // ÂàõÂª∫Ë∞ÉËØï‰ø°ÊÅØÊòæÁ§∫ÂÖÉÁ¥†ÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
            let debugDiv = document.getElementById('laser-debug-info');
            if (!debugDiv) {
                debugDiv = document.createElement('div');
                debugDiv.id = 'laser-debug-info';
                debugDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.8);
                    color: #0f0;
                    padding: 10px;
                    border: 2px solid #0f0;
                    border-radius: 5px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    z-index: 1000;
                    max-width: 300px;
                `;
                document.body.appendChild(debugDiv);
            }
            
            // Êõ¥Êñ∞‰ø°ÊÅØ
            let info = '<div style="color: #0ff; font-weight: bold;">üî¥ ÊøÄÂÖâË∞ÉËØï‰ø°ÊÅØ</div>';
            info += `<div>ÊøÄÂÖâÁûÑÂáÜÁ∫ø: ${laserAimLine ? '‚úÖ Â≠òÂú®' : '‚ùå ‰∏çÂ≠òÂú®'}</div>`;
            info += `<div>ÊøÄÂÖâÁûÑÂáÜÁÇπ: ${laserAimDot ? '‚úÖ Â≠òÂú®' : '‚ùå ‰∏çÂ≠òÂú®'}</div>`;
            info += `<div>Êú∫Ê¢∞ËáÇ: ${arm ? '‚úÖ Â≠òÂú®' : '‚ùå ‰∏çÂ≠òÂú®'}</div>`;
            info += `<div>ÊøÄÂÖâÂèëÂ∞ÑÂô®: ${laserEmitter ? '‚úÖ Â≠òÂú®' : '‚ùå ‰∏çÂ≠òÂú®'}</div>`;
            
            if (laserEmitter && laserAimLine) {
                const startPos = new THREE.Vector3();
                laserEmitter.getWorldPosition(startPos);
                info += `<div style="margin-top: 5px; color: #ff0;">ÂèëÂ∞ÑÂô®‰ΩçÁΩÆ:</div>`;
                info += `<div>X: ${startPos.x.toFixed(3)}</div>`;
                info += `<div>Y: ${startPos.y.toFixed(3)}</div>`;
                info += `<div>Z: ${startPos.z.toFixed(3)}</div>`;
                
                // ËÆ°ÁÆóÂèëÂ∞ÑÊñπÂêë
                const direction = new THREE.Vector3(-1, 0, 0);
                const worldQuaternion = new THREE.Quaternion();
                laserEmitter.getWorldQuaternion(worldQuaternion);
                direction.applyQuaternion(worldQuaternion);
                direction.normalize();
                
                info += `<div style="margin-top: 5px; color: #f80;">ÂèëÂ∞ÑÊñπÂêë:</div>`;
                info += `<div>X: ${direction.x.toFixed(3)}</div>`;
                info += `<div>Y: ${direction.y.toFixed(3)}</div>`;
                info += `<div>Z: ${direction.z.toFixed(3)}</div>`;
                
                // Ëé∑ÂèñÁûÑÂáÜÁÇπ‰ΩçÁΩÆ
                if (laserAimDot) {
                    info += `<div style="margin-top: 5px; color: #f0f;">ÁûÑÂáÜÁÇπ‰ΩçÁΩÆ:</div>`;
                    info += `<div>X: ${laserAimDot.position.x.toFixed(3)}</div>`;
                    info += `<div>Y: ${laserAimDot.position.y.toFixed(3)}</div>`;
                    info += `<div>Z: ${laserAimDot.position.z.toFixed(3)}</div>`;
                    
                    const distance = startPos.distanceTo(laserAimDot.position);
                    info += `<div style="color: #fff;">Ë∑ùÁ¶ª: ${distance.toFixed(2)}m</div>`;
                    
                    // ËÆ°ÁÆóÊúüÊúõÊñπÂêëÔºà‰ªéÂèëÂ∞ÑÂô®ÊåáÂêëÁûÑÂáÜÁÇπÔºâ
                    const expectedDir = new THREE.Vector3();
                    expectedDir.subVectors(laserAimDot.position, startPos).normalize();
                    info += `<div style="margin-top: 5px; color: #0ff;">ÊúüÊúõÊñπÂêë:</div>`;
                    info += `<div>X: ${expectedDir.x.toFixed(3)}</div>`;
                    info += `<div>Y: ${expectedDir.y.toFixed(3)}</div>`;
                    info += `<div>Z: ${expectedDir.z.toFixed(3)}</div>`;
                    
                    // ËÆ°ÁÆóÊñπÂêëÂ∑ÆÂºÇ
                    const angleDiff = direction.angleTo(expectedDir) * 180 / Math.PI;
                    info += `<div style="color: ${angleDiff < 5 ? '#0f0' : '#f00'};">ÊñπÂêëÂÅèÂ∑Æ: ${angleDiff.toFixed(1)}¬∞</div>`;
                }
            }
            
            // Â∞èËΩ¶‰ΩçÁΩÆ
            info += `<div style="margin-top: 5px; color: #0ff;">Â∞èËΩ¶‰ΩçÁΩÆ:</div>`;
            info += `<div>X: ${cart.position.x.toFixed(3)}</div>`;
            info += `<div>Z: ${cart.position.z.toFixed(3)}</div>`;
            info += `<div>ÊúùÂêë: ${(cart.rotation.y * 180 / Math.PI).toFixed(1)}¬∞</div>`;
            
            debugDiv.innerHTML = info;
        }
        
        // Êõ¥Êñ∞ÊøÄÂÖâÂáª‰∏≠ÁâπÊïà
        function updateLaserHitEffect(position, plant) {
            const plantData = plant.userData;
            const isWeed = plantData.is_weed;
            
            // Ê†πÊçÆÊ§çÁâ©Á±ªÂûãÈÄâÊã©È¢úËâ≤
            const color = isWeed ? 0xFF4444 : 0xFFAA00;  // ÊùÇËçâ=Á∫¢Ëâ≤ÔºåËî¨Ëèú=Ê©ôËâ≤
            
            // ÂàõÂª∫ÊàñÊõ¥Êñ∞ÂÖâÁéØÁâπÊïà
            if (!laserHitEffect) {
                const ringGeometry = new THREE.RingGeometry(0.03, 0.05, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                laserHitEffect = new THREE.Mesh(ringGeometry, ringMaterial);
                laserHitEffect.rotation.x = -Math.PI / 2;  // Âπ≥ÊîæÂú®Âú∞Èù¢
                scene.add(laserHitEffect);
            }
            
            // Êõ¥Êñ∞‰ΩçÁΩÆ
            laserHitEffect.position.copy(position);
            laserHitEffect.position.y += 0.03;  // Áï•È´ò‰∫éÂáª‰∏≠ÁÇπ
            
            // Êõ¥Êñ∞È¢úËâ≤
            laserHitEffect.material.color.setHex(color);
            
            // Âä®ÊÄÅÊî∂Áº©ËÑâÂÜ≤ÊïàÊûú
            const time = Date.now() * 0.008;
            const pulse = 0.5 + Math.sin(time) * 0.5;  // 0~1
            
            // Êî∂Áº©ÊïàÊûúÔºö‰ªéÂ§ßÂà∞Â∞èÂæ™ÁéØ
            const scale = 1.5 - pulse * 0.8;  // 1.5 -> 0.7
            laserHitEffect.scale.set(scale, scale, 1);
            
            // ÈÄèÊòéÂ∫¶ËÑâÂÜ≤ÔºöÊî∂Áº©Êó∂Êõ¥‰∫Æ
            laserHitEffect.material.opacity = 0.6 + pulse * 0.4;  // 0.6 -> 1.0
        }
        
        // ========== ÂàõÂª∫ËåÉÂõ¥ÊåáÁ§∫Âô® ==========
        function createRangeIndicator(equipmentType) {
            // ÁßªÈô§ÊóßÁöÑÊåáÁ§∫Âô®
            if (rangeIndicator) {
                cart.remove(rangeIndicator);
                if (rangeIndicator.geometry) rangeIndicator.geometry.dispose();
                if (rangeIndicator.material) rangeIndicator.material.dispose();
                rangeIndicator = null;
            }
            
            const config = equipmentConfig[equipmentType];
            if (!config) return;
            
            const material = new THREE.MeshBasicMaterial({
                color: config.color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            let geometry;
            
            switch(config.interactionType) {
                case 'aim':
                    // ÊøÄÂÖâÔºö‰∏çÊòæÁ§∫ËåÉÂõ¥Ôºà‰ΩøÁî®ÂçÅÂ≠óÂáÜÊòüÔºâ
                    return;
                    
                case 'circle':
                    // Êú∫Ê¢∞ËáÇÔºöÂú∞Èù¢ÂúÜÂúà
                    geometry = new THREE.RingGeometry(config.range - 0.1, config.range, 32);
                    rangeIndicator = new THREE.Mesh(geometry, material);
                    rangeIndicator.rotation.x = -Math.PI / 2;
                    rangeIndicator.position.set(config.position.x, 0.01, config.position.z);
                    break;
                    
                case 'scanner_cone':
                    // Êâ´Êèè‰ª™ÔºöÂâçÊñπÊâáÂΩ¢Ôºà108Â∫¶Ôºâ
                    const scannerShape = new THREE.Shape();
                    scannerShape.moveTo(0, 0);
                    const scannerAngle = config.scanAngle || Math.PI * 0.6;  // 108Â∫¶ÊâáÂΩ¢
                    for (let i = 0; i <= 32; i++) {
                        const angle = -scannerAngle/2 + (scannerAngle * i / 32);
                        scannerShape.lineTo(
                            Math.sin(angle) * config.range,
                            Math.cos(angle) * config.range
                        );
                    }
                    scannerShape.lineTo(0, 0);
                    geometry = new THREE.ShapeGeometry(scannerShape);
                    rangeIndicator = new THREE.Mesh(geometry, material);
                    rangeIndicator.rotation.x = -Math.PI / 2;
                    rangeIndicator.position.set(0, 0.01, 0);
                    break;
                    
                case 'cone':
                    // Âñ∑Ê¥íÂô®ÔºöÂâçÊñπÊâáÂΩ¢Ôºà60Â∫¶Ôºâ
                    const coneShape = new THREE.Shape();
                    coneShape.moveTo(0, 0);
                    const angleSpread = Math.PI / 3;  // 60Â∫¶ÊâáÂΩ¢
                    for (let i = 0; i <= 20; i++) {
                        const angle = -angleSpread/2 + (angleSpread * i / 20);
                        coneShape.lineTo(
                            Math.sin(angle) * config.range,
                            Math.cos(angle) * config.range
                        );
                    }
                    coneShape.lineTo(0, 0);
                    geometry = new THREE.ShapeGeometry(coneShape);
                    rangeIndicator = new THREE.Mesh(geometry, material);
                    rangeIndicator.rotation.x = -Math.PI / 2;
                    rangeIndicator.position.set(0, 0.01, 0);
                    break;
                    
                case 'area':
                    // ÊµáÊ∞¥ÔºöÂë®Âõ¥ÂúÜÂΩ¢Âå∫Âüü
                    geometry = new THREE.CircleGeometry(config.range, 32);
                    rangeIndicator = new THREE.Mesh(geometry, material);
                    rangeIndicator.rotation.x = -Math.PI / 2;
                    rangeIndicator.position.set(0, 0.01, 0);
                    break;
                    
                case 'auto':
                    // ÂúüÂ£§Êé¢ÈíàÔºöËÑö‰∏ãÂúÜÂΩ¢
                    geometry = new THREE.CircleGeometry(config.range, 16);
                    rangeIndicator = new THREE.Mesh(geometry, material);
                    rangeIndicator.rotation.x = -Math.PI / 2;
                    rangeIndicator.position.set(0, 0.01, 0);
                    break;
            }
            
            if (rangeIndicator) {
                cart.add(rangeIndicator);
                // ËÑâÂÜ≤Âä®Áîª
                let pulseTime = 0;
                rangeIndicator.userData.pulseAnimation = setInterval(() => {
                    pulseTime += 0.05;
                    material.opacity = 0.2 + Math.sin(pulseTime) * 0.15;
                }, 50);
            }
        }
        
        // ========== ÂàáÊç¢Ë£ÖÂ§á ==========
        function switchEquipment(equipment, sourceEvent = null) {
            gameState.currentEquipment = equipment;
            
            // Ëé∑ÂèñÂçÅÂ≠óÂáÜÊòüÂÖÉÁ¥†
            const crosshair = document.querySelector('.crosshair');
            
            // Â¶ÇÊûúÊòØÊøÄÂÖâË£ÖÂ§áÔºå‰∏çÊòæÁ§∫ÁûÑÂáÜÁ∫ø
            if (equipment === 'laser') {
                // ‰∏çÂàõÂª∫ÁûÑÂáÜÁ∫ø
                // ÊòæÁ§∫Ë∞ÉËØïÈù¢Êùø
                const debugDiv = document.getElementById('laser-debug-info');
                if (debugDiv) {
                    debugDiv.style.display = 'block';
                }
                // ÈöêËóèÂÖ∂‰ªñËåÉÂõ¥ÊåáÁ§∫Âô®
                if (rangeIndicator) {
                    cart.remove(rangeIndicator);
                    rangeIndicator = null;
                }
                // ÈöêËóèÂçÅÂ≠óÂáÜÊòüÔºàÊøÄÂÖâË£ÖÂ§á‰ΩøÁî®Êú∫Ê¢∞ËáÇÁûÑÂáÜÁ∫øÔºâ
                if (crosshair) {
                    crosshair.style.display = 'none';
                }
            } else {
                // ÈöêËóèÊøÄÂÖâÁûÑÂáÜÁ∫ø
                removeLaserAimLine();
                if (laserAimDot) {
                    scene.remove(laserAimDot);
                    laserAimDot = null;
                }
                // Ê∏ÖÁêÜÊøÄÂÖâÂáª‰∏≠ÁâπÊïà
                if (laserHitEffect) {
                    scene.remove(laserHitEffect);
                    if (laserHitEffect.geometry) laserHitEffect.geometry.dispose();
                    if (laserHitEffect.material) laserHitEffect.material.dispose();
                    laserHitEffect = null;
                }
                // ÈöêËóèË∞ÉËØïÈù¢Êùø
                const debugDiv = document.getElementById('laser-debug-info');
                if (debugDiv) {
                    debugDiv.style.display = 'none';
                }
                // ÂàõÂª∫ÂØπÂ∫îÁöÑËåÉÂõ¥ÊåáÁ§∫Âô®
                createRangeIndicator(equipment);
                // ÊòæÁ§∫ÂçÅÂ≠óÂáÜÊòüÔºàÂÖ∂‰ªñË£ÖÂ§áÂèØËÉΩÈúÄË¶ÅÔºâ
                if (crosshair) {
                    crosshair.style.display = 'block';
                }
            }
            
            const equipmentData = {
                'laser': { name: 'ÊøÄÂÖâÈô§ËçâÂô®', icon: 'üî¥', range: '3.0m' },
                'scanner': { name: 'Â§öÂÖâË∞±Êâ´Êèè‰ª™', icon: 'üîµ', range: '4.0m' },
                'arm': { name: 'Êú∫Ê¢∞ËáÇÊî∂Ëé∑', icon: 'ü¶æ', range: '0.9m' },
                'soil': { name: 'ÂúüÂ£§Ê£ÄÊµãÊé¢Èíà', icon: 'üî¨', range: '1.0m' },
                'spray': { name: 'ÂÜúËçØÂñ∑Ê¥íÂô®', icon: 'üí®', range: '2.0m' },
                'water': { name: 'ÊµáÊ∞¥Á≥ªÁªü', icon: 'üíß', range: '2.5m' },
                'planter': { name: 'Êí≠ÁßçÂô®', icon: 'üå±', range: '0.6m' }
            };
            
            const data = equipmentData[equipment];
            if (!data) {
                console.error('Unknown equipment:', equipment);
                return;
            }
            
            // ‰ΩøÁî®Êñ∞ÈÖçÁΩÆ
            const config = equipmentConfig[equipment];
            document.getElementById('equipment-icon').textContent = config.icon;
            document.getElementById('equipment-name').textContent = config.name;
            document.getElementById('equipment-range').textContent = config.range.toFixed(1) + 'm';
            
            // ÊòæÁ§∫‰ΩøÁî®ÊèêÁ§∫
            showMessage(config.tip, 'info');
            
            // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
            document.querySelectorAll('.hotkey').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // È´ò‰∫ÆÂØπÂ∫îÁöÑË£ÖÂ§áÊåâÈíÆ
            const buttons = document.querySelectorAll('.hotkey');
            const equipmentIndex = {'laser': 0, 'scanner': 1, 'soil': 2, 'spray': 3, 'water': 4, 'planter': 5, 'arm': 6};
            if (equipmentIndex[equipment] !== undefined && buttons[equipmentIndex[equipment]]) {
                buttons[equipmentIndex[equipment]].classList.add('active');
            }
            
            // Êí≠ÊîæÂàáÊç¢Èü≥Êïà
            SoundEffects.equipmentSwitch();
            
            // Êõ¥Êñ∞Êú∫Ê¢∞ËáÇÊåáÁ§∫ÁÅØ
            updateArmIndicator(equipment);
            
            // ÈÄöÁü•ÊúçÂä°Âô®
            fetch('/api/equipment/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ equipment: equipment })
            }).catch(err => console.error('Equipment switch error:', err));
        }
        
        // ========== Êõ¥Êñ∞Êú∫Ê¢∞ËáÇÊåáÁ§∫ÁÅØ ==========
        function updateArmIndicator(equipment) {
            // ÊâæÂà∞Êú∫Ê¢∞ËáÇ‰∏äÁöÑÊåáÁ§∫ÁÅØ
            const armGroup = cart.getObjectByName('robotic_arm');
            if (armGroup) {
                const indicator = armGroup.getObjectByName('arm_indicator');
                if (indicator) {
                    // Âè™ÊúâÈÄâ‰∏≠Êú∫Ê¢∞ËáÇÊó∂Êâç‰∫ÆÁÅØ
                    indicator.visible = (equipment === 'arm');
                    
                    if (equipment === 'arm') {
                        // Èó™ÁÉÅÂä®Áîª
                        indicator.material.emissiveIntensity = 1.0;
                        setTimeout(() => {
                            indicator.material.emissiveIntensity = 0.5;
                        }, 200);
                    }
                }
            }
        }
        
        // ========== Èº†Ê†áÁÇπÂáªÔºà‰ΩøÁî®Ë£ÖÂ§áÔºâ ==========
        function onMouseClick(event) {
            // ÊøÄÂÖâË£ÖÂ§á‰∏ç‰ΩøÁî®Èº†Ê†áÁÇπÂáªÔºà‰ΩøÁî®Á©∫Ê†ºÈîÆ‰ªéÊú∫Ê¢∞ËáÇÂèëÂ∞ÑÔºâ
            const config = equipmentConfig[gameState.currentEquipment];
            if (config && config.interactionType === 'arm_aim') {
                return;  // ÊøÄÂÖâË£ÖÂ§á‰∏çÂìçÂ∫îÈº†Ê†áÁÇπÂáª
            }
            
            // Â¶ÇÊûúÈº†Ê†áÂ∑≤ÈîÅÂÆöÔºå‰ΩøÁî®Â±èÂπï‰∏≠ÂøÉÂ∞ÑÁ∫ø
            // Âê¶Âàô‰ΩøÁî®Èº†Ê†á‰ΩçÁΩÆ
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            if (mouseControl.isLocked) {
                // Èº†Ê†áÈîÅÂÆöÊó∂Ôºå‰ªéÂ±èÂπï‰∏≠ÂøÉÂèëÂ∞ÑÂ∞ÑÁ∫ø
                mouse.set(0, 0);
            } else {
                // Èº†Ê†áÊú™ÈîÅÂÆöÊó∂Ôºå‰ªéÈº†Ê†á‰ΩçÁΩÆÂèëÂ∞ÑÂ∞ÑÁ∫ø
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            
            raycaster.setFromCamera(mouse, camera);
            
            // Ê£ÄÊµãÊòØÂê¶ÁÇπÂáªÂà∞Ê§çÁâ©
            const plants = farm.children.filter(child => child.userData && child.userData.id);
            const intersects = raycaster.intersectObjects(plants, true);
            
            if (intersects.length > 0) {
                const plant = intersects[0].object.parent;
                useEquipmentOnPlant(plant);
            }
        }
        
        // ========== ‰ΩøÁî®Ë£ÖÂ§á ==========
        let lastEquipmentUseTime = 0;
        const EQUIPMENT_COOLDOWN = 100; // 100msÂÜ∑Âç¥Êó∂Èó¥
        
        async function useEquipmentOnPlant(plant) {
            // Ê£ÄÊü•ÂÜ∑Âç¥Êó∂Èó¥ÔºàÊõ¥Â•ΩÁöÑÈò≤ÊäñÊñπÂºèÔºâ
            const now = Date.now();
            if (now - lastEquipmentUseTime < EQUIPMENT_COOLDOWN) {
                return;
            }
            lastEquipmentUseTime = now;
            
            if (!plant || !plant.userData) return;
            if (!plant.visible) return; // Â∑≤Ë¢´ÁßªÈô§ÁöÑÊ§çÁâ©
            
            const plantData = plant.userData;
            
            try {
                if (gameState.currentEquipment === 'laser') {
                    // ÊøÄÂÖâÈô§Ëçâ
                    const response = await fetch('/api/action/laser', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Êí≠ÊîæÊøÄÂÖâÊïàÊûú
                        createLaserEffect(cart.position, plant.position);
                        SoundEffects.laser();
                        
                        showMessage(result.message, result.type === 'weed' ? 'success' : 'error');
                        
                        if (result.type === 'weed') {
                            // ÊùÇËçâÁáÉÁÉßÊïàÊûú
                            await burnPlant(plant);
                            SoundEffects.success();
                        } else {
                            // Ëî¨ËèúÂèóÊçüÈó™ÁÉÅ
                            flashPlant(plant);
                            shakeCamera();
                            SoundEffects.error();
                        }
                        
                        // Êõ¥Êñ∞‰ªøÁúüÁä∂ÊÄÅ
                        gameState.score += result.score_change;
                        updateUI();
                    }
                    
                } else if (gameState.currentEquipment === 'scanner') {
                    // Êâ´ÊèèÊ§çÁâ©
                    SoundEffects.scan();
                    createScanEffect(plant.position);
                    
                    const response = await fetch('/api/action/scan', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showPlantInfo(result.plant);
                        updateUI();
                    }
                    
                } else if (gameState.currentEquipment === 'planter') {
                    // Êí≠ÁßçÂô® - Âú®Á©∫Âú∞Êí≠Áßç
                    if (!plantData || !plantData.id) return;
                    
                    // Âè™ËÉΩÂú®Á©∫Âú∞Êí≠Áßç
                    if (!plantData.is_empty) {
                        showMessage('ËØ•‰ΩçÁΩÆÂ∑≤ÊúâÊ§çÁâ©ÊàñÁßçÂ≠êÔºÅ', 'error');
                        return;
                    }
                    
                    const response = await fetch('/api/action/plant', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            row: plantData.row, 
                            col: plantData.col 
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Êõ¥Êñ∞Ê§çÁâ©Êï∞ÊçÆ
                        plantData.is_empty = false;
                        plantData.is_seed = true;
                        plantData.growth_stage = 0;
                        
                        // ÈáçÂª∫3DÊ®°ÂûãÔºà‰ªéÁ©∫Âú∞ÂèòÊàêÁßçÂ≠êÔºâ
                        plant.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        plant.children = [];
                        
                        // ÂàõÂª∫ÁßçÂ≠êÊ®°Âûã
                        const seedModel = createPlantModel({
                            is_seed: true,
                            is_empty: false
                        });
                        seedModel.children.forEach(child => plant.add(child));
                        
                        // Êí≠ÁßçÁâπÊïà
                        createPlantingEffect(plant.position);
                        SoundEffects.success();
                        
                        showMessage(result.message, 'success');
                        
                        // Êõ¥Êñ∞‰ªøÁúüÁä∂ÊÄÅ
                        gameState.coins -= 5;
                        updateUI();
                    } else {
                        showMessage(result.message, 'error');
                    }
                    
                } else if (gameState.currentEquipment === 'soil') {
                    // ÂúüÂ£§Ê£ÄÊµãÊé¢Èíà
                    if (!plantData || !plantData.id) return;
                    
                    SoundEffects.scan();
                    createSoilDetectEffect(plant.position);
                    
                    const response = await fetch('/api/action/soil_detect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showSoilInfo(result);
                        updateUI();
                    } else {
                        showMessage(result.message, 'error');
                    }
                    
                } else if (gameState.currentEquipment === 'spray') {
                    // ÂÜúËçØÂñ∑Ê¥íÂô®
                    if (!plantData || !plantData.id) return;
                    
                    const response = await fetch('/api/action/spray_pesticide', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Âñ∑ÈõæÊïàÊûú
                        createSprayEffect(plant.position);
                        SoundEffects.success();
                        
                        showMessage(result.message, 'success');
                        
                        // Êõ¥Êñ∞‰ªøÁúüÁä∂ÊÄÅ
                        gameState.coins += result.coins_earned;
                        gameState.score += result.coins_earned;
                        updateUI();
                    } else {
                        showMessage(result.message, result.pests_found === false ? 'info' : 'error');
                    }
                    
                } else if (gameState.currentEquipment === 'water') {
                    // ÊµáÊ∞¥Á≥ªÁªü
                    if (!plantData || !plantData.id) return;
                    
                    const response = await fetch('/api/action/water', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // ÊµáÊ∞¥ÊïàÊûú
                        createWaterEffect(plant.position);
                        SoundEffects.success();
                        
                        showMessage(result.message, 'success');
                        
                        // Â¶ÇÊûúÊ§çÁâ©ÊàêÈïøÔºåÊõ¥Êñ∞ËßÜËßâ
                        if (result.stage_changed) {
                            updatePlantGrowth(plant, result.growth_stage);
                        }
                        
                        updateUI();
                    } else {
                        showMessage(result.message, result.is_weed ? 'error' : 'info');
                    }
                }
            } catch (error) {
                console.error('Equipment use error:', error);
                showMessage('Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑ÈáçËØï', 'error');
            }
        }
        
        // ========== ÊøÄÂÖâÊïàÊûú ==========
        function createLaserEffect(startPos, endPos) {
            // ÂàõÂª∫ÊøÄÂÖâÊùü
            const direction = new THREE.Vector3().subVectors(endPos, startPos);
            const distance = direction.length();
            
            const laserGeometry = new THREE.CylinderGeometry(0.01, 0.015, distance, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // ÂÆö‰ΩçÊøÄÂÖâ
            laser.position.copy(startPos).lerp(endPos, 0.5);
            laser.position.y += 0.3; // ‰ªéËΩ¶È°∂ÂèëÂ∞Ñ
            laser.lookAt(endPos);
            laser.rotateX(Math.PI / 2);
            
            scene.add(laser);
            
            // ÊøÄÂÖâÁ≤íÂ≠ê
            createLaserParticles(startPos, endPos);
            
            // 0.3ÁßíÂêéÁßªÈô§ÊøÄÂÖâ
            setTimeout(() => {
                scene.remove(laser);
                laserGeometry.dispose();
                laserMaterial.dispose();
            }, 300);
        }
        
        function createLaserParticles(startPos, endPos) {
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                const t = i / particleCount;
                const pos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
                
                // ÈöèÊú∫ÂÅèÁßª
                pos.x += (Math.random() - 0.5) * 0.02;
                pos.y += (Math.random() - 0.5) * 0.02 + 0.3;
                pos.z += (Math.random() - 0.5) * 0.02;
                
                positions.push(pos.x, pos.y, pos.z);
                colors.push(1.0, Math.random() * 0.5, 0.0);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Á≤íÂ≠êÂä®Áîª
            let opacity = 1.0;
            const interval = setInterval(() => {
                opacity -= 0.1;
                material.opacity = opacity;
                
                if (opacity <= 0) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 50);
        }
        
        // ========== Ê§çÁâ©ÁáÉÁÉßÊïàÊûú ==========
        async function burnPlant(plant) {
            // ÂàõÂª∫ÁáÉÁÉßÁ≤íÂ≠ê
            createBurnParticles(plant.position);
            
            // Ê§çÁâ©Áº©Â∞èÂπ∂Ê∂àÂ§±
            const startScale = plant.scale.clone();
            const duration = 1000;
            const startTime = Date.now();
            
            return new Promise(resolve => {
                const burnInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Áº©Â∞è
                    plant.scale.lerpVectors(startScale, new THREE.Vector3(0, 0, 0), progress);
                    
                    // ÊóãËΩ¨
                    plant.rotation.x += 0.05;
                    plant.rotation.z += 0.03;
                    
                    if (progress >= 1) {
                        clearInterval(burnInterval);
                        
                        // Ê∏ÖÁêÜÊóßÊ®°Âûã
                        plant.children.forEach(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        plant.children = [];
                        
                        // ÈáçÁΩÆ‰∏∫Á©∫Âú∞
                        plant.userData.is_empty = true;
                        plant.userData.is_weed = false;
                        plant.userData.is_vegetable = false;
                        plant.userData.is_seed = false;
                        plant.scale.set(1, 1, 1);
                        plant.rotation.set(0, 0, 0);
                        
                        resolve();
                    }
                }, 16);
            });
        }
        
        function createBurnParticles(position) {
            const particleCount = 40;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * 0.05,
                    position.y + Math.random() * 0.05,
                    position.z + (Math.random() - 0.5) * 0.05
                );
                
                velocities.push(
                    (Math.random() - 0.5) * 0.02,
                    Math.random() * 0.05 + 0.02,
                    (Math.random() - 0.5) * 0.02
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.03,
                color: 0xff6600,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Á≤íÂ≠êÂä®Áîª
            let lifetime = 0;
            const maxLifetime = 60;
            const interval = setInterval(() => {
                lifetime++;
                
                const pos = geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                    
                    velocities[i * 3 + 1] -= 0.001; // ÈáçÂäõ
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 1 - lifetime / maxLifetime;
                
                if (lifetime >= maxLifetime) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 16);
        }
        
        // ========== Êâ´ÊèèÊïàÊûú ==========
        function createScanEffect(position) {
            // ÂàõÂª∫Êâ´ÊèèÂúÜÁéØ
            const ringGeometry = new THREE.RingGeometry(0.05, 0.08, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.position.y = 0.01;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Êâ´ÊèèÂä®Áîª
            let scale = 1;
            const interval = setInterval(() => {
                scale += 0.1;
                ring.scale.set(scale, scale, 1);
                ringMaterial.opacity = 0.8 / scale;
                
                if (scale >= 5) {
                    clearInterval(interval);
                    scene.remove(ring);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            }, 50);
            
            // Êâ´ÊèèÂÖâÊùü
            const beamGeometry = new THREE.CylinderGeometry(0.02, 0.08, 0.5, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.copy(position);
            beam.position.y = 0.25;
            scene.add(beam);
            
            setTimeout(() => {
                scene.remove(beam);
                beamGeometry.dispose();
                beamMaterial.dispose();
            }, 500);
        }
        
        // ========== Áõ∏Êú∫ÈúáÂä®ÊïàÊûú ==========
        let cameraShakeOffset = new THREE.Vector3();
        let cameraShakeActive = false;
        
        function shakeCamera() {
            if (cameraShakeActive) return; // Èò≤Ê≠¢ÈáçÂ§çÈúáÂä®
            
            cameraShakeActive = true;
            let shakeCount = 0;
            const shakeDuration = 6;
            
            const shakeInterval = setInterval(() => {
                // ‰ΩøÁî®ÂÅèÁßªËÄå‰∏çÊòØÁõ¥Êé•‰øÆÊîπ‰ΩçÁΩÆÔºàÈÅøÂÖç‰∏éFPSÊõ¥Êñ∞ÂÜ≤Á™ÅÔºâ
                cameraShakeOffset.set(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                );
                
                shakeCount++;
                if (shakeCount >= shakeDuration) {
                    clearInterval(shakeInterval);
                    cameraShakeOffset.set(0, 0, 0);
                    cameraShakeActive = false;
                }
            }, 30);
        }
        
        // ========== Ê§çÁâ©Èó™ÁÉÅÊïàÊûú ==========
        function flashPlant(plant) {
            let count = 0;
            const interval = setInterval(() => {
                plant.visible = !plant.visible;
                count++;
                if (count >= 6) {
                    clearInterval(interval);
                    plant.visible = true;
                }
            }, 100);
        }
        
        // ========== Êî∂Ëé∑ÊïàÊûú ==========
        // ÂàõÂª∫È£òÊµÆÈáëÂ∏ÅÊï∞Â≠óÁâπÊïà
        function createFloatingCoinText(position, coinsEarned, fruitCount) {
            // ÂàõÂª∫ÁîªÂ∏É
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // ÁªòÂà∂ËÉåÊôØÔºàÂçäÈÄèÊòéÈáëËâ≤ÂÖâÊôïÔºâ
            const gradient = context.createRadialGradient(128, 64, 10, 128, 64, 90);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 128);
            
            // ÁªòÂà∂ÊûúÂÆûÊï∞Èáè
            context.font = 'bold 32px Arial';
            context.fillStyle = '#FF6B6B';
            context.textAlign = 'center';
            context.fillText(`üçé x${fruitCount}`, 128, 45);
            
            // ÁªòÂà∂ÈáëÂ∏ÅÊï∞Èáè
            context.font = 'bold 40px Arial';
            context.fillStyle = '#FFD700';
            context.strokeStyle = '#8B4513';
            context.lineWidth = 4;
            context.strokeText(`+${coinsEarned}`, 128, 90);
            context.fillText(`+${coinsEarned}`, 128, 90);
            
            // Ê∑ªÂä†ÈáëÂ∏Åemoji
            context.font = 'bold 30px Arial';
            context.fillText('üí∞', 190, 90);
            
            // ÂàõÂª∫Á∫πÁêÜÂíåSprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.position.y += 0.5;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // È£òÊµÆÂä®Áîª
            const duration = 2000;
            const startTime = Date.now();
            const startY = sprite.position.y;
            
            const floatInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    clearInterval(floatInterval);
                    scene.remove(sprite);
                    if (sprite.material.map) sprite.material.map.dispose();
                    if (sprite.material) sprite.material.dispose();
                    return;
                }
                
                // Âêë‰∏äÈ£òÊµÆ
                sprite.position.y = startY + progress * 1.5;
                
                // Ê∏êÊ∏êÊ∂àÂ§±
                sprite.material.opacity = 1 - progress;
                
                // ËΩªÂæÆÊîæÂ§ß
                const scale = 2 + progress * 0.5;
                sprite.scale.set(scale, scale * 0.5, 1);
            }, 16);
        }
        
        function createHarvestEffect(position) {
            // ÂàõÂª∫ÈáëËâ≤ÊòüÊòüÁ≤íÂ≠ê
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * 0.1,
                    position.y + Math.random() * 0.1,
                    position.z + (Math.random() - 0.5) * 0.1
                );
                
                velocities.push(
                    (Math.random() - 0.5) * 0.03,
                    Math.random() * 0.08 + 0.05,  // Âêë‰∏äÈ£û
                    (Math.random() - 0.5) * 0.03
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                color: 0xFFD700,  // ÈáëËâ≤
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Á≤íÂ≠êÂä®Áîª
            let lifetime = 0;
            const maxLifetime = 60;
            const interval = setInterval(() => {
                lifetime++;
                
                const pos = geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 1 - lifetime / maxLifetime;
                
                if (lifetime >= maxLifetime) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 16);
        }
        
        async function harvestPlant(plant) {
            // ü¶æ ÈúáÊíºÁöÑÊú∫Ê¢∞ËáÇÊî∂Ëé∑Âä®Áîª
            
            console.log('ü¶æ ÂºÄÂßãÊî∂Ëé∑Ê§çÁâ©...');
            console.log('  Ê§çÁâ©ID:', plant.userData.id);
            console.log('  Ê§çÁâ©‰ΩçÁΩÆ:', plant.position);
            console.log('  ÁîüÈïøÈò∂ÊÆµ:', plant.userData.growth_stage);
            
            // Êõ¥Êñ∞‰∏ñÁïåÁü©Èòµ‰ª•Á°Æ‰øù‰ΩçÁΩÆÂáÜÁ°Æ
            cart.updateMatrixWorld(true);
            scene.updateMatrixWorld(true);
            
            // 1. Êú∫Ê¢∞ËáÇÁßªÂä®Âà∞Ê§çÁâ©Âπ∂Â§πÁ¥ßÔºàÂåÖÂê´ÊâÄÊúâÊ≠•È™§Ôºâ
            await animateArmToTarget(plant.position);
            console.log('  ‚úÖ Êú∫Ê¢∞ËáÇÂà∞‰ΩçÂπ∂Â§πÁ¥ß');
            
            // 2. Ê§çÁâ©ËΩªÂæÆÈúáÂä®ÔºàË¢´Â§π‰ΩèÔºâ
            const startScale = plant.scale.clone();
            const startPos = plant.position.clone();
            
            // Ê∑ªÂä†Êî∂Ëé∑Á≤íÂ≠êÁâπÊïàÔºàÈáëËâ≤Èó™ÂÖâÔºâ
            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 6, 6),
                    new THREE.MeshBasicMaterial({
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                const angle = (i / 20) * Math.PI * 2;
                particle.position.copy(plant.position);
                particle.position.x += Math.cos(angle) * 0.1;
                particle.position.z += Math.sin(angle) * 0.1;
                particle.position.y += 0.1;
                scene.add(particle);
                
                const particleDuration = 600 + Math.random() * 400;
                const particleStartTime = Date.now();
                
                const animateParticle = () => {
                    const elapsed = Date.now() - particleStartTime;
                    const progress = elapsed / particleDuration;
                    
                    if (progress < 1) {
                        particle.position.y += 0.01;
                        particle.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                };
                animateParticle();
            }
            
            // 3. Êú∫Ê¢∞ËáÇÂêë‰∏äÊãîËµ∑ÔºåÊ§çÁâ©Ë∑üÈöèÔºàÂèÇËÄÉÊóßÁâàÊú¨Ôºâ
            const arm = cart.getObjectByName('robotic_arm');
            const axis2 = arm.getObjectByName('axis2_shoulder');
            const pullStartShoulder = axis2.rotation.z;
            const pullSteps = 20;
            
            // ËÆ°ÁÆóÊ§çÁâ©Áõ∏ÂØπÊäìÊâãÁöÑÂÅèÁßª
            const tipPos = getGripperTipWorldPosition();
            const plantOffset = {
                x: startPos.x - tipPos.x,
                y: startPos.y - tipPos.y,
                z: startPos.z - tipPos.z
            };
            
            // Êú∫Ê¢∞ËáÇÂêë‰∏äÊä¨Ëµ∑ÔºåÊ§çÁâ©Ë∑üÈöè
            for (let i = 0; i < pullSteps; i++) {
                const progress = i / pullSteps;
                const smooth = easeInOutCubic(progress);
                
                // ËÇ©ÂÖ≥ËäÇÈÄêÊ∏ê‰∏äÂçáÔºàÊä¨È´ò45Â∫¶Ôºâ
                axis2.rotation.z = pullStartShoulder + smooth * Math.PI / 4;
                
                // Ê§çÁâ©Ë∑üÈöèÊäìÊâãÊú´Á´ØÁßªÂä®
                const currentTipPos = getGripperTipWorldPosition();
                plant.position.x = currentTipPos.x + plantOffset.x;
                plant.position.y = currentTipPos.y + plantOffset.y;
                plant.position.z = currentTipPos.z + plantOffset.z;
                
                // Ê§çÁâ©Âú®ÊãîËµ∑Êó∂ËΩªÂæÆÊëáÊôÉÂíåÊóãËΩ¨
                plant.rotation.z = Math.sin(progress * Math.PI * 6) * 0.1;
                plant.rotation.x = Math.sin(progress * Math.PI * 4) * 0.08;
                plant.rotation.y += 0.08;
                
                // Ê§çÁâ©ÈÄêÊ∏êÁº©Â∞è
                const scaleProgress = Math.pow(progress, 0.5);
                plant.scale.x = startScale.x * (1 - scaleProgress * 0.8);
                plant.scale.y = startScale.y * (1 - scaleProgress * 0.5);
                plant.scale.z = startScale.z * (1 - scaleProgress * 0.8);
                
                await sleep(30);
            }
            
            console.log('  ‚úÖ Ê§çÁâ©Â∑≤ÊãîËµ∑');
            await sleep(300);
            
            // Ê∏ÖÁêÜÊóßÊ®°Âûã
            plant.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            plant.children = [];
            
            // ÈáçÁΩÆ‰∏∫Á©∫Âú∞
            plant.userData.is_empty = true;
            plant.userData.is_weed = false;
            plant.userData.is_vegetable = false;
            plant.userData.is_seed = false;
            plant.userData.is_removed = false;
            plant.scale.set(1, 1, 1);
            plant.rotation.set(0, 0, 0);
            plant.position.copy(startPos);
            
            // 4. ÊäìÊâãÊâìÂºÄ
            if (gripperLeft && gripperRight) {
                const openStartTime = Date.now();
                const openDuration = 200;
                
                await new Promise(resolve => {
                    const openInterval = setInterval(() => {
                        const elapsed = Date.now() - openStartTime;
                        const progress = Math.min(elapsed / openDuration, 1);
                        
                        // ÊäìÊâãÈÄêÊ∏êÂº†ÂºÄ
                        gripperLeft.position.x = -0.01 - progress * 0.015;
                        gripperRight.position.x = 0.01 + progress * 0.015;
                        
                        if (progress >= 1) {
                            clearInterval(openInterval);
                            resolve();
                        }
                    }, 16);
                });
            }
            
            // 5. Êú∫Ê¢∞ËáÇÂõûÂà∞ÂàùÂßã‰ΩçÁΩÆ
            await resetArmPose();
        }
        
        // ========== ËæÖÂä©ÂáΩÊï∞ÔºöÂª∂Êó∂ ==========
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // ========== Ëé∑ÂèñÊäìÊâãÊú´Á´Ø‰∏ñÁïåÂùêÊ†á ==========
        function getGripperTipWorldPosition() {
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return new THREE.Vector3(0, 0, 0);
            
            const axis2 = armBase.getObjectByName('axis2_shoulder');
            const axis3 = axis2.getObjectByName('axis3_elbow');
            const axis4 = axis3.getObjectByName('axis4_wrist');
            const gripper = axis4.getObjectByName('gripper');
            const tipMarker = gripper.getObjectByName('tip_marker');
            
            if (!tipMarker) return new THREE.Vector3(0, 0, 0);
            
            const worldPos = new THREE.Vector3();
            tipMarker.getWorldPosition(worldPos);
            return worldPos;
        }
        
        // ========== ÈÄÜËøêÂä®Â≠¶ËÆ°ÁÆóÔºàÂèÇËÄÉÊóßÁâàÊú¨Á≤æÁ°ÆËÆ°ÁÆóÔºâ ==========
        function calculateArmAngles(targetDist, targetHeight) {
            // Êú∫Ê¢∞ËáÇÂèÇÊï∞Ôºà‰∏éÂàõÂª∫Êó∂‰∏ÄËá¥Ôºâ
            const L1 = 0.3;    // Âú∞Èù¢Âà∞ËÇ©ÂÖ≥ËäÇÈ´òÂ∫¶ (axis1.y=0.2 + axis2.y=0.1)
            const L2 = 0.18;   // Â§ßËáÇÈïøÂ∫¶ÔºàËÇ©Âà∞ËÇòÔºâ
            const L3 = 0.15;   // Â∞èËáÇÈïøÂ∫¶ÔºàËÇòÂà∞ËÖïÔºâ
            const L4 = 0.08;   // ÊäìÊâãÂª∂‰º∏ÈïøÂ∫¶ÔºàÊ∞¥Âπ≥ÔºåtipMarker.zÔºâ
            const L5 = 0.085;  // ÊäìÊâãÂª∂‰º∏ÈïøÂ∫¶ÔºàÂûÇÁõ¥Ôºågripper.y=0.05 + gripper_y=0.035Ôºâ
            
            // ËÆ°ÁÆóËÖïÂÖ≥ËäÇÈúÄË¶ÅÂà∞ËææÁöÑ‰ΩçÁΩÆ
            const heightFromShoulder = targetHeight + L5 - L1;
            const wristDist = targetDist - L4;
            const d = Math.sqrt(wristDist * wristDist + heightFromShoulder * heightFromShoulder);
            
            // Ê£ÄÊü•ÊòØÂê¶ÂèØËææ
            if (d > L2 + L3 || d < Math.abs(L2 - L3)) {
                console.warn(`‚ö†Ô∏è ÁõÆÊ†á‰∏çÂèØËææ! d=${d.toFixed(3)}, L2+L3=${(L2+L3).toFixed(3)}`);
                // ËøîÂõûÂ∞ΩÂèØËÉΩÊé•ËøëÁöÑÂßøÊÄÅ
                return {
                    shoulder: Math.PI / 4,
                    elbow: -Math.PI / 3,
                    wrist: -Math.PI / 6
                };
            }
            
            // ‰ΩôÂº¶ÂÆöÁêÜËÆ°ÁÆóËÇòÂÖ≥ËäÇËßíÂ∫¶
            const cosElbow = (L2 * L2 + L3 * L3 - d * d) / (2 * L2 * L3);
            const elbow = -Math.acos(Math.max(-1, Math.min(1, cosElbow)));
            
            // ËÆ°ÁÆóËÇ©ÂÖ≥ËäÇËßíÂ∫¶
            const alpha = Math.atan2(heightFromShoulder, wristDist);
            const cosBeta = (L2 * L2 + d * d - L3 * L3) / (2 * L2 * d);
            const beta = Math.acos(Math.max(-1, Math.min(1, cosBeta)));
            const shoulder = alpha + beta;
            
            // ËÖïÂÖ≥ËäÇËßíÂ∫¶Ôºà‰øùÊåÅÊú´Á´ØÊ∞¥Âπ≥Ôºâ
            const wrist = -(shoulder + (Math.PI + elbow));
            
            return { shoulder, elbow, wrist };
        }
        
        // ========== Êú∫Ê¢∞ËáÇÂÖ≥ËäÇÂä®ÁîªËæÖÂä©ÂáΩÊï∞ ==========
        function animateJoints(axis1, axis2, axis3, axis4, startY, startS, startE, startW, endY, endS, endE, endW, duration) {
            return new Promise(resolve => {
                const startTime = Date.now();
                const animInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeInOutCubic(progress);
                    
                    axis1.rotation.y = THREE.MathUtils.lerp(startY, endY, eased);
                    axis2.rotation.z = THREE.MathUtils.lerp(startS, endS, eased);
                    axis3.rotation.z = THREE.MathUtils.lerp(startE, endE, eased);
                    axis4.rotation.z = THREE.MathUtils.lerp(startW, endW, eased);
                    
                    if (progress >= 1) {
                        clearInterval(animInterval);
                        resolve();
                    }
                }, 16);
            });
        }
        
        // ========== Êú∫Ê¢∞ËáÇÂä®ÁîªÂà∞ÁõÆÊ†á‰ΩçÁΩÆÔºàÂèÇËÄÉÊóßÁâàÊú¨Á≤æÁ°ÆÊñπÊ≥ïÔºâ ==========
        async function animateArmToTarget(targetPos) {
            console.log('üé¨ ÂºÄÂßãÊú∫Ê¢∞ËáÇÂä®ÁîªÔºåÁõÆÊ†á‰ΩçÁΩÆ:', targetPos);
            
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) {
                console.error('‚ùå Êâæ‰∏çÂà∞Êú∫Ê¢∞ËáÇÂü∫Â∫ßÔºÅ');
                return;
            }
            
            const axis1 = armBase;  // Âü∫Â∫ßÊóãËΩ¨
            const axis2 = axis1.getObjectByName('axis2_shoulder');
            if (!axis2) {
                console.error('‚ùå Êâæ‰∏çÂà∞ axis2_shoulderÔºÅ');
                return;
            }
            
            const axis3 = axis2.getObjectByName('axis3_elbow');
            if (!axis3) {
                console.error('‚ùå Êâæ‰∏çÂà∞ axis3_elbowÔºÅ');
                return;
            }
            
            const axis4 = axis3.getObjectByName('axis4_wrist');
            if (!axis4) {
                console.error('‚ùå Êâæ‰∏çÂà∞ axis4_wristÔºÅ');
                return;
            }
            
            const gripper = axis4.getObjectByName('gripper');
            if (!gripper) {
                console.error('‚ùå Êâæ‰∏çÂà∞ gripperÔºÅ');
                return;
            }
            
            // Êõ¥Êñ∞‰∏ñÁïåÁü©Èòµ
            cart.updateMatrixWorld(true);
            
            // ËÆ°ÁÆóÊ§çÁâ©Áõ∏ÂØπÂ∞èËΩ¶ÁöÑ‰ΩçÁΩÆ
            const cartPos = cart.position;
            const cartRotY = cart.rotation.y;
            
            // ‰∏ñÁïåÂùêÊ†áÁ≥ª‰∏≠Ê§çÁâ©Áõ∏ÂØπÂ∞èËΩ¶ÁöÑ‰ΩçÁΩÆ
            const worldRelativeX = targetPos.x - cartPos.x;
            const worldRelativeZ = targetPos.z - cartPos.z;
            
            console.log(`  Â∞èËΩ¶‰ΩçÁΩÆ: (${cartPos.x.toFixed(3)}, ${cartPos.z.toFixed(3)}), ÊúùÂêë: ${(cartRotY * 180 / Math.PI).toFixed(1)}¬∞`);
            console.log(`  Ê§çÁâ©‰∏ñÁïå‰ΩçÁΩÆ: (${targetPos.x.toFixed(3)}, ${targetPos.z.toFixed(3)})`);
            console.log(`  ‰∏ñÁïåÂùêÊ†áÁ≥ªÁõ∏ÂØπ‰ΩçÁΩÆ: X=${worldRelativeX.toFixed(3)}, Z=${worldRelativeZ.toFixed(3)}`);
            
            // üîÑ ËΩ¨Êç¢Âà∞Â∞èËΩ¶ÁöÑÂ±ÄÈÉ®ÂùêÊ†áÁ≥ªÔºàÂÖ≥ÈîÆ‰øÆÂ§çÔºÅÔºâ
            // Âõ†‰∏∫Êú∫Ê¢∞ËáÇÊòØÂ∞èËΩ¶ÁöÑÂ≠êÂØπË±°ÔºåÊóãËΩ¨ÊòØÁõ∏ÂØπ‰∫éÂ∞èËΩ¶ÁöÑÂ±ÄÈÉ®ÂùêÊ†áÁ≥ª
            const cos = Math.cos(-cartRotY);
            const sin = Math.sin(-cartRotY);
            const localX = worldRelativeX * cos - worldRelativeZ * sin;
            const localZ = worldRelativeX * sin + worldRelativeZ * cos;
            
            console.log(`  Â∞èËΩ¶Â±ÄÈÉ®ÂùêÊ†áÁ≥ªÁõ∏ÂØπ‰ΩçÁΩÆ: X=${localX.toFixed(3)}, Z=${localZ.toFixed(3)}`);
            
            // üéØ ËÆ°ÁÆóÊ§çÁâ©È°∂ÈÉ®ÁöÑÂÆûÈôÖ‰∏ñÁïåÈ´òÂ∫¶
            const plantGrowthStage = 3;  // Âè™ÊúâÊàêÁÜüÊ§çÁâ©ÊâçËÉΩÊî∂Ëé∑
            const plantStemHeight = 0.08 * plantGrowthStage;  // 0.24
            const plantTopRadius = 0.015 * plantGrowthStage;  // 0.045
            const plantHeight = 0.01 + plantStemHeight + plantTopRadius;  // Á∫¶0.295
            
            // Âü∫Â∫ßÊóãËΩ¨ËßíÂ∫¶ÔºàÂú®Â∞èËΩ¶Â±ÄÈÉ®ÂùêÊ†áÁ≥ª‰∏≠Ôºâ
            // Â∞èËΩ¶Â±ÄÈÉ®ÂùêÊ†áÁ≥ªÔºöÂâçÊñπÊòØ-ZÔºåÂ∑¶ËæπÊòØ+X
            // üîß ‰øÆÊ≠£ÔºöÂèçËΩ¨XÊñπÂêë + ÈÄÜÊó∂ÈíàÊóãËΩ¨90Â∫¶
            const targetYaw = Math.atan2(-localX, -localZ) + Math.PI / 2;
            
            // Ê∞¥Âπ≥Ë∑ùÁ¶ªÔºà‰ΩøÁî®Â±ÄÈÉ®ÂùêÊ†áÔºâ
            const horizontalDist = Math.sqrt(localX * localX + localZ * localZ);
            
            // Âà§Êñ≠ÊñπÂêëÔºà‰ΩøÁî®Â±ÄÈÉ®ÂùêÊ†áÁ≥ªÔºâ
            let direction = '';
            if (Math.abs(localX) > Math.abs(localZ)) {
                direction = localX > 0 ? 'Â∑¶Ëæπ' : 'Âè≥Ëæπ';
            } else {
                direction = localZ > 0 ? 'ÂêéÊñπ' : 'ÂâçÊñπ';
            }
            
            console.log(`  Ê§çÁâ©Âú®Â∞èËΩ¶${direction}, Ê∞¥Âπ≥Ë∑ùÁ¶ª=${horizontalDist.toFixed(3)}m`);
            console.log(`  ÂΩìÂâçÊú∫Ê¢∞ËáÇÂü∫Â∫ßËßíÂ∫¶: ${(axis1.rotation.y * 180 / Math.PI).toFixed(1)}¬∞`);
            console.log(`  ËÆ°ÁÆóÁõÆÊ†áÂü∫Â∫ßËßíÂ∫¶: ${(targetYaw * 180 / Math.PI).toFixed(1)}¬∞ (Áõ∏ÂØπÂ∞èËΩ¶Â±ÄÈÉ®ÂùêÊ†áÁ≥ª)`);
            
            // üéØ ‰ΩøÁî®Âõ∫ÂÆöÁöÑÊäìÂèñÂßøÊÄÅÔºà‰ºòÂåñÔºö‰º∏Â±ïÂæóÊõ¥ËøúÔºâ
            const harvestPoseAngles = {
                shoulder: -70 * Math.PI / 180,  // -70¬∞ÔºàÊõ¥Âêë‰∏ãÔºå‰º∏Â±ïÊõ¥ËøúÔºâ
                elbow: -40 * Math.PI / 180,     // -40¬∞ÔºàÊõ¥ÂºØÊõ≤Ôºâ
                wrist: -25 * Math.PI / 180      // -25¬∞ÔºàË∞ÉÊï¥‰øùÊåÅÂπ≥Ë°°Ôºâ
            };
            
            // ÊÇ¨ÂÅúÂßøÊÄÅÔºöËÇ©ÂÖ≥ËäÇÁ®çÈ´ò‰∏Ä‰∫õ
            const hoverAngles = {
                shoulder: -40 * Math.PI / 180,  // -40¬∞Ôºà‰∏≠Èó¥‰ΩçÁΩÆÔºâ
                elbow: -50 * Math.PI / 180,     // -50¬∞
                wrist: -30 * Math.PI / 180      // -30¬∞
            };
            
            console.log(`  ‰ΩøÁî®Âõ∫ÂÆöÊäìÂèñÂßøÊÄÅ: shoulder=-65¬∞, elbow=-55¬∞, wrist=-30¬∞Ôºà‰ºòÂåñÔºö‰º∏Â±ïÊõ¥ËøúÔºâ`);
            
            // ‰øùÂ≠òÂàùÂßãÂßøÊÄÅ
            const startRotY = axis1.rotation.y;
            const startAxis2Z = axis2.rotation.z;
            const startAxis3Z = axis3.rotation.z;
            const startAxis4Z = axis4.rotation.z;
            
            // üåü Êî∂Ëµ∑ÂßøÊÄÅÔºàÊú∫Ê¢∞ËáÇÂûÇÁõ¥Âêë‰∏äÔºåÈÅøÂÖçÁ¢∞ÊíûÔºâ
            const retractAngles = {
                shoulder: 0,  // 0¬∞ÔºàÂûÇÁõ¥Âêë‰∏äÔºâ
                elbow: 0,
                wrist: 0
            };
            
            // 1Ô∏è‚É£ ÂÖàÊî∂Ëµ∑Êú∫Ê¢∞ËáÇÂà∞ÂÆâÂÖ®‰ΩçÁΩÆÔºà‰øùÊåÅÂΩìÂâçÊúùÂêëÔºâ
            await animateJoints(axis1, axis2, axis3, axis4,
                startRotY, startAxis2Z, startAxis3Z, startAxis4Z,
                startRotY, retractAngles.shoulder, retractAngles.elbow, retractAngles.wrist,
                400
            );
            console.log(`  ‚úÖ Êú∫Ê¢∞ËáÇÂ∑≤Êî∂Ëµ∑`);
            
            await sleep(150);
            
            // 2Ô∏è‚É£ ÊóãËΩ¨Âü∫Â∫ßÊúùÂêëÊ§çÁâ©Ôºà‰øùÊåÅÊî∂Ëµ∑Áä∂ÊÄÅÔºâ
            await animateJoints(axis1, axis2, axis3, axis4,
                startRotY, retractAngles.shoulder, retractAngles.elbow, retractAngles.wrist,
                targetYaw, retractAngles.shoulder, retractAngles.elbow, retractAngles.wrist,
                500
            );
            console.log(`  ‚úÖ Âü∫Â∫ßÂ∑≤ÊóãËΩ¨ÊúùÂêëÊ§çÁâ© (${(targetYaw * 180 / Math.PI).toFixed(1)}¬∞)`);
            
            await sleep(200);
            
            // 3Ô∏è‚É£ Âπ≥Êªë‰∏ãÈôçÂà∞ÊÇ¨ÂÅú‰ΩçÁΩÆ
            await animateJoints(axis1, axis2, axis3, axis4,
                targetYaw, retractAngles.shoulder, retractAngles.elbow, retractAngles.wrist,
                targetYaw, hoverAngles.shoulder, hoverAngles.elbow, hoverAngles.wrist,
                600
            );
            console.log(`  ‚úÖ ‰∏ãÈôçÂà∞ÊÇ¨ÂÅú‰ΩçÁΩÆ (shoulder=-40¬∞, elbow=-50¬∞, wrist=-30¬∞)`);
            
            await sleep(250);
            
            // 4Ô∏è‚É£ Á≤æÁ°Æ‰∏ãÈôçÂà∞ÊäìÂèñ‰ΩçÁΩÆ
            await animateJoints(axis1, axis2, axis3, axis4,
                targetYaw, hoverAngles.shoulder, hoverAngles.elbow, hoverAngles.wrist,
                targetYaw, harvestPoseAngles.shoulder, harvestPoseAngles.elbow, harvestPoseAngles.wrist,
                500
            );
            console.log(`  ‚úÖ Âà∞ËææÊäìÂèñ‰ΩçÁΩÆ (shoulder=-70¬∞, elbow=-40¬∞, wrist=-25¬∞)`);
            
            await sleep(200);
            
            // È™åËØÅ‰ΩçÁΩÆ
            const tipPos = getGripperTipWorldPosition();
            console.log(`  Êú´Á´Ø: (${tipPos.x.toFixed(3)}, ${tipPos.y.toFixed(3)}, ${tipPos.z.toFixed(3)})`);
            console.log(`  Ê§çÁâ©: (${targetPos.x.toFixed(3)}, ${targetPos.y.toFixed(3)}, ${targetPos.z.toFixed(3)})`);
            console.log(`  ËØØÂ∑Æ: X=${Math.abs(tipPos.x - targetPos.x).toFixed(3)}, Y=${Math.abs(tipPos.y - targetPos.y).toFixed(3)}, Z=${Math.abs(tipPos.z - targetPos.z).toFixed(3)}`);
            
            // 4Ô∏è‚É£ ÊäìÊâãÈó≠ÂêàÔºàÂ§π‰ΩèÊ§çÁâ©Ôºâ
            const leftGrip = gripper.getObjectByName('left_gripper');
            const rightGrip = gripper.getObjectByName('right_gripper');
            if (leftGrip && rightGrip) {
                await new Promise(resolve => {
                    const startTime = Date.now();
                    const duration = 400;
                    const startLeft = leftGrip.position.x;
                    const startRight = rightGrip.position.x;
                    
                    const animInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const eased = easeInOutCubic(progress);
                        
                        leftGrip.position.x = THREE.MathUtils.lerp(startLeft, -0.01, eased);
                        rightGrip.position.x = THREE.MathUtils.lerp(startRight, 0.01, eased);
                        
                        if (progress >= 1) {
                            clearInterval(animInterval);
                            resolve();
                        }
                    }, 16);
                });
            }
            
            await sleep(300);
            console.log('  ‚úÖ ÊäìÊâãÂ§πÁ¥ßÔºÅ');
        }
        
        // ========== ÈáçÁΩÆÊú∫Ê¢∞ËáÇÂßøÊÄÅ ==========
        async function resetArmPose() {
            const armBase = cart.getObjectByName('robotic_arm');
            if (!armBase) return;
            
            const axis1 = armBase;
            const axis2 = axis1.getObjectByName('axis2_shoulder');
            const axis3 = axis2.getObjectByName('axis3_elbow');
            const axis4 = axis3.getObjectByName('axis4_wrist');
            const gripper = axis4.getObjectByName('gripper');
            
            const startRotY = axis1.rotation.y;
            const startAxis2Z = axis2.rotation.z;
            const startAxis3Z = axis3.rotation.z;
            const startAxis4Z = axis4.rotation.z;
            
            const duration = 500;
            const startTime = Date.now();
            
            return new Promise(resolve => {
                const resetInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = easeInOutCubic(progress);
                    
                    // ÂõûÂà∞ÂàùÂßãÂßøÊÄÅ
                    axis1.rotation.y = THREE.MathUtils.lerp(startRotY, 0, eased);
                    axis2.rotation.z = THREE.MathUtils.lerp(startAxis2Z, Math.PI / 6, eased);
                    axis3.rotation.z = THREE.MathUtils.lerp(startAxis3Z, -Math.PI / 4, eased);
                    axis4.rotation.z = THREE.MathUtils.lerp(startAxis4Z, Math.PI / 6, eased);
                    
                    // Â§πÁà™ÊâìÂºÄ
                    if (gripper) {
                        const leftGrip = gripper.getObjectByName('left_gripper');
                        const rightGrip = gripper.getObjectByName('right_gripper');
                        if (leftGrip && rightGrip) {
                            leftGrip.position.x = THREE.MathUtils.lerp(leftGrip.position.x, -0.02, eased);
                            rightGrip.position.x = THREE.MathUtils.lerp(rightGrip.position.x, 0.02, eased);
                        }
                    }
                    
                    if (progress >= 1) {
                        clearInterval(resetInterval);
                        resolve();
                    }
                }, 16);
            });
        }
        
        // ========== ÁºìÂä®ÂáΩÊï∞ ==========
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // ========== ÊòæÁ§∫Ê§çÁâ©‰ø°ÊÅØ ==========
        function showPlantInfo(plant) {
            const info = `
                ${plant.is_weed ? 'üåø ÊùÇËçâ' : 'ü•¨ Ëî¨Ëèú'}: ${plant.type}
                ÂÅ•Â∫∑Â∫¶: ${plant.health}%
                ÂúüÂ£§PH: ${plant.soil_ph}
                ÊπøÂ∫¶: ${plant.soil_moisture}%
                ${plant.has_pests ? '‚ö†Ô∏è ÊúâÂÆ≥Ëô´!' : ''}
            `.trim();
            
            showMessage(info, 'info');
        }
        
        // ========== ÊòæÁ§∫Ê∂àÊÅØ ==========
        function showMessage(text, type = 'info') {
            const log = document.getElementById('message-log');
            
            // ÈôêÂà∂ÊúÄÂ§öÊòæÁ§∫3Êù°Ê∂àÊÅØ
            while (log.children.length >= 3) {
                log.removeChild(log.firstChild);
            }
            
            const message = document.createElement('div');
            message.className = `message message-${type}`;
            message.textContent = text;
            log.appendChild(message);
            
            // 2ÁßíÂêéÊ∑°Âá∫
            setTimeout(() => {
                message.style.opacity = '0';
                message.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    if (message.parentNode) {
                        message.remove();
                    }
                }, 500);
            }, 2000);
        }
        
        // ========== Êõ¥Êñ∞UI ==========
        function updateUI() {
            document.getElementById('game-score').textContent = gameState.score;
            document.getElementById('game-coins').textContent = gameState.coins;
            
            // Êõ¥Êñ∞ËÉΩÈáèÊù°
            const energyBar = document.getElementById('energy-bar');
            energyBar.style.width = gameState.energy + '%';
            if (gameState.energy < 20) {
                energyBar.classList.add('low');
            } else {
                energyBar.classList.remove('low');
            }
            
            // Êõ¥Êñ∞‰ªªÂä°ÂàóË°®
            const taskList = document.getElementById('task-list');
            taskList.innerHTML = '';
            gameState.tasks.forEach(task => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'task-item' + (task.completed ? ' completed' : '');
                taskDiv.innerHTML = `
                    <div>${task.completed ? '‚úì' : '‚óã'} ${task.name}</div>
                    <div class="task-progress">${task.description}</div>
                    <div class="task-progress">ËøõÂ∫¶: ${task.progress}/${task.target === -1 ? '?' : task.target}</div>
                `;
                taskList.appendChild(taskDiv);
            });
        }
        
        // ========== Êõ¥Êñ∞Â∞èÂú∞Âõæ ==========
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const size = 150;
            
            // Ê∏ÖÁ©∫
            ctx.clearRect(0, 0, size, size);
            
            // ËÉåÊôØ
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, size, size);
            
            // ÁΩëÊ†º
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const pos = (i * size) / 4;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            // Ê§çÁâ©
            const scale = size / 3;
            gameState.plants.forEach(plant => {
                if (plant.is_removed) return;
                
                const x = (plant.position.x * scale / 2) + size / 2;
                const y = (plant.position.z * scale / 2) + size / 2;
                
                ctx.fillStyle = plant.is_weed ? '#C62828' : '#4CAF50';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Â∞èËΩ¶
            const cartX = (cart.position.x * scale / 2) + size / 2;
            const cartY = (cart.position.z * scale / 2) + size / 2;
            
            ctx.fillStyle = '#2196F3';
            ctx.beginPath();
            ctx.moveTo(cartX, cartY - 5);
            ctx.lineTo(cartX - 4, cartY + 3);
            ctx.lineTo(cartX + 4, cartY + 3);
            ctx.closePath();
            ctx.fill();
        }
        
        // ========== Á™óÂè£Ë∞ÉÊï¥ ==========
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ========== Âä®ÁîªÂæ™ÁéØ ==========
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            
            // Êõ¥Êñ∞Â∞èËΩ¶
            updateCart(deltaTime);
            
            // Êõ¥Êñ∞Áõ∏Êú∫
            updateCamera();
            
            // ‰∏çÊõ¥Êñ∞ÊøÄÂÖâÁûÑÂáÜÁ∫øÔºàÂ∑≤ÁßªÈô§Ôºâ
            
            // Êõ¥Êñ∞Â∞èÂú∞Âõæ
            updateMinimap();
            
            // Ê∏≤Êüì
            renderer.render(scene, camera);
        }
        
        // ========== Socket.IO‰∫ã‰ª∂ ==========
        socket.on('connected', (data) => {
            console.log('Socket connected');
            if (data.state) {
                gameState = data.state;
                updateUI();
            }
        });
        
        socket.on('laser_fired', (data) => {
            // ÂèØ‰ª•Ê∑ªÂä†ÊøÄÂÖâËßÜËßâÊïàÊûú
            console.log('Laser fired:', data);
        });
        
        // ÁõëÂê¨Â∞èËΩ¶‰ΩçÁΩÆÊõ¥Êñ∞ÔºàÁî®‰∫éËá™Âä®ÂåñÁßªÂä®Ôºâ
        socket.on('cart_update', (data) => {
            console.log('Cart update:', data);
            
            // ÂÅúÊ≠¢Ëá™Âä®Â∑°Ëà™ÔºàÂ¶ÇÊûúÊ≠£Âú®ËøõË°åÔºâ
            if (autoTraverse.active) {
                stopAutoTraverse('external control');
            }
            
            // Êõ¥Êñ∞Â∞èËΩ¶‰ΩçÁΩÆ
            if (data.x !== undefined && data.z !== undefined) {
                cart.position.x = data.x;
                cart.position.z = data.z;
            }
            
            // Êõ¥Êñ∞Â∞èËΩ¶ÊóãËΩ¨
            if (data.rotation !== undefined) {
                cart.rotation.y = THREE.MathUtils.degToRad(data.rotation);
            }
            
            // Êõ¥Êñ∞ÈÄüÂ∫¶ÊòæÁ§∫
            if (data.speed !== undefined) {
                cartSpeed = data.speed;
            }
        });
        
        // ÁõëÂê¨Ëá™Âä®ÂåñÂÜúÂú∫‰ªªÂä°ÂºÄÂßã
        socket.on('auto_farm_task_started', (data) => {
            console.log('ü§ñ Ëá™Âä®Âåñ‰ªªÂä°ÂºÄÂßã:', data);
            // ÂèØ‰ª•Ê∑ªÂä†ËßÜËßâÊèêÁ§∫ÔºåÊØîÂ¶ÇÈ´ò‰∫ÆÁõÆÊ†áÊ§çÁâ©
        });
        
        // ÁõëÂê¨Ëá™Âä®ÂåñÂÜúÂú∫Êìç‰Ωú
        socket.on('auto_farm_action', (data) => {
            console.log('‚ö° Ëá™Âä®ÂåñÊìç‰Ωú:', data);
            // ÂèØ‰ª•Ëß¶ÂèëÁõ∏Â∫îÁöÑÂä®ÁîªÊïàÊûú
        });
        
        // ========== ÊâãÂä®ÊéßÂà∂Èù¢Êùø‰∫ã‰ª∂ÁõëÂê¨Âô® ==========
        // ÂÖ≥Èó≠Èù¢ÊùøÊåâÈíÆ
        document.getElementById('close-arm-panel').addEventListener('click', () => {
            toggleArmControlPanel();
        });
        
        // ËΩ¥ÊéßÂà∂ÊåâÈíÆ
        document.querySelectorAll('.axis-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const axis = parseInt(btn.getAttribute('data-axis'));
                const dir = parseInt(btn.getAttribute('data-dir'));
                controlAxis(axis, dir);
            });
        });
        
        // ÊªëÂùóÊéßÂà∂
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`axis${i}-slider`).addEventListener('input', (e) => {
                armManualControl.currentAngles[`axis${i}`] = parseFloat(e.target.value);
                applyAxisAngle(i);
                updateAxisDisplay(i);
                updateEndEffectorPosition();
            });
        }
        
        // ÊäìÊâãÊéßÂà∂
        document.getElementById('gripper-open').addEventListener('click', () => {
            controlGripper(true);
        });
        document.getElementById('gripper-close').addEventListener('click', () => {
            controlGripper(false);
        });
        
        // È¢ÑËÆæÂßøÊÄÅ
        document.querySelectorAll('.pose-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const pose = btn.getAttribute('data-pose');
                setPose(pose);
            });
        });
        
        // Êú∫Ê¢∞ËáÇÈîÆÁõòÊéßÂà∂ (ÂßãÁªàÁîüÊïà)
        document.addEventListener('keydown', (e) => {
            // MÈîÆÂàáÊç¢Êú∫Ê¢∞ËáÇËßíÂ∫¶ÁõëËßÜÈù¢Êùø
            if (e.key.toLowerCase() === 'm' && !e.repeat) {
                toggleArmStatus();
                return;
            }
            
            // RÈîÆÂ§ç‰ΩçÊú∫Ê¢∞ËáÇ
            if (e.key.toLowerCase() === 'r' && !e.repeat) {
                setPose('home');
                showMessage('Êú∫Ê¢∞ËáÇÂ∑≤Â§ç‰ΩçÂà∞ÂàùÂßãÂßøÊÄÅ', 'info');
                return;
            }
            
            // Êú∫Ê¢∞ËáÇÊéßÂà∂Âø´Êç∑ÈîÆ
            const key = e.key;
            switch(key) {
                // ËΩ¥1 - Âü∫Â∫ßÊóãËΩ¨
                case '7': 
                    controlAxis(1, -1); 
                    if (!armManualControl.showStatus) {
                        let displayAngle = armManualControl.currentAngles.axis1 % 360;
                        if (displayAngle > 180) displayAngle -= 360;
                        if (displayAngle < -180) displayAngle += 360;
                        showMessage('ËΩ¥1: ' + displayAngle.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                case '8':
                case '9': 
                    controlAxis(1, 1); 
                    if (!armManualControl.showStatus) {
                        let displayAngle = armManualControl.currentAngles.axis1 % 360;
                        if (displayAngle > 180) displayAngle -= 360;
                        if (displayAngle < -180) displayAngle += 360;
                        showMessage('ËΩ¥1: ' + displayAngle.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                
                // ËΩ¥2 - ËÇ©ÂÖ≥ËäÇ
                case 'u':
                case 'U':
                    controlAxis(2, -1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥2: ' + armManualControl.currentAngles.axis2.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                case 'i':
                case 'I':
                    controlAxis(2, 1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥2: ' + armManualControl.currentAngles.axis2.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                
                // ËΩ¥3 - ËÇòÂÖ≥ËäÇ
                case 'j':
                case 'J':
                    controlAxis(3, -1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥3: ' + armManualControl.currentAngles.axis3.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                case 'k':
                case 'K':
                    controlAxis(3, 1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥3: ' + armManualControl.currentAngles.axis3.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                
                // ËΩ¥4 - ËÖïÂÖ≥ËäÇ
                case 'n':
                case 'N':
                    controlAxis(4, -1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥4: ' + armManualControl.currentAngles.axis4.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                case 'o':
                case 'O':
                case '0':
                    controlAxis(4, 1);
                    if (!armManualControl.showStatus) {
                        showMessage('ËΩ¥4: ' + armManualControl.currentAngles.axis4.toFixed(0) + '¬∞', 'info');
                    }
                    break;
                
                // ÊäìÊâã
                case ',':
                    controlGripper(true);
                    showMessage('ÊäìÊâãÂº†ÂºÄ', 'info');
                    break;
                case '.':
                    controlGripper(false);
                    showMessage('ÊäìÊâãÂêàÊã¢', 'info');
                    break;
            }
        });
        
        // ========== ÂúüÂ£§Ê£ÄÊµãÊïàÊûú ==========
        function createSoilDetectEffect(position) {
            // ÂàõÂª∫Êé¢Èíà‰∏ãÈôçÂä®ÁîªÔºàÈªÑËâ≤ÂÖâÊü±Ôºâ
            const probeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            const probeMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.8
            });
            const probe = new THREE.Mesh(probeGeometry, probeMaterial);
            probe.position.set(position.x, 0.5, position.z);
            scene.add(probe);
            
            // ‰∏ãÈôçÂä®Áîª
            let probeY = 0.5;
            const probeInterval = setInterval(() => {
                probeY -= 0.02;
                probe.position.y = probeY;
                
                if (probeY <= 0.05) {
                    clearInterval(probeInterval);
                    
                    // Ê£ÄÊµãÂÆåÊàêÔºåÊòæÁ§∫ËÑâÂÜ≤ÊïàÊûú
                    let pulseCount = 0;
                    const pulseInterval = setInterval(() => {
                        probeMaterial.opacity = 0.3 + Math.sin(pulseCount * 0.5) * 0.5;
                        pulseCount++;
                        
                        if (pulseCount >= 20) {
                            clearInterval(pulseInterval);
                            scene.remove(probe);
                            probeGeometry.dispose();
                            probeMaterial.dispose();
                        }
                    }, 50);
                }
            }, 30);
        }
        
        // ========== ÊòæÁ§∫ÂúüÂ£§‰ø°ÊÅØÈù¢Êùø ==========
        function showSoilInfo(data) {
            const soil = data.soil_data;
            const score = data.health_score;
            const issues = data.issues || [];
            const recommendations = data.recommendations || [];
            
            // ÁßªÈô§ÊóßÁöÑÂúüÂ£§‰ø°ÊÅØÈù¢ÊùøÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            const oldPanel = document.getElementById('soil-info-panel');
            if (oldPanel) oldPanel.remove();
            
            // ÂÅ•Â∫∑Á≠âÁ∫ß
            let healthLevel = '‰ºòÁßÄ';
            let healthColor = '#00FF00';
            if (score < 60) {
                healthLevel = 'Â∑Æ';
                healthColor = '#FF0000';
            } else if (score < 75) {
                healthLevel = '‰∏ÄËà¨';
                healthColor = '#FFA500';
            } else if (score < 90) {
                healthLevel = 'ËâØÂ•Ω';
                healthColor = '#FFFF00';
            }
            
            // ÂàõÂª∫ËΩªÈáèÁ∫ßHUDÈù¢ÊùøÔºàÂè≥‰∏ãËßíÔºåÈÄèÊòéÔºåËá™Âä®Ê∂àÂ§±Ôºâ
            const infoHTML = `
                <div style="position: fixed; bottom: 180px; right: 20px; 
                     background: rgba(0, 0, 0, 0.75); padding: 15px; border-radius: 12px; 
                     border: 2px solid ${healthColor}; min-width: 300px; max-width: 350px;
                     box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 10px ${healthColor}40; 
                     z-index: 1000; backdrop-filter: blur(5px);
                     animation: slideInRight 0.3s ease-out;">
                    
                    <!-- Ê†áÈ¢òÊ†è -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="color: ${healthColor}; font-weight: bold; font-size: 16px;">
                            üî¨ ÂúüÂ£§Ê£ÄÊµã
                        </div>
                        <div style="font-size: 20px; font-weight: bold; color: ${healthColor};">
                            ${score}/100
                        </div>
                    </div>
                    
                    <!-- ÂÅ•Â∫∑Áä∂ÊÄÅÊù° -->
                    <div style="background: rgba(255, 255, 255, 0.1); height: 8px; border-radius: 4px; margin-bottom: 12px; overflow: hidden;">
                        <div style="background: ${healthColor}; height: 100%; width: ${score}%; transition: width 0.5s;"></div>
                    </div>
                    
                    <!-- Êï∞ÊçÆÁΩëÊ†º -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; font-size: 13px;">
                        <div style="color: rgba(255, 255, 255, 0.8);">üìä PH: <span style="color: #00FF00;">${soil.ph}</span></div>
                        <div style="color: rgba(255, 255, 255, 0.8);">üíß ÊπøÂ∫¶: <span style="color: #00BFFF;">${soil.moisture}%</span></div>
                        <div style="color: rgba(255, 255, 255, 0.8);">üåø N: <span style="color: #90EE90;">${soil.nitrogen}%</span></div>
                        <div style="color: rgba(255, 255, 255, 0.8);">üåæ P: <span style="color: #FFD700;">${soil.phosphorus}%</span></div>
                        <div style="color: rgba(255, 255, 255, 0.8);">üçÄ K: <span style="color: #FFA500;">${soil.potassium}%</span></div>
                        <div style="color: rgba(255, 255, 255, 0.8);">üå°Ô∏è ${soil.temperature}¬∞C</div>
                    </div>
                    
                    <!-- ÈóÆÈ¢òÊèêÁ§∫ÔºàÂ¶ÇÊûúÊúâÔºâ -->
                    ${issues.length > 0 ? `
                        <div style="background: rgba(255, 0, 0, 0.15); padding: 8px; border-radius: 6px; 
                             margin-bottom: 8px; border-left: 3px solid #FF0000; font-size: 12px;">
                            <div style="color: #FF6B6B; font-weight: bold; margin-bottom: 3px;">‚ö†Ô∏è ÈóÆÈ¢ò</div>
                            ${issues.slice(0, 2).map(issue => `<div style="color: #FFB3B3;">‚Ä¢ ${issue}</div>`).join('')}
                        </div>
                    ` : ''}
                    
                    <!-- Âª∫ËÆÆÔºàÂè™ÊòæÁ§∫Á¨¨‰∏ÄÊù°Ôºâ -->
                    <div style="background: rgba(0, 255, 0, 0.1); padding: 8px; border-radius: 6px; 
                         border-left: 3px solid #00FF00; font-size: 12px;">
                        <div style="color: #90EE90;">üí° ${recommendations[0] || 'ÂúüÂ£§Áä∂ÂÜµËâØÂ•Ω'}</div>
                    </div>
                    
                    <!-- Ëá™Âä®ÂÖ≥Èó≠ÊèêÁ§∫ -->
                    <div style="text-align: center; margin-top: 8px; font-size: 11px; color: rgba(255, 255, 255, 0.5);">
                        5ÁßíÂêéËá™Âä®ÂÖ≥Èó≠
                    </div>
                </div>
            `;
            
            // Ê∑ªÂä†ÊªëÂÖ•Âä®Áîª
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(400px);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
            `;
            document.head.appendChild(style);
            
            const panel = document.createElement('div');
            panel.innerHTML = infoHTML;
            panel.id = 'soil-info-panel';
            document.body.appendChild(panel);
            
            // 5ÁßíÂêéËá™Âä®Ê∑°Âá∫Âπ∂ÁßªÈô§
            setTimeout(() => {
                if (panel.parentElement) {
                    panel.style.transition = 'opacity 0.4s, transform 0.4s';
                    panel.style.opacity = '0';
                    panel.style.transform = 'translateX(400px)';
                    setTimeout(() => {
                        panel.remove();
                        style.remove();
                    }, 400);
                }
            }, 5000);
        }
        
        // ========== Âñ∑ÈõæÊïàÊûú ==========
        function createSprayEffect(position) {
            // ÂàõÂª∫ÁªøËâ≤Âñ∑ÈõæÁ≤íÂ≠ê
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // ‰ªéÂ∞èËΩ¶‰ΩçÁΩÆÂñ∑ÂêëÊ§çÁâ©
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.2;
                
                positions.push(
                    cart.position.x + Math.cos(angle) * radius,
                    cart.position.y + 0.3 + Math.random() * 0.2,
                    cart.position.z + Math.sin(angle) * radius
                );
                
                // ÂêëÁõÆÊ†áÊ§çÁâ©ÊñπÂêëÁßªÂä®
                const dx = (position.x - cart.position.x) + (Math.random() - 0.5) * 0.3;
                const dy = Math.random() * 0.02 - 0.01;
                const dz = (position.z - cart.position.z) + (Math.random() - 0.5) * 0.3;
                const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                velocities.push(
                    dx / len * 0.04,
                    dy / len * 0.04,
                    dz / len * 0.04
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.08,
                color: 0x00FF00,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Á≤íÂ≠êÂä®Áîª
            let lifetime = 0;
            const maxLifetime = 40;
            const interval = setInterval(() => {
                lifetime++;
                
                const pos = geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 0.7 * (1 - lifetime / maxLifetime);
                
                if (lifetime >= maxLifetime) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 16);
        }
        
        // ========== ÊµáÊ∞¥ÊïàÊûú ==========
        function createWaterEffect(position) {
            // ÂàõÂª∫ËìùËâ≤Ê∞¥ÊµÅÁ≤íÂ≠ê
            const particleCount = 60;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // ‰ªé‰∏äÊñπËêΩ‰∏ã
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.15;
                
                positions.push(
                    position.x + Math.cos(angle) * radius,
                    position.y + 0.8 + Math.random() * 0.2,
                    position.z + Math.sin(angle) * radius
                );
                
                velocities.push(
                    (Math.random() - 0.5) * 0.01,
                    -0.03 - Math.random() * 0.02,  // Âêë‰∏ã
                    (Math.random() - 0.5) * 0.01
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.06,
                color: 0x00BFFF,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Ê∞¥Êª¥Âä®Áîª
            let lifetime = 0;
            const maxLifetime = 50;
            const interval = setInterval(() => {
                lifetime++;
                
                const pos = geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                    
                    // ËêΩÂà∞Âú∞Èù¢ÂêéÂÅúÊ≠¢
                    if (pos[i * 3 + 1] <= 0.02) {
                        pos[i * 3 + 1] = 0.02;
                        velocities[i * 3 + 1] = 0;
                    }
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 0.8 * (1 - lifetime / maxLifetime);
                
                if (lifetime >= maxLifetime) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 16);
            
            // Ê∑ªÂä†Ê∞¥Ëä±È£ûÊ∫ÖÊïàÊûú
            setTimeout(() => {
                createSplashEffect(position);
            }, 400);
        }
        
        function createSplashEffect(position) {
            const splashCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < splashCount; i++) {
                positions.push(position.x, 0.02, position.z);
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.03 + 0.01;
                velocities.push(
                    Math.cos(angle) * speed,
                    Math.random() * 0.02 + 0.01,
                    Math.sin(angle) * speed
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.04,
                color: 0x87CEEB,
                transparent: true,
                opacity: 1
            });
            
            const splash = new THREE.Points(geometry, material);
            scene.add(splash);
            
            let lifetime = 0;
            const interval = setInterval(() => {
                lifetime++;
                const pos = geometry.attributes.position.array;
                
                for (let i = 0; i < splashCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                    
                    velocities[i * 3 + 1] -= 0.001;  // ÈáçÂäõ
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 1 - lifetime / 20;
                
                if (lifetime >= 20) {
                    clearInterval(interval);
                    scene.remove(splash);
                    geometry.dispose();
                    material.dispose();
                }
            }, 30);
        }
        
        // ========== Êõ¥Êñ∞Ê§çÁâ©ÁîüÈïøÈò∂ÊÆµ ==========
        function updatePlantGrowth(plantMesh, newStage) {
            // Ê§çÁâ©ÁîüÈïøÂä®Áîª
            const targetScale = 0.8 + (newStage - 1) * 0.15;
            const startScale = plantMesh.scale.x;
            
            let progress = 0;
            const growInterval = setInterval(() => {
                progress += 0.05;
                const currentScale = startScale + (targetScale - startScale) * Math.min(progress, 1);
                plantMesh.scale.set(currentScale, currentScale, currentScale);
                
                // Èó™ÁÉÅÊïàÊûú
                if (progress < 0.5) {
                    plantMesh.material.emissive.setHex(0x00FF00);
                    plantMesh.material.emissiveIntensity = Math.sin(progress * Math.PI * 10) * 0.3;
                } else {
                    plantMesh.material.emissiveIntensity = 0;
                }
                
                if (progress >= 1) {
                    clearInterval(growInterval);
                    plantMesh.material.emissiveIntensity = 0;
                }
            }, 30);
            
            // ÁîüÈïøÁ≤íÂ≠êÊïàÊûú
            createGrowthParticles(plantMesh.position);
        }
        
        function createGrowthParticles(position) {
            const particleCount = 25;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.1;
                
                positions.push(
                    position.x + Math.cos(angle) * radius,
                    position.y + Math.random() * 0.1,
                    position.z + Math.sin(angle) * radius
                );
                
                velocities.push(
                    (Math.random() - 0.5) * 0.02,
                    Math.random() * 0.03 + 0.02,
                    (Math.random() - 0.5) * 0.02
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                color: 0x7FFF00,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            let lifetime = 0;
            const interval = setInterval(() => {
                lifetime++;
                const pos = geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                }
                geometry.attributes.position.needsUpdate = true;
                
                material.opacity = 1 - lifetime / 30;
                
                if (lifetime >= 30) {
                    clearInterval(interval);
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            }, 30);
        }
        
        // ========== Èº†Ê†áÊåâ‰∏ã/ÊùæÂºÄÔºàÊåÅÁª≠‰ΩøÁî®Ôºâ==========
        function onMouseDown(event) {
            if (event.button !== 0) return;  // Âè™ÂìçÂ∫îÂ∑¶ÈîÆ
            
            const config = equipmentConfig[gameState.currentEquipment];
            if (!config) return;
            
            // Âñ∑Ê¥íÂô®ÂíåÊµáÊ∞¥Á≥ªÁªüÔºöÊåâ‰ΩèÊåÅÁª≠‰ΩøÁî®
            if (config.interactionType === 'cone' || config.interactionType === 'area') {
                isUsingEquipment = true;
                showMessage(`${config.name}ÂêØÂä®...`, 'info');
            }
        }
        
        function onMouseUp(event) {
            if (event.button !== 0) return;
            
            if (isUsingEquipment) {
                isUsingEquipment = false;
                showMessage('ÂÅúÊ≠¢‰ΩøÁî®', 'info');
            }
        }
        
        // ========== ÊøÄÂÖâËá™Âä®ÁûÑÂáÜÂπ∂ÊîªÂáªÊùÇËçâ ==========
        // üêõ Ë∞ÉËØïÂèØËßÜÂåñÁ≥ªÁªü
        let debugMarkers = {
            target: null,    // ÁõÆÊ†á‰ΩçÁΩÆÊ†áËÆ∞ÔºàÁ∫¢Ëâ≤Ôºâ
            hit: null        // Âáª‰∏≠‰ΩçÁΩÆÊ†áËÆ∞ÔºàÈªÑËâ≤Ôºâ
        };
        
        function clearDebugMarkers() {
            if (debugMarkers.target) {
                scene.remove(debugMarkers.target);
                debugMarkers.target = null;
            }
            if (debugMarkers.hit) {
                scene.remove(debugMarkers.hit);
                debugMarkers.hit = null;
            }
        }
        
        function showTargetMarker(position, label = "ÁõÆÊ†á") {
            clearDebugMarkers();
            
            // ÂàõÂª∫Á∫¢Ëâ≤ÁõÆÊ†áÊ†áËÆ∞ÔºàÂúÜÁéØ + ÂçÅÂ≠óÔºâ
            const group = new THREE.Group();
            
            // Â§ñÂúàÔºàÁ∫¢Ëâ≤ÂúÜÁéØÔºâ
            const ringGeometry = new THREE.TorusGeometry(0.05, 0.008, 8, 24);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            // ÂçÅÂ≠óÂáÜÊòü
            const crossMaterial = new THREE.LineBasicMaterial({ color: 0xFF0000, linewidth: 2 });
            const crossPoints1 = [
                new THREE.Vector3(-0.04, 0, 0),
                new THREE.Vector3(0.04, 0, 0)
            ];
            const crossPoints2 = [
                new THREE.Vector3(0, 0, -0.04),
                new THREE.Vector3(0, 0, 0.04)
            ];
            const crossGeo1 = new THREE.BufferGeometry().setFromPoints(crossPoints1);
            const crossGeo2 = new THREE.BufferGeometry().setFromPoints(crossPoints2);
            group.add(new THREE.Line(crossGeo1, crossMaterial));
            group.add(new THREE.Line(crossGeo2, crossMaterial));
            
            // ÂèëÂÖâÊïàÊûú
            const glowGeometry = new THREE.SphereGeometry(0.03, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.5
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            group.position.copy(position);
            group.position.y = 0.1;  // Á®çÂæÆÊä¨È´ò
            scene.add(group);
            debugMarkers.target = group;
            
            console.log(`üéØ [Ë∞ÉËØï] ${label}‰ΩçÁΩÆ: (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
        }
        
        function showHitMarker(position, label = "Âáª‰∏≠") {
            if (debugMarkers.hit) {
                scene.remove(debugMarkers.hit);
            }
            
            // ÂàõÂª∫ÈªÑËâ≤Âáª‰∏≠Ê†áËÆ∞ÔºàÁàÜÁÇ∏ÊïàÊûúÔºâ
            const group = new THREE.Group();
            
            // ‰∏≠ÂøÉÁêÉ
            const sphereGeometry = new THREE.SphereGeometry(0.03, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.9
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // Â§ñÂúàÔºàÈªÑËâ≤ÂÖâÂúàÔºâ
            const ringGeometry = new THREE.TorusGeometry(0.04, 0.006, 8, 24);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFAA00,
                transparent: true,
                opacity: 0.7
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            // Â∞ÑÁ∫øÊïàÊûú
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const points = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(Math.cos(angle) * 0.06, 0, Math.sin(angle) * 0.06)
                ];
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                const lineMat = new THREE.LineBasicMaterial({ color: 0xFFFF00, linewidth: 2 });
                group.add(new THREE.Line(lineGeo, lineMat));
            }
            
            group.position.copy(position);
            group.position.y = 0.1;  // Á®çÂæÆÊä¨È´ò
            scene.add(group);
            debugMarkers.hit = group;
            
            console.log(`üî• [Ë∞ÉËØï] ${label}‰ΩçÁΩÆ: (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)})`);
            
            // ËÆ°ÁÆó‰ΩçÁΩÆÂ∑Æ
            if (debugMarkers.target) {
                const diff = debugMarkers.target.position.distanceTo(position);
                console.log(`üìè [Ë∞ÉËØï] ‰ΩçÁΩÆÂÅèÂ∑Æ: ${diff.toFixed(3)}m ${diff < 0.05 ? '‚úÖ Á≤æÂáÜ' : diff < 0.1 ? '‚ö†Ô∏è ËΩªÂæÆÂÅèÂ∑Æ' : '‚ùå ÂÅèÂ∑ÆËæÉÂ§ß'}`);
            }
            
            // 2ÁßíÂêéËá™Âä®Ê∏ÖÈô§
            setTimeout(() => {
                if (debugMarkers.hit === group) {
                    scene.remove(group);
                    debugMarkers.hit = null;
                }
            }, 2000);
        }
        
        // ========== üî¥ ÁÆÄÂåñÁâàÊøÄÂÖâÁ≥ªÁªü ==========
        async function useAutoLaser() {
            console.log('üî¥ ÊøÄÂÖâÁ≥ªÁªüÔºöÊåâ‰∏ãÁ©∫Ê†ºÈîÆ');
            
            // 1. ÊâæÂà∞ÊúÄËøëÁöÑÊùÇËçâ
            const target = findClosestWeed();
            
            if (target) {
                // ÊúâÊùÇËçâÔºöËá™Âä®ÁûÑÂáÜÂπ∂ÂèëÂ∞Ñ
                console.log(`üéØ ÁõÆÊ†á: ${target.userData.id}`);
                
                // 2. ÁÆÄÂçïÁûÑÂáÜ
                await aimAtTarget(target);
                
                // 3. ÂèëÂ∞ÑÊøÄÂÖâ
                await fireLaser(target);
            } else {
                // Ê≤°ÊúâÊùÇËçâÔºöÊ≤øÁûÑÂáÜÁ∫øÊñπÂêëËá™Áî±ÂèëÂ∞Ñ
                console.log('üéØ Ëá™Áî±ÂèëÂ∞ÑÊ®°Âºè - Ê≤øÁûÑÂáÜÁ∫øÂèëÂ∞Ñ');
                showMessage('Ëá™Áî±ÂèëÂ∞ÑÔºÅ', 'info');
                
                // Áõ¥Êé•ÂèëÂ∞ÑÔºà‰∏çÈúÄË¶ÅÁûÑÂáÜÔºå‰øùÊåÅÂΩìÂâçÂßøÊÄÅÔºâ
                await fireFreeLaser();
            }
        }
        
        // Êü•ÊâæÊúÄËøëÁöÑÊùÇËçâ
        function findClosestWeed() {
            let closest = null;
            let minDist = Infinity;
            const maxRange = 5;  // 5Á±≥ËåÉÂõ¥
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id) return;
                if (!child.userData.is_weed) return;
                if (child.userData.is_removed) return;
                
                const dist = cart.position.distanceTo(child.position);
                if (dist < minDist && dist <= maxRange) {
                        minDist = dist;
                    closest = child;
                }
            });
            
            return closest;
        }
        
        // ÁûÑÂáÜÁõÆÊ†áÔºàÂ∏¶Âä®ÁîªÔºâ
        // üéØ Êô∫ËÉΩËá™ÈÄÇÂ∫îÁûÑÂáÜ - ÊøÄÂÖâÂûÇÁõ¥‰∫éËÖïÂÖ≥ËäÇÔºåÈÄöËøáÂõõËΩ¥ËÅîÂä®ÁûÑÂáÜÁõÆÊ†á
        async function aimAtTarget(target) {
            const arm = cart.getObjectByName('robotic_arm');
            if (!arm) return;
            
            // Ëé∑ÂèñÂÖ≥ËäÇ
            const base = arm;  // Âü∫Â∫ß (axis1) - Ê∞¥Âπ≥ÊóãËΩ¨
            const shoulder = arm.getObjectByName('axis2_shoulder');  // ËÇ©ÂÖ≥ËäÇ - ‰øØ‰ª∞
            const elbow = arm.getObjectByName('axis3_elbow');        // ËÇòÂÖ≥ËäÇ - ‰øØ‰ª∞
            const wrist = arm.getObjectByName('axis4_wrist');        // ËÖïÂÖ≥ËäÇ - ‰øØ‰ª∞
            
            if (!shoulder || !elbow || !wrist) return;
            
            // ËÆ°ÁÆó‰ªéÂ∞èËΩ¶Âà∞ÁõÆÊ†áÁöÑÊñπÂêëÂêëÈáè
            const dx = target.position.x - cart.position.x;
            const dy = target.position.y - cart.position.y;
            const dz = target.position.z - cart.position.z;
            
            // ËÆ°ÁÆóÊ∞¥Âπ≥Ë∑ùÁ¶ªÂíåÊÄªË∑ùÁ¶ª
            const horizontalDist = Math.sqrt(dx * dx + dz * dz);
            const totalDist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            // 1Ô∏è‚É£ Âü∫Â∫ßÊóãËΩ¨ËßíÂ∫¶ÔºàÊ∞¥Âπ≥ÂØπÂáÜÁõÆÊ†áÔºâ
            const angleToTarget = Math.atan2(dx, dz);
            const targetBaseAngle = angleToTarget - cart.rotation.y + Math.PI / 2;
            
            // 2Ô∏è‚É£ ËÆ°ÁÆóÊï¥‰Ωì‰øØ‰ª∞ËßíÔºà‰ªéÊ∞¥Âπ≥Èù¢Âà∞ÁõÆÊ†áÔºâ
            const pitchAngle = Math.atan2(dy, horizontalDist);
            
            // 3Ô∏è‚É£ Ê†πÊçÆË∑ùÁ¶ªÂíåËßíÂ∫¶ÔºåÂàÜÈÖçÁªôÂêÑ‰∏™ÂÖ≥ËäÇ
            // ÂÅáËÆæÊú∫Ê¢∞ËáÇÂêÑÊÆµÈïøÂ∫¶ÔºàÁõ∏ÂØπÂçï‰ΩçÔºâ
            const shoulderLength = 1.0;   // ËÇ©Âà∞ËÇòÁöÑÈïøÂ∫¶
            const elbowLength = 1.0;      // ËÇòÂà∞ËÖïÁöÑÈïøÂ∫¶
            const wristLength = 0.5;      // ËÖïÂà∞ÊøÄÂÖâÂèëÂ∞ÑÁÇπÁöÑÈïøÂ∫¶
            
            // ÁÆÄÂåñÁöÑÈÄÜËøêÂä®Â≠¶ÔºöÊ†πÊçÆË∑ùÁ¶ªÂíå‰øØ‰ª∞ËßíÂàÜÈÖçÂÖ≥ËäÇËßíÂ∫¶
            // ËÇ©ÂÖ≥ËäÇÔºö‰∏ªË¶ÅË¥üË¥£Êï¥‰Ωì‰øØ‰ª∞
            let targetShoulderAngle = pitchAngle - 0.2;  // Âü∫Á°Ä‰øØ‰ª∞Ëßí
            
            // ËÇòÂÖ≥ËäÇÔºöÊ†πÊçÆË∑ùÁ¶ªË∞ÉÊï¥ÂºØÊõ≤Á®ãÂ∫¶ÔºàËøëÂ§ÑÂºØÊõ≤Â§öÔºåËøúÂ§Ñ‰º∏Â±ïÔºâ
            const bendFactor = Math.max(0, Math.min(1, (5 - totalDist) / 3));  // Ë∑ùÁ¶ªË∂äËøëÂºØÊõ≤Ë∂äÂ§ö
            let targetElbowAngle = bendFactor * 0.4 - 0.2;  // -0.2 Âà∞ 0.2 ËåÉÂõ¥
            
            // ËÖïÂÖ≥ËäÇÔºöÂæÆË∞ÉÊúÄÁªàÊåáÂêëËßíÂ∫¶
            let targetWristAngle = pitchAngle * 0.3;  // ÂçèÂä©ËÇ©ÂÖ≥ËäÇÁöÑ‰øØ‰ª∞
            
            // ÈôêÂà∂ËßíÂ∫¶ËåÉÂõ¥ÔºàÈÅøÂÖçÂÖ≥ËäÇËøáÂ∫¶ÊóãËΩ¨Ôºâ
            targetShoulderAngle = Math.max(-Math.PI/2, Math.min(Math.PI/4, targetShoulderAngle));
            targetElbowAngle = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetElbowAngle));
            targetWristAngle = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetWristAngle));
            
            console.log(`üéØ Ëá™ÈÄÇÂ∫îÁûÑÂáÜËÆ°ÁÆó:
   Ë∑ùÁ¶ª: ${totalDist.toFixed(2)}m
   Ê∞¥Âπ≥Ëßí: ${(targetBaseAngle * 180 / Math.PI).toFixed(1)}¬∞
   ‰øØ‰ª∞Ëßí: ${(pitchAngle * 180 / Math.PI).toFixed(1)}¬∞
   ËÇ©: ${(targetShoulderAngle * 180 / Math.PI).toFixed(1)}¬∞
   ËÇò: ${(targetElbowAngle * 180 / Math.PI).toFixed(1)}¬∞
   ËÖï: ${(targetWristAngle * 180 / Math.PI).toFixed(1)}¬∞`);
            
            // ËÆ∞ÂΩïÂàùÂßãËßíÂ∫¶
            const startBaseAngle = base.rotation.y;
            const startShoulderAngle = shoulder.rotation.z;
            const startElbowAngle = elbow.rotation.z;
            const startWristAngle = wrist.rotation.z;
            
            // Âä®ÁîªÊó∂ÈïøÔºàÊØ´ÁßíÔºâ
            const duration = 350;
            const startTime = Date.now();
            
            // Âπ≥ÊªëÂõõËΩ¥ËÅîÂä®Âä®Áîª
            return new Promise(resolve => {
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ‰ΩøÁî®ÁºìÂä®ÂáΩÊï∞Ôºàease-in-outÔºâËÆ©Âä®‰ΩúÊõ¥Ëá™ÁÑ∂
                    const eased = progress < 0.5 
                        ? 4 * progress * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                    
                    // ÂõõËΩ¥ÂêåÊ≠•Âπ≥ÊªëÊèíÂÄº
                    base.rotation.y = startBaseAngle + (targetBaseAngle - startBaseAngle) * eased;
                    shoulder.rotation.z = startShoulderAngle + (targetShoulderAngle - startShoulderAngle) * eased;
                    elbow.rotation.z = startElbowAngle + (targetElbowAngle - startElbowAngle) * eased;
                    wrist.rotation.z = startWristAngle + (targetWristAngle - startWristAngle) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        console.log(`‚úÖ ÂõõËΩ¥ÁûÑÂáÜÂÆåÊàêÔºÅ`);
                        resolve();
                    }
                }
                animate();
            });
        }
        
        // ÂèëÂ∞ÑÊøÄÂÖâ
        async function fireLaser(target) {
            console.log('üî• ÂèëÂ∞ÑÊøÄÂÖâÔºÅ');
            
            const arm = cart.getObjectByName('robotic_arm');
            if (!arm) {
                showMessage('Êú∫Ê¢∞ËáÇÊú™ÊâæÂà∞', 'error');
                return;
            }
            
            const base = arm;  // Âü∫Â∫ß (axis1)
            const shoulder = arm.getObjectByName('axis2_shoulder');
            const elbow = arm.getObjectByName('axis3_elbow');
            const wrist = arm.getObjectByName('axis4_wrist');
            
            // üéØ ÂèëÂ∞ÑÂâçÊú∫Ê¢∞ËáÇÂõõËΩ¥ËÅîÂä®ÂæÆË∞ÉÂä®ÁîªÔºà250msÔºâ
            if (base && shoulder && elbow && wrist) {
                // ‰øùÂ≠òÂΩìÂâçËßíÂ∫¶
                const initialAngles = {
                    base: base.rotation.y,
                    shoulder: shoulder.rotation.z,
                    elbow: elbow.rotation.z,
                    wrist: wrist.rotation.z
                };
                
                // ÂõõËΩ¥ËÅîÂä®Âä®‰ΩúÔºöËìÑÂäõ ‚Üí Á≤æÁ°ÆË∞ÉÊï¥ ‚Üí ÂèëÂ∞Ñ
                await new Promise(resolve => {
                    const startTime = Date.now();
                    const duration = 250;  // 250msÂõõËΩ¥Ë∞ÉÊï¥
                    
                    function animate() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        if (progress < 0.33) {
                            // Á¨¨‰∏ÄÈò∂ÊÆµ (0-33%)ÔºöÊâÄÊúâËΩ¥ÂêéÊí§ËìÑÂäõ
                            const t = progress * 3;
                            base.rotation.y = initialAngles.base - 0.03 * Math.sin(t * Math.PI);  // Âü∫Â∫ßÂ∑¶Âè≥ÂæÆË∞É
                            shoulder.rotation.z = initialAngles.shoulder + 0.06 * t;  // ËÇ©ÂÖ≥ËäÇÂêë‰∏äÊä¨
                            elbow.rotation.z = initialAngles.elbow + 0.04 * t;  // ËÇòÂÖ≥ËäÇÊî∂Áº©
                            wrist.rotation.z = initialAngles.wrist + 0.03 * t;  // ËÖïÂÖ≥ËäÇÂêéÂÄæ
                        } else if (progress < 0.67) {
                            // Á¨¨‰∫åÈò∂ÊÆµ (33-67%)ÔºöÁ≤æÁ°ÆÂØπÂáÜË∞ÉÊï¥
                            const t = (progress - 0.33) * 3;
                            base.rotation.y = initialAngles.base + 0.02 * Math.sin(t * Math.PI);  // Âü∫Â∫ßÂæÆË∞ÉÂØπÂáÜ
                            shoulder.rotation.z = initialAngles.shoulder + 0.06 * (1 - t) - 0.04 * t;  // ËÇ©ÂÖ≥ËäÇÂø´ÈÄü‰∏ãÂéã
                            elbow.rotation.z = initialAngles.elbow + 0.04 * (1 - t) - 0.03 * t;  // ËÇòÂÖ≥ËäÇ‰º∏Â±ï
                            wrist.rotation.z = initialAngles.wrist + 0.03 * (1 - t) - 0.02 * t;  // ËÖïÂÖ≥ËäÇÂâçÂÄæ
                        } else {
                            // Á¨¨‰∏âÈò∂ÊÆµ (67-100%)ÔºöÂèëÂ∞ÑÂßøÊÄÅÂπ∂ÂõûÂΩí
                            const t = (progress - 0.67) * 3;
                            base.rotation.y = initialAngles.base * (1 - t) + initialAngles.base * t;  // Âü∫Â∫ßÂΩí‰Ωç
                            shoulder.rotation.z = initialAngles.shoulder - 0.04 * (1 - t) + initialAngles.shoulder * t;  // ËÇ©ÂΩí‰Ωç
                            elbow.rotation.z = initialAngles.elbow - 0.03 * (1 - t) + initialAngles.elbow * t;  // ËÇòÂΩí‰Ωç
                            wrist.rotation.z = initialAngles.wrist - 0.02 * (1 - t) + initialAngles.wrist * t;  // ËÖïÂΩí‰Ωç
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Á°Æ‰øùÊÅ¢Â§çÂà∞ÂàùÂßãËßíÂ∫¶
                            base.rotation.y = initialAngles.base;
                            shoulder.rotation.z = initialAngles.shoulder;
                            elbow.rotation.z = initialAngles.elbow;
                            wrist.rotation.z = initialAngles.wrist;
                            resolve();
                        }
                    }
                    animate();
                });
            }
            
            // ÊâæÂà∞ÊøÄÂÖâÂèëÂ∞ÑÂô®
            let emitter = null;
            arm.traverse(child => {
                if (child.name === 'laser_emitter') {
                    emitter = child;
                }
            });
            
            if (!emitter) {
                showMessage('ÊøÄÂÖâÂèëÂ∞ÑÂô®Êú™ÊâæÂà∞', 'error');
                return;
            }
            
            // Êõ¥Êñ∞‰∏ñÁïåÂùêÊ†á
            cart.updateMatrixWorld(true);
            
            // Ëé∑ÂèñÂèëÂ∞Ñ‰ΩçÁΩÆ
            const startPos = new THREE.Vector3();
            emitter.getWorldPosition(startPos);
            
            // ÂàõÂª∫ÊøÄÂÖâÁâπÊïàÔºàÁõ¥Êé•ÊåáÂêëÁõÆÊ†áÔºâ
            createLaserBeam(startPos, target.position);
            SoundEffects.laser();
            
            // Ë∞ÉÁî®ÂêéÁ´ØAPI
            try {
                const response = await fetch('/api/action/laser', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plant_id: target.userData.id })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (result.type === 'weed') {
                        // ÊàêÂäüÊ∏ÖÈô§ÊùÇËçâ
                        showMessage(result.message, 'success');
                        await burnPlant(target);
                        SoundEffects.success();
            } else {
                        // ËØØ‰º§Ëî¨Ëèú
                        showMessage(result.message, 'error');
                        flashPlant(target);
                        shakeCamera();
                        SoundEffects.error();
                    }
                    
                    gameState.score += result.score_change;
                    updateUI();
                }
            } catch (error) {
                console.error('ÊøÄÂÖâÂèëÂ∞ÑÈîôËØØ:', error);
                showMessage('ÊøÄÂÖâÂèëÂ∞ÑÂ§±Ë¥•', 'error');
            }
        }
        
        // üéØ Ëá™Áî±ÂèëÂ∞ÑÊøÄÂÖâÔºàÊ≤øÁûÑÂáÜÁ∫øÊñπÂêëÔºâ
        async function fireFreeLaser() {
            console.log('üî• Ëá™Áî±ÂèëÂ∞ÑÊøÄÂÖâÔºÅ');
            
            const arm = cart.getObjectByName('robotic_arm');
            if (!arm) {
                showMessage('Êú∫Ê¢∞ËáÇÊú™ÊâæÂà∞', 'error');
                return;
            }
            
            // ÊâæÂà∞ÊøÄÂÖâÂèëÂ∞ÑÂô®
            let emitter = null;
            arm.traverse(child => {
                if (child.name === 'laser_emitter') {
                    emitter = child;
                }
            });
            
            if (!emitter) {
                showMessage('ÊøÄÂÖâÂèëÂ∞ÑÂô®Êú™ÊâæÂà∞', 'error');
                return;
            }
            
            // Êõ¥Êñ∞‰∏ñÁïåÂùêÊ†á
            cart.updateMatrixWorld(true);
            
            // Ëé∑ÂèñÂèëÂ∞Ñ‰ΩçÁΩÆ
            const startPos = new THREE.Vector3();
            emitter.getWorldPosition(startPos);
            
            // Ëé∑ÂèñÂèëÂ∞ÑÊñπÂêëÔºàÂêë‰∏ãÔºåÂõ†‰∏∫ÊøÄÂÖâÂûÇÁõ¥‰∫éËÖïÂÖ≥ËäÇÔºâ
            const direction = new THREE.Vector3(0, -1, 0);
            emitter.getWorldDirection(direction);
            direction.normalize();
            
            // ËÆ°ÁÆóÁªàÁÇπÔºàÊ≤øÊñπÂêëÂèëÂ∞Ñ10Á±≥Ôºâ
            const endPos = startPos.clone().add(direction.multiplyScalar(10));
            
            // ÂàõÂª∫ÊøÄÂÖâÁâπÊïà
            createLaserBeam(startPos, endPos);
                SoundEffects.laser();
                
            console.log('‚ú® Ëá™Áî±ÂèëÂ∞ÑÂÆåÊàêÔºÅÔºàÁ∫ØËßÜËßâÊïàÊûúÔºâ');
        }
        
        // ÁÇ´ÈÖ∑ÊøÄÂÖâÂÖâÊùüÁâπÊïà
        function createLaserBeam(start, end) {
            // 1. ÂàõÂª∫‰∏ªÂÖâÊùüÔºàÂúÜÊü±‰ΩìÔºâ
            const distance = start.distanceTo(end);
            const beamGeometry = new THREE.CylinderGeometry(0.015, 0.015, distance, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0
            });
            const beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
            
            // ÂÆö‰ΩçÂÖâÊùü
            const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            beamMesh.position.copy(midPoint);
            
            // ÊóãËΩ¨ÂÖâÊùüÊåáÂêëÁõÆÊ†á
            const direction = new THREE.Vector3().subVectors(end, start);
            beamMesh.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                direction.clone().normalize()
            );
            scene.add(beamMesh);
            
            // 2. ÂàõÂª∫Â§ñÂ±ÇÂÖâÊôï
            const glowGeometry = new THREE.CylinderGeometry(0.03, 0.03, distance, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff3333,
                transparent: true,
                opacity: 0
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.position.copy(midPoint);
            glowMesh.quaternion.copy(beamMesh.quaternion);
            scene.add(glowMesh);
            
            // 3. ÂàõÂª∫Á≤íÂ≠êÊïàÊûú
            const particleCount = 20;
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Ê≤øÁùÄÂÖâÊùüÈöèÊú∫ÂàÜÂ∏É
                const t = Math.random();
                particle.position.lerpVectors(start, end, t);
                
                // Ê∑ªÂä†ÈöèÊú∫ÂÅèÁßª
                particle.position.x += (Math.random() - 0.5) * 0.05;
                particle.position.y += (Math.random() - 0.5) * 0.05;
                particle.position.z += (Math.random() - 0.5) * 0.05;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // 4. Âä®ÁîªÊïàÊûú
            const duration = 400; // Âä®ÁîªÊó∂Èïø
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 0.2) {
                    // Âø´ÈÄüÊ∑°ÂÖ•Ôºà0-20%Ôºâ
                    const fadeIn = progress / 0.2;
                    beamMaterial.opacity = fadeIn * 0.9;
                    glowMaterial.opacity = fadeIn * 0.5;
                    particles.forEach(p => p.material.opacity = fadeIn * 0.8);
                } else if (progress < 1) {
                    // ÁºìÊÖ¢Ê∑°Âá∫Ôºà20-100%Ôºâ
                    const fadeOut = 1 - (progress - 0.2) / 0.8;
                    beamMaterial.opacity = fadeOut * 0.9;
                    glowMaterial.opacity = fadeOut * 0.5;
                    particles.forEach(p => p.material.opacity = fadeOut * 0.8);
                } else {
                    // Ê∏ÖÁêÜ
                    scene.remove(beamMesh);
                    scene.remove(glowMesh);
                    beamGeometry.dispose();
                    beamMaterial.dispose();
                    glowGeometry.dispose();
                    glowMaterial.dispose();
                    
                    particles.forEach(p => {
                        scene.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                    return;
                }
                
                // Á≤íÂ≠êÊâ©Êï£Âä®Áîª
                particles.forEach((p, i) => {
                    const t = (i / particleCount) + progress * 0.5;
                    const offset = Math.sin(t * Math.PI * 4) * 0.02;
                    p.scale.set(1 + offset, 1 + offset, 1 + offset);
                });
                
                requestAnimationFrame(animate);
            }
            animate();
            
            // 5. Ê∑ªÂä†ÂÜ≤ÂáªÊ≥¢ÊïàÊûúÔºàÂà∞ËææÁõÆÊ†áÊó∂Ôºâ
            setTimeout(() => {
                createImpactEffect(end);
            }, duration * 0.3);
        }
        
        // ÂÜ≤ÂáªÊ≥¢ÊïàÊûú
        function createImpactEffect(position) {
            const ringGeometry = new THREE.RingGeometry(0.05, 0.1, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.position.y += 0.01; // Áï•È´ò‰∫éÂú∞Èù¢
            ring.rotation.x = -Math.PI / 2; // Ê∞¥Âπ≥ÊîæÁΩÆ
            scene.add(ring);
            
            // Êâ©Êï£Âä®Áîª
            const startTime = Date.now();
            const duration = 300;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    // Êâ©Â§ßÂπ∂Ê∑°Âá∫
                    const scale = 1 + progress * 3;
                    ring.scale.set(scale, scale, scale);
                    ringMaterial.opacity = 1 - progress;
                    requestAnimationFrame(animate);
                    } else {
                    scene.remove(ring);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            }
            animate();
        }
        
        // üéØ ÂàõÂª∫ÊøÄÂÖâÁûÑÂáÜÁ∫ø
        function createLaserAimLine() {
            // Â¶ÇÊûúÂ∑≤Â≠òÂú®ÔºåÂÖàÁßªÈô§
            if (laserAimLine) {
                scene.remove(laserAimLine);
                laserAimLine.geometry.dispose();
                laserAimLine.material.dispose();
            }
            
            // ÂàõÂª∫‰∏ÄÊù°‰ªéÊøÄÂÖâÂèëÂ∞ÑÂô®ÊåáÂêëÂâçÊñπÁöÑÁ∫ø
            const points = [
                new THREE.Vector3(0, 0, 0),  // Ëµ∑ÁÇπÔºàÂ∞ÜÂú®update‰∏≠Êõ¥Êñ∞Ôºâ
                new THREE.Vector3(0, 0, -10) // ÁªàÁÇπÔºà10Á±≥ËøúÔºâ
            ];
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({
                color: 0xff0000,
                linewidth: 2,
                dashSize: 0.1,
                gapSize: 0.05,
                transparent: true,
                opacity: 0.6
            });
            
            laserAimLine = new THREE.Line(geometry, material);
            laserAimLine.computeLineDistances();
            scene.add(laserAimLine);
            laserAimLineEnabled = true;
            
            console.log('‚úÖ ÊøÄÂÖâÁûÑÂáÜÁ∫øÂ∑≤ÂàõÂª∫');
        }
        
        // üîÑ Êõ¥Êñ∞ÊøÄÂÖâÁûÑÂáÜÁ∫ø‰ΩçÁΩÆ
        function updateLaserAimLine() {
            if (!laserAimLine || !laserAimLineEnabled) return;
            
            const arm = cart.getObjectByName('robotic_arm');
            if (!arm) return;
            
            // ÊâæÂà∞ÊøÄÂÖâÂèëÂ∞ÑÂô®
            let emitter = null;
            arm.traverse(child => {
                if (child.name === 'laser_emitter') {
                    emitter = child;
                }
            });
            
            if (!emitter) return;
            
            // Êõ¥Êñ∞‰∏ñÁïåÁü©Èòµ
            cart.updateMatrixWorld(true);
            
            // Ëé∑ÂèñÊøÄÂÖâÂèëÂ∞ÑÂô®ÁöÑ‰∏ñÁïå‰ΩçÁΩÆÂíåÊñπÂêë
            const startPos = new THREE.Vector3();
            emitter.getWorldPosition(startPos);
            
            // Ëé∑ÂèñÂèëÂ∞ÑÂô®ÁöÑ‰∏ñÁïåÊñπÂêëÔºàÂêë‰∏ãÔºåÂõ†‰∏∫ÊøÄÂÖâÂûÇÁõ¥‰∫éËÖïÂÖ≥ËäÇÔºâ
            const direction = new THREE.Vector3(0, -1, 0);
            emitter.getWorldDirection(direction);
            direction.normalize();
            
            // ËÆ°ÁÆóÁªàÁÇπÔºàÊ≤øÁùÄÊñπÂêëÂª∂‰º∏10Á±≥Ôºâ
            const endPos = startPos.clone().add(direction.multiplyScalar(15));
            
            // Êõ¥Êñ∞Á∫øÁöÑÂá†‰Ωï‰Ωì
            const positions = laserAimLine.geometry.attributes.position.array;
            positions[0] = startPos.x;
            positions[1] = startPos.y;
            positions[2] = startPos.z;
            positions[3] = endPos.x;
            positions[4] = endPos.y;
            positions[5] = endPos.z;
            
            laserAimLine.geometry.attributes.position.needsUpdate = true;
            laserAimLine.computeLineDistances();
        }
        
        // ÁßªÈô§ÊøÄÂÖâÁûÑÂáÜÁ∫ø
        function removeLaserAimLine() {
            if (laserAimLine) {
                scene.remove(laserAimLine);
                laserAimLine.geometry.dispose();
                laserAimLine.material.dispose();
                laserAimLine = null;
                laserAimLineEnabled = false;
                console.log('‚ùå ÊøÄÂÖâÁûÑÂáÜÁ∫øÂ∑≤ÁßªÈô§');
            }
        }
        
        // ========== Ëá™Âä®Ë£ÖÂ§á‰ΩøÁî® ==========
        async function useAutoEquipment() {
            console.log('[DEBUG useAutoEquipment] 1. ÂºÄÂßãÊâßË°å useAutoEquipment()');
            const equipmentType = gameState.currentEquipment;
            console.log(`[DEBUG useAutoEquipment] 2. ÂΩìÂâçË£ÖÂ§áÁ±ªÂûã: ${equipmentType}`);
            const config = equipmentConfig[equipmentType];
            
            if (!config) {
                console.log('[DEBUG useAutoEquipment] ‚ùå ÈÖçÁΩÆ‰∏çÂ≠òÂú®ÔºåËøîÂõû');
                return;
            }
            
            console.log(`[DEBUG useAutoEquipment] 3. Ë£ÖÂ§áÈÖçÁΩÆ: interactionType=${config.interactionType}`);
            
            // Ê£ÄÊü•ÊòØÂê¶ÊòØËá™Âä®Ëß¶ÂèëË£ÖÂ§áÔºàÊâ´Êèè‰ª™„ÄÅÂúüÂ£§Êé¢Èíà„ÄÅÊí≠ÁßçÂô®„ÄÅÊú∫Ê¢∞ËáÇÔºâ
            if (config.interactionType !== 'auto' && config.interactionType !== 'scanner_cone') {
                console.log('[DEBUG useAutoEquipment] ‚ùå interactionType ‰∏çÂåπÈÖçÔºåËøîÂõû');
                return;
            }
            
            if (equipmentType === 'scanner') {
                // Êâ´Êèè‰ª™ÔºöÊâ´ÊèèÂâçÊñπÊâáÂΩ¢Âå∫Âüü
                console.log('[DEBUG useAutoEquipment] 4. Ë∞ÉÁî® useScannerAuto()');
                await useScannerAuto();
            } else if (equipmentType === 'soil') {
                // ÂúüÂ£§Êé¢ÈíàÔºöÊ£ÄÊµãËÑö‰∏ãÂúüÂ£§
                console.log('[DEBUG useAutoEquipment] 4. Ë∞ÉÁî® useSoilProbeAuto()');
                await useSoilProbeAuto();
            } else if (equipmentType === 'planter') {
                // Êí≠ÁßçÂô®ÔºöÂú®ÈôÑËøëÁ©∫Âú∞Êí≠Áßç
                console.log('[DEBUG useAutoEquipment] 4. Ë∞ÉÁî® usePlantAuto()');
                await usePlantAuto();
            } else if (equipmentType === 'arm') {
                // Êú∫Ê¢∞ËáÇÔºöÊî∂Ëé∑ÊúÄËøëÁöÑÊàêÁÜüÊ§çÁâ©
                console.log('[DEBUG useAutoEquipment] 4. Ë∞ÉÁî® useArmHarvestAuto()');
                await useArmHarvestAuto();
                console.log('[DEBUG useAutoEquipment] 5. useArmHarvestAuto() ËøîÂõû');
            } else {
                console.log(`[DEBUG useAutoEquipment] ‚ùå Êú™Áü•Ë£ÖÂ§áÁ±ªÂûã: ${equipmentType}`);
            }
            console.log('[DEBUG useAutoEquipment] 6. useAutoEquipment() ÊâßË°åÂÆåÊàê');
        }
        
        // Êâ´Êèè‰ª™ËåÉÂõ¥Êâ´ÊèèÔºàÁé∞ÂÆûÊ®°ÊãüÔºâ
        async function useScannerAuto() {
            // Ëé∑ÂèñÊâ´ÊèèËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©
            const config = equipmentConfig.scanner;
            const scanRadius = config.range;  // ‰ªéÈÖçÁΩÆËØªÂèñÊâ´ÊèèÂçäÂæÑ
            const scanAngle = config.scanAngle;  // ‰ªéÈÖçÁΩÆËØªÂèñÊâ´ÊèèËßíÂ∫¶
            
            const plants = getPlantsInScannerRange(scanRadius, scanAngle);
            
            if (plants.length === 0) {
                showMessage('Êâ´ÊèèËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊ§çÁâ©', 'info');
                return;
            }
            
            // Êí≠ÊîæÊâ´ÊèèÈü≥Êïà
            SoundEffects.scan();
            
            // ÊòæÁ§∫Êâ´ÊèèËåÉÂõ¥ÂúàÔºàËßÜËßâÂèçÈ¶àÔºâ
            showScannerRange(scanRadius, scanAngle);
            
            // ÊâπÈáèËØ∑Ê±ÇÂêéÁ´ØËé∑ÂèñÊ§çÁâ©‰ø°ÊÅØ
            const scannedPlants = [];
            for (const plant of plants) {
                const plantData = plant.userData;
                
                try {
                    const response = await fetch('/api/action/scan', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plantData.id })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        scannedPlants.push({
                            mesh: plant,
                            data: result.plant
                        });
                    }
                } catch (error) {
                    console.error('Scan error:', error);
                }
            }
            
            // È´ò‰∫ÆÊòæÁ§∫ÊâÄÊúâË¢´Êâ´ÊèèÁöÑÊ§çÁâ©
            highlightScannedPlants(scannedPlants);
            
            // ÊòæÁ§∫Êâ´ÊèèÁªìÊûúÈù¢Êùø
            showScanResultsPanel(scannedPlants);
            
            updateUI();
        }
        
        // Ëé∑ÂèñÊâ´Êèè‰ª™ËåÉÂõ¥ÂÜÖÁöÑÊ§çÁâ©ÔºàÊâáÂΩ¢Âå∫ÂüüÔºâ
        function getPlantsInScannerRange(radius, scanAngle) {
            const plants = [];
            const cartForward = new THREE.Vector3(0, 0, -1);
            cartForward.applyQuaternion(cart.quaternion);
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id) return;
                if (!child.visible) return;
                
                // ËÆ°ÁÆóÊ§çÁâ©Áõ∏ÂØπÂ∞èËΩ¶ÁöÑ‰ΩçÁΩÆ
                const offset = child.position.clone().sub(cart.position);
                
                // Ê£ÄÊü•Ë∑ùÁ¶ªÔºàÂú®Êâ´ÊèèÂçäÂæÑÂÜÖÔºâ
                if (offset.length() > radius) return;
                
                // Ê£ÄÊü•ËßíÂ∫¶ÔºàÂú®Êâ´ÊèèÊâáÂΩ¢ÂÜÖÔºâ
                offset.y = 0;  // Âè™ËÄÉËôëÊ∞¥Âπ≥ËßíÂ∫¶
                const angle = cartForward.angleTo(offset);
                if (angle > scanAngle / 2) return;  // ÂçäËßí
                
                plants.push(child);
            });
            
            return plants;
        }
        
        // ÊòæÁ§∫Êâ´ÊèèËåÉÂõ¥ÂúàÔºàËßÜËßâÂèçÈ¶àÔºâ
        function showScannerRange(radius, scanAngle) {
            // ÁßªÈô§ÊóßÁöÑÊâ´ÊèèËåÉÂõ¥Âúà
            const oldRange = scene.getObjectByName('scanner_range');
            if (oldRange) scene.remove(oldRange);
            
            // ÂàõÂª∫Êâ´ÊèèËåÉÂõ¥ÊâáÂΩ¢
            const segments = 32;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            // ‰∏≠ÂøÉÁÇπ
            vertices.push(0, 0.05, 0);
            
            // ÊâáÂΩ¢ÂºßÁ∫ø
            for (let i = 0; i <= segments; i++) {
                const angle = -scanAngle / 2 + (scanAngle * i / segments);
                const x = Math.sin(angle) * radius;
                const z = -Math.cos(angle) * radius;
                vertices.push(x, 0.05, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00BFFF, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            const scanRange = new THREE.Line(geometry, material);
            scanRange.name = 'scanner_range';
            scanRange.position.copy(cart.position);
            scanRange.quaternion.copy(cart.quaternion);
            
            scene.add(scanRange);
            
            // 2ÁßíÂêéÊ∑°Âá∫Ê∂àÂ§±
            setTimeout(() => {
                if (scanRange.parent) {
                    scanRange.material.opacity = 0.4;
                    setTimeout(() => {
                        scene.remove(scanRange);
                        scanRange.geometry.dispose();
                        scanRange.material.dispose();
                    }, 1000);
                }
            }, 2000);
        }
        
        // È´ò‰∫ÆÊòæÁ§∫Ë¢´Êâ´ÊèèÁöÑÊ§çÁâ©
        function highlightScannedPlants(scannedPlants) {
            scannedPlants.forEach(({ mesh, data }) => {
                // 4Ëâ≤ÂàÜÁ±ªÁ≥ªÁªü
                let highlightColor;
                if (data.is_weed) {
                    // ÊùÇËçâ - Á∫¢Ëâ≤
                    highlightColor = 0xFF0000;
                } else if (data.has_pests) {
                    // ÊúâÂÆ≥Ëô´ - ÈªÑËâ≤Ôºà‰ºòÂÖàÁ∫ßÈ´ò‰∫éÂÅ•Â∫∑Â∫¶Ôºâ
                    highlightColor = 0xFFD700;
                } else if (data.health >= 70) {
                    // ÂÅ•Â∫∑ - ÁªøËâ≤
                    highlightColor = 0x00FF00;
                } else {
                    // ‰∏çÂÅ•Â∫∑ - Ê∑±Ê©ôËâ≤
                    highlightColor = 0xFF8C00;
                }
                
                // ÂàõÂª∫È´ò‰∫ÆÂúà
                const ringGeometry = new THREE.RingGeometry(0.15, 0.2, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: highlightColor, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(mesh.position.x, 0.02, mesh.position.z);
                ring.name = 'scan_highlight';
                scene.add(ring);
                
                // 3ÁßíÂêéÁßªÈô§
                setTimeout(() => {
                    scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                }, 3000);
            });
        }
        
        // ÊòæÁ§∫Êâ´ÊèèÁªìÊûúÈù¢Êùø
        function showScanResultsPanel(scannedPlants) {
            // ÁßªÈô§ÊóßÈù¢Êùø
            const oldPanel = document.getElementById('scan-results-panel');
            if (oldPanel) oldPanel.remove();
            
            // ÁªüËÆ°Êï∞ÊçÆÔºà4Á±ªÂàÜÁ±ªÔºâ
            const vegetables = scannedPlants.filter(p => p.data.is_vegetable);
            const weeds = scannedPlants.filter(p => p.data.is_weed);
            
            // ÂÅ•Â∫∑ = Ëî¨Ëèú ‰∏î health >= 70 ‰∏î Êó†ÂÆ≥Ëô´
            const healthy = vegetables.filter(p => p.data.health >= 70 && !p.data.has_pests);
            
            // ÊúâËô´ = Ëî¨Ëèú ‰∏î ÊúâÂÆ≥Ëô´ÔºàÊó†ËÆ∫ÂÅ•Â∫∑Â∫¶Ôºâ
            const hasPests = vegetables.filter(p => p.data.has_pests);
            
            // ‰∏çÂÅ•Â∫∑ = Ëî¨Ëèú ‰∏î health < 70 ‰∏î Êó†ÂÆ≥Ëô´
            const unhealthy = vegetables.filter(p => p.data.health < 70 && !p.data.has_pests);
            
            // ÂàõÂª∫ÁªìÊûúÈù¢Êùø
            const panelHTML = `
                <div style="position: fixed; bottom: 180px; right: 20px; 
                     background: rgba(0, 0, 0, 0.85); padding: 15px; border-radius: 12px; 
                     border: 2px solid #00BFFF; min-width: 320px; max-width: 380px;
                     max-height: 500px; overflow-y: auto;
                     box-shadow: 0 0 20px rgba(0, 191, 255, 0.5); 
                     z-index: 1000; backdrop-filter: blur(5px);
                     animation: slideInRight 0.3s ease-out;">
                    
                    <!-- Ê†áÈ¢ò -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #00BFFF; padding-bottom: 8px;">
                        <div style="color: #00BFFF; font-weight: bold; font-size: 16px;">
                            üîµ Â§öÂÖâË∞±Êâ´ÊèèÊä•Âëä
                        </div>
                        <div style="color: #00BFFF; font-size: 18px; font-weight: bold;">
                            ${scannedPlants.length} Ê†™
                        </div>
                    </div>
                    
                    <!-- ÁªüËÆ°Âç°ÁâáÔºà4Á±ªÔºâ-->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <div style="background: rgba(0, 255, 0, 0.15); padding: 8px; border-radius: 8px; border-left: 3px solid #00FF00;">
                            <div style="color: #90EE90; font-size: 12px;">‚úÖ ÂÅ•Â∫∑Ëî¨Ëèú</div>
                            <div style="color: #00FF00; font-size: 20px; font-weight: bold;">${healthy.length}</div>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.15); padding: 8px; border-radius: 8px; border-left: 3px solid #FFD700;">
                            <div style="color: #FFD700; font-size: 12px;">üêõ ÊúâÂÆ≥Ëô´</div>
                            <div style="color: #FFD700; font-size: 20px; font-weight: bold;">${hasPests.length}</div>
                        </div>
                        <div style="background: rgba(255, 140, 0, 0.15); padding: 8px; border-radius: 8px; border-left: 3px solid #FF8C00;">
                            <div style="color: #FFA07A; font-size: 12px;">‚ö†Ô∏è ‰∏çÂÅ•Â∫∑</div>
                            <div style="color: #FF8C00; font-size: 20px; font-weight: bold;">${unhealthy.length}</div>
                        </div>
                        <div style="background: rgba(255, 0, 0, 0.15); padding: 8px; border-radius: 8px; border-left: 3px solid #FF0000;">
                            <div style="color: #FF6B6B; font-size: 12px;">üåø ÊùÇËçâ</div>
                            <div style="color: #FF0000; font-size: 20px; font-weight: bold;">${weeds.length}</div>
                        </div>
                    </div>
                    
                    <!-- ËØ¶ÁªÜÂàóË°® -->
                    <div style="margin-top: 12px;">
                        <div style="color: rgba(255, 255, 255, 0.7); font-size: 12px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 4px;">
                            ËØ¶ÁªÜ‰ø°ÊÅØ
                        </div>
                        ${scannedPlants.map((p, index) => {
                            const data = p.data;
                            // 4Ëâ≤ÂàÜÁ±ªÈÄªËæë
                            let statusColor, statusIcon, statusText;
                            if (data.is_weed) {
                                // ÊùÇËçâ - Á∫¢Ëâ≤
                                statusColor = '#FF0000';
                                statusIcon = 'üåø';
                                statusText = 'ÊùÇËçâ';
                            } else if (data.has_pests) {
                                // ÊúâÂÆ≥Ëô´ - ÈªÑËâ≤Ôºà‰ºòÂÖàÁ∫ßÈ´ò‰∫éÂÅ•Â∫∑Â∫¶Ôºâ
                                statusColor = '#FFD700';
                                statusIcon = 'üêõ';
                                statusText = 'ÊúâÂÆ≥Ëô´';
                            } else if (data.health >= 70) {
                                // ÂÅ•Â∫∑ - ÁªøËâ≤
                                statusColor = '#00FF00';
                                statusIcon = '‚úÖ';
                                statusText = 'ÂÅ•Â∫∑';
                            } else {
                                // ‰∏çÂÅ•Â∫∑ - Ê©ôËâ≤
                                statusColor = '#FF8C00';
                                statusIcon = '‚ö†Ô∏è';
                                statusText = '‰∏çÂÅ•Â∫∑';
                            }
                            
                            return `
                                <div style="background: rgba(255, 255, 255, 0.05); padding: 8px; border-radius: 6px; 
                                     margin-bottom: 6px; border-left: 3px solid ${statusColor}; font-size: 12px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <div style="color: rgba(255,255,255,0.9); font-weight: bold;">
                                            #${index + 1} ${data.type}
                                        </div>
                                        <div style="color: ${statusColor};">
                                            ${statusIcon} ${statusText}
                                        </div>
                                    </div>
                                    ${!data.is_weed ? `
                                        <div style="color: rgba(255,255,255,0.7); display: flex; justify-content: space-between;">
                                            <span>ÂÅ•Â∫∑Â∫¶: <span style="color: ${statusColor};">${data.health}%</span></span>
                                            <span>ÁîüÈïø: Á¨¨${data.growth_stage}Èò∂ÊÆµ</span>
                                        </div>
                                        ${data.has_pests ? `<div style="color: #FF6347; margin-top: 4px;">üêõ ÂèëÁé∞ÂÆ≥Ëô´ (${data.pests_count}Âè™)</div>` : ''}
                                    ` : `
                                        <div style="color: #FF6B6B;">Âª∫ËÆÆÔºö‰ΩøÁî®ÊøÄÂÖâÈô§ËçâÂô®Ê∏ÖÈô§</div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <!-- ÂÖ≥Èó≠ÊèêÁ§∫ -->
                    <div style="text-align: center; margin-top: 10px; font-size: 11px; color: rgba(255, 255, 255, 0.5);">
                        5ÁßíÂêéËá™Âä®ÂÖ≥Èó≠
                    </div>
                </div>
            `;
            
            const panel = document.createElement('div');
            panel.innerHTML = panelHTML;
            panel.id = 'scan-results-panel';
            document.body.appendChild(panel);
            
            // 5ÁßíÂêéËá™Âä®ÂÖ≥Èó≠
            setTimeout(() => {
                if (panel.parentElement) {
                    panel.style.transition = 'opacity 0.4s, transform 0.4s';
                    panel.style.opacity = '0';
                    panel.style.transform = 'translateX(400px)';
                    setTimeout(() => panel.remove(), 400);
                }
            }, 5000);
        }
        
        // ÂúüÂ£§Êé¢ÈíàËá™Âä®Ê£ÄÊµã
        async function useSoilProbeAuto() {
            // ÊâæÂà∞ÊúÄËøëÁöÑËÑö‰∏ãÊ§çÁâ©ÔºàÁî®‰∫éËé∑ÂèñÂúüÂ£§Êï∞ÊçÆÔºâ
            let nearestPlant = null;
            let minDist = Infinity;
            
            const config = equipmentConfig.soil;
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id) return;
                const dist = cart.position.distanceTo(child.position);
                if (dist < config.range && dist < minDist) {
                    minDist = dist;
                    nearestPlant = child;
                }
            });
            
            if (!nearestPlant) {
                showMessage('ËÑö‰∏ãÊ≤°ÊúâÊ§çÁâ©', 'info');
                return;
            }
            
            // ‰ΩøÁî®ÂéüÊúâÁöÑÂúüÂ£§Ê£ÄÊµãÈÄªËæë
            SoundEffects.scan();
            createSoilDetectEffect(nearestPlant.position);
            
            try {
                const response = await fetch('/api/action/soil_detect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plant_id: nearestPlant.userData.id })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSoilInfo(result);
                    updateUI();
                } else {
                    showMessage(result.message, 'error');
                }
            } catch (error) {
                console.error('Soil detect error:', error);
                showMessage('Ê£ÄÊµãÂ§±Ë¥•', 'error');
            }
        }
        
        // ========== Âñ∑Ê¥íÂÜúËçØÔºàËá™Âä®Ôºâ ==========
        async function useSprayAuto() {
            const config = equipmentConfig.spray;
            
            // Ëé∑ÂèñÊâáÂΩ¢ËåÉÂõ¥ÂÜÖÁöÑÊ§çÁâ©
            const plantsInRange = [];
            const cartPos = cart.position;
            const cartRotation = cart.rotation.y;
            const coneAngle = Math.PI / 3;  // 60Â∫¶ÊâáÂΩ¢
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id || child.userData.is_removed) return;
                
                const dist = cartPos.distanceTo(child.position);
                if (dist > config.range) return;
                
                // ËÆ°ÁÆóËßíÂ∫¶
                const dx = child.position.x - cartPos.x;
                const dz = child.position.z - cartPos.z;
                const angle = Math.atan2(dx, dz);
                let deltaAngle = angle - cartRotation;
                
                // Ê†áÂáÜÂåñËßíÂ∫¶Âà∞ [-œÄ, œÄ]
                while (deltaAngle > Math.PI) deltaAngle -= Math.PI * 2;
                while (deltaAngle < -Math.PI) deltaAngle += Math.PI * 2;
                
                // Ê£ÄÊü•ÊòØÂê¶Âú®ÊâáÂΩ¢ÂÜÖ
                if (Math.abs(deltaAngle) <= coneAngle / 2) {
                    plantsInRange.push(child);
                }
            });
            
            if (plantsInRange.length === 0) {
                showMessage('ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊ§çÁâ©', 'info');
                return;
            }
            
            // Êí≠ÊîæÈü≥ÊïàÂíåÁâπÊïà
            SoundEffects.spray();
            plantsInRange.forEach(plant => {
                createSprayEffect(plant.position);
            });
            
            // ÂØπÊØè‰∏™Ê§çÁâ©Ë∞ÉÁî®Âñ∑Ê¥íAPI
            let successCount = 0;
            let pestsEliminated = 0;
            let coinsEarned = 0;
            
            for (const plant of plantsInRange) {
                try {
                    const response = await fetch('/api/action/spray_pesticide', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plant.userData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success && result.pests_found) {
                        successCount++;
                        pestsEliminated += result.pests_eliminated;
                        coinsEarned += result.coins_earned;
                        
                        // Êõ¥Êñ∞Ê§çÁâ©Êï∞ÊçÆ
                        plant.userData.has_pests = false;
                        plant.userData.pests_count = 0;
                        plant.userData.health = Math.min(100, plant.userData.health + result.health_recovery);
                    }
                } catch (error) {
                    console.error('Spray error:', error);
                }
            }
            
            // ÊòæÁ§∫ÁªìÊûú
            if (successCount > 0) {
                showMessage(`Âñ∑Ê¥íÊàêÂäüÔºÅÊ∂àÁÅ≠${pestsEliminated}Âè™ÂÆ≥Ëô´Ôºå+${coinsEarned}ÈáëÂ∏Å`, 'success');
                SoundEffects.success();
            } else {
                showMessage('ËåÉÂõ¥ÂÜÖÁöÑÊ§çÁâ©ÈÉΩÊ≤°ÊúâÂÆ≥Ëô´', 'info');
            }
            
            updateUI();
        }
        
        // ========== Ê§çÁâ©ÊàêÈïøÁâπÊïà ==========
        function createGrowthEffect(plant, oldStage, newStage) {
            const position = plant.position.clone();
            const plantData = plant.userData;
            
            // „Äê1„ÄëÈáëËâ≤Á≤íÂ≠êÁàÜÂèë
            const particleCount = 30;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,  // ÈáëËâ≤
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                particle.position.copy(position);
                particle.position.y += 0.05;
                
                // ÈöèÊú∫ÊñπÂêëÂíåÈÄüÂ∫¶
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 0.5;
                particle.velocity = new THREE.Vector3(
                    Math.cos(angle) * speed,
                    1 + Math.random() * 1.5,  // Âêë‰∏ä
                    Math.sin(angle) * speed
                );
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Á≤íÂ≠êÂä®Áîª
            let particleTime = 0;
            const particleInterval = setInterval(() => {
                particleTime += 0.05;
                
                particles.forEach(particle => {
                    // Êõ¥Êñ∞‰ΩçÁΩÆ
                    particle.position.x += particle.velocity.x * 0.05;
                    particle.position.y += particle.velocity.y * 0.05;
                    particle.position.z += particle.velocity.z * 0.05;
                    
                    // ÈáçÂäõ
                    particle.velocity.y -= 2 * 0.05;
                    
                    // Ê∑°Âá∫
                    particle.material.opacity = Math.max(0, 1 - particleTime * 2);
                });
                
                if (particleTime >= 0.5) {
                    clearInterval(particleInterval);
                    particles.forEach(p => {
                        scene.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                }
            }, 50);
            
            // „Äê2„ÄëÂÖâÁéØÊâ©Êï£ÊïàÊûú
            const ringGeometry = new THREE.RingGeometry(0.05, 0.08, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FF00,  // ÁªøËâ≤ÂÖâÁéØ
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(position.x, 0.02, position.z);
            scene.add(ring);
            
            // ÂÖâÁéØÂä®Áîª
            let ringTime = 0;
            const ringInterval = setInterval(() => {
                ringTime += 0.05;
                
                // Êâ©Êï£
                const scale = 1 + ringTime * 4;
                ring.scale.set(scale, scale, 1);
                
                // Ê∑°Âá∫
                ring.material.opacity = Math.max(0, 0.8 - ringTime);
                
                if (ringTime >= 0.8) {
                    clearInterval(ringInterval);
                    scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                }
            }, 50);
            
            // „Äê3„ÄëÊ§çÁâ©Ê®°ÂûãÈáçÂª∫ÂíåÂºπÊÄßÂèòÂåñÂä®Áîª
            // ÂÖàËÆ©Ê§çÁâ©Áº©Â∞è
            const originalScale = plant.scale.clone();
            let modelReplaced = false;  // Ê†áËÆ∞Ê®°ÂûãÊòØÂê¶Â∑≤ÊõøÊç¢
            
            let scaleTime = 0;
            const scaleInterval = setInterval(() => {
                scaleTime += 0.05;
                const t = Math.min(1, scaleTime / 0.8);  // 0.8ÁßíÂÆåÊàê
                
                if (t < 0.2) {
                    // Ââç0.16ÁßíÔºöÁº©Â∞èÂà∞0.8ÂÄç
                    const shrink = 1 - (t / 0.2) * 0.2;
                    plant.scale.copy(originalScale).multiplyScalar(shrink);
                } else if (!modelReplaced && t >= 0.2) {
                    // Âú®Áº©Â∞èÂà∞ÊúÄÂ∞èÂêéÁ¨¨‰∏ÄÊ¨°ÔºåÈáçÂª∫Ê§çÁâ©Ê®°Âûã
                    modelReplaced = true;
                    
                    // Ê∏ÖÈô§ÊóßÊ®°ÂûãÁöÑÊâÄÊúâÂ≠êÂØπË±°
                    while (plant.children.length > 0) {
                        const child = plant.children[0];
                        plant.remove(child);
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    }
                    
                    // ÂàõÂª∫Êñ∞ÁöÑÊ§çÁâ©Ê®°ÂûãÔºà‰ΩøÁî®Êñ∞ÁöÑgrowth_stageÔºâ
                    const newPlantModel = createPlantModel(plantData);
                    newPlantModel.children.forEach(child => {
                        plant.add(child.clone());
                    });
                    
                    // Â§ÑÁêÜ‰∏¥Êó∂Ê®°Âûã
                    while (newPlantModel.children.length > 0) {
                        const child = newPlantModel.children[0];
                        newPlantModel.remove(child);
                    }
                    
                    plant.scale.copy(originalScale).multiplyScalar(0.8);
                } else if (modelReplaced) {
                    // Âêé0.64ÁßíÔºöÂºπÊÄßÊîæÂ§ßÂà∞Ê≠£Â∏∏Â§ßÂ∞è
                    const growT = (t - 0.2) / 0.8;
                    const eased = easeOutElastic(growT);
                    const targetScale = 0.8 + eased * 0.2;  // ‰ªé0.8Âà∞1.0
                    plant.scale.copy(originalScale).multiplyScalar(targetScale);
                }
                
                if (t >= 1) {
                    clearInterval(scaleInterval);
                    plant.scale.copy(originalScale);  // Á°Æ‰øùÊúÄÁªàÊòØÂéüÂßãÂ§ßÂ∞è
                }
            }, 50);
            
            // „Äê4„ÄëËû∫Êóã‰∏äÂçáÂÖâÁÇπ
            const spiralParticles = [];
            for (let i = 0; i < 10; i++) {
                const glowGeometry = new THREE.SphereGeometry(0.01, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFF00,  // ÈªÑËâ≤
                    transparent: true,
                    opacity: 1
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                
                glow.angle = (i / 10) * Math.PI * 2;
                glow.height = 0;
                
                scene.add(glow);
                spiralParticles.push(glow);
            }
            
            let spiralTime = 0;
            const spiralInterval = setInterval(() => {
                spiralTime += 0.05;
                
                spiralParticles.forEach((glow, index) => {
                    const radius = 0.1;
                    glow.angle += 0.15;
                    glow.height += 0.02;
                    
                    glow.position.x = position.x + Math.cos(glow.angle) * radius;
                    glow.position.y = position.y + glow.height;
                    glow.position.z = position.z + Math.sin(glow.angle) * radius;
                    
                    glow.material.opacity = Math.max(0, 1 - spiralTime * 2);
                });
                
                if (spiralTime >= 0.5) {
                    clearInterval(spiralInterval);
                    spiralParticles.forEach(p => {
                        scene.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                }
            }, 50);
            
            // „Äê5„Äë3DÊµÆÂä®ÊñáÂ≠óÊèêÁ§∫
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // ÁªòÂà∂ÊñáÂ≠ó
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 48px Arial';
            context.fillStyle = '#FFD700';
            context.strokeStyle = '#000000';
            context.lineWidth = 4;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            const text = `Èò∂ÊÆµ ${oldStage} ‚Üí ${newStage}`;
            context.strokeText(text, 128, 40);
            context.fillText(text, 128, 40);
            
            context.font = 'bold 36px Arial';
            context.fillStyle = '#00FF00';
            context.strokeText('‚ú® ÊàêÈïø ‚ú®', 128, 90);
            context.fillText('‚ú® ÊàêÈïø ‚ú®', 128, 90);
            
            // ÂàõÂª∫Á∫πÁêÜÂíåÁ≤æÁÅµ
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(position.x, position.y + 0.3, position.z);
            sprite.scale.set(0.5, 0.25, 1);
            scene.add(sprite);
            
            // ÊñáÂ≠ó‰∏äÊµÆÂπ∂Ê∑°Âá∫
            let textTime = 0;
            const textInterval = setInterval(() => {
                textTime += 0.05;
                
                sprite.position.y += 0.01;
                sprite.material.opacity = Math.max(0, 1 - textTime * 0.5);
                
                if (textTime >= 2) {
                    clearInterval(textInterval);
                    scene.remove(sprite);
                    sprite.material.map.dispose();
                    sprite.material.dispose();
                }
            }, 50);
            
            // „Äê6„ÄëÊí≠ÊîæÊàêÈïøÈü≥Êïà
            SoundEffects.growth();
        }
        
        // ÂºπÊÄßÁºìÂä®ÂáΩÊï∞ÔºàÁî®‰∫éÊ§çÁâ©ÂºπË∑≥ÊïàÊûúÔºâ
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }
        
        // ========== ÊµáÊ∞¥ÔºàËá™Âä®Ôºâ ==========
        async function useWaterAuto() {
            const config = equipmentConfig.water;
            
            // üåø Ëé∑ÂèñÂë®Âõ¥ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÊ§çÁâ©ÔºàÂåÖÊã¨ÊùÇËçâÔºÅÔºâ
            const plantsInRange = [];
            const cartPos = cart.position;
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id || child.userData.is_removed) return;
                // ÁßªÈô§‰∫Ü "Âè™ÊµáÊ∞¥Ëî¨Ëèú" ÁöÑÈôêÂà∂ÔºåÊùÇËçâ‰πü‰ºöË¢´ÊµáÊ∞¥ÔºÅ
                
                const dist = cartPos.distanceTo(child.position);
                if (dist <= config.range) {
                    plantsInRange.push(child);
                }
            });
            
            if (plantsInRange.length === 0) {
                showMessage('ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊ§çÁâ©', 'info');
                return;
            }
            
            // Êí≠ÊîæÈü≥ÊïàÂíåÁâπÊïà
            SoundEffects.water();
            plantsInRange.forEach(plant => {
                createWaterEffect(plant.position);
            });
            
            // ÂØπÊØè‰∏™Ê§çÁâ©Ë∞ÉÁî®ÊµáÊ∞¥API
            let successCount = 0;
            let growthCount = 0;
            let weedGrowthCount = 0;
            const allSpreadInfo = [];
            
            for (const plant of plantsInRange) {
                try {
                    const response = await fetch('/api/action/water', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ plant_id: plant.userData.id })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        successCount++;
                        
                        // üå± ÁßçÂ≠êÂèëËäΩÁâπÊÆäÂ§ÑÁêÜ
                        if (result.germinated) {
                            // ÁßçÂ≠êÂèòÊàêÊ§çÁâ©
                            plant.userData.is_seed = false;
                            plant.userData.is_vegetable = !result.is_weed;
                            plant.userData.is_weed = result.is_weed;
                            plant.userData.growth_stage = 1;
                            plant.userData.health = result.health;
                            
                            // ÈáçÂª∫3DÊ®°ÂûãÔºà‰ªéÁßçÂ≠êÂèòÊàêÊ§çÁâ©Ôºâ
                            plant.children.forEach(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => m.dispose());
                                    } else {
                                        child.material.dispose();
                                    }
                                }
                            });
                            plant.children = [];
                            
                            // ÂàõÂª∫Êñ∞ÁöÑÊ§çÁâ©Ê®°Âûã
                            const newModel = createPlantModel({
                                is_weed: result.is_weed,
                                is_vegetable: !result.is_weed,
                                growth_stage: 1,
                                health: result.health
                            });
                            newModel.children.forEach(child => plant.add(child));
                            
                            // ÂàõÂª∫ÂèëËäΩÁâπÊïà
                            createGerminationEffect(plant.position, result.is_weed);
                            
                            continue;  // Ë∑≥ËøáÂêéÁª≠ÁöÑÊàêÈïøÈÄªËæë
                        }
                        
                        // Êõ¥Êñ∞Ê§çÁâ©Êï∞ÊçÆ
                        const oldStage = plant.userData.growth_stage;
                        const newStage = result.growth_stage || plant.userData.growth_stage;
                        plant.userData.growth_stage = newStage;
                        plant.userData.soil_moisture = plant.userData.soil_moisture + (result.moisture_increase || 0);
                        if (!result.is_weed) {
                            plant.userData.health = Math.min(100, plant.userData.health + (result.health_recovery || 0));
                        }
                        
                        // Ê£ÄÊü•ÊòØÂê¶ÁúüÁöÑÊàêÈïø‰∫Ü
                        // Êõ¥Êñ∞Ê§çÁâ©ÂÅ•Â∫∑Â∫¶
                        if (result.health !== undefined) {
                            plant.userData.health = result.health;
                            // üçé Âä®ÊÄÅÊõ¥Êñ∞ÊûúÂÆûÊï∞ÈáèÊ†áÁ≠æ
                            updateFruitLabel(plant, result.health);
                        }
                        
                        if (result.stage_changed && newStage > oldStage) {
                            if (result.is_weed) {
                                weedGrowthCount++;
                            } else {
                                growthCount++;
                            }
                            // Ëß¶ÂèëÊàêÈïøÁâπÊïà
                            createGrowthEffect(plant, oldStage, newStage);
                        }
                        
                        // üåø Â§ÑÁêÜÊùÇËçâÊâ©Êï£
                        if (result.weed_spread && result.weed_spread.length > 0) {
                            allSpreadInfo.push(...result.weed_spread);
                        }
                    }
                } catch (error) {
                    console.error('Water error:', error);
                }
            }
            
            // Â§ÑÁêÜÊâÄÊúâÊùÇËçâÊâ©Êï£
            if (allSpreadInfo.length > 0) {
                handleWeedSpread(allSpreadInfo);
            }
            
            // ÊòæÁ§∫ÁªìÊûú
            if (successCount > 0) {
                let message = `ÊµáÊ∞¥${successCount}Ê†™`;
                if (growthCount > 0) {
                    message += ` | üåø${growthCount}Ê†™Ëî¨ËèúÊàêÈïø`;
                }
                if (weedGrowthCount > 0) {
                    message += ` | ‚ö†Ô∏è${weedGrowthCount}Ê†™ÊùÇËçâÊàêÈïø`;
                }
                if (allSpreadInfo.length > 0) {
                    message += ` | üö®${allSpreadInfo.length}ÂùóÂú∞Ë¢´‰æµÂç†ÔºÅ`;
                }
                showMessage(message, allSpreadInfo.length > 0 ? 'error' : 'success');
                if (allSpreadInfo.length === 0) {
                    SoundEffects.success();
                } else {
                    SoundEffects.error();
                }
            } else {
                showMessage('ËåÉÂõ¥ÂÜÖÁöÑÊ§çÁâ©ÈÉΩÂ∑≤ÊàêÁÜü', 'info');
            }
            
            updateUI();
        }
        
        // ========== Êí≠ÁßçÔºàÂçïÁÇπÔºâ ==========
        async function usePlantAuto() {
            const config = equipmentConfig.planter;
            
            // üéØ ÊâæÂà∞Â∞èËΩ¶ËÑö‰∏ãÊúÄËøëÁöÑ‰∏ÄÂùóÂú∞ÔºàÂçïÁÇπÊí≠ÁßçÔºåÁ¨¶ÂêàÁé∞ÂÆûÈÄªËæëÔºâ
            let closestPlot = null;
            let minDist = Infinity;
            const cartPos = cart.position;
            
            farm.children.forEach(child => {
                if (!child.userData || !child.userData.id || child.userData.is_removed) return;
                // Âè™ÈÄâÊã©Á©∫Âú∞
                if (!child.userData.is_empty) return;
                
                const dist = cartPos.distanceTo(child.position);
                if (dist < minDist && dist <= config.range) {
                    minDist = dist;
                    closestPlot = child;
                }
            });
            
            if (!closestPlot) {
                showMessage('‚ùå Ê≤°ÊúâÁ©∫Âú∞ÔºÅËØ∑ÁßªÂä®Âà∞Á©∫Âú∞‰∏äÊñπ', 'error');
                return;
            }
            
            // Ê£ÄÊü•ÈáëÂ∏Å
            if (gameState.coins < 5) {
                showMessage('ÈáëÂ∏Å‰∏çË∂≥ÔºÅÈúÄË¶Å5üí∞', 'error');
                SoundEffects.error();
                return;
            }
            
            // Êí≠ÁßçÂçïÂùóÂú∞
            try {
                const response = await fetch('/api/action/plant', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        row: closestPlot.userData.row,
                        col: closestPlot.userData.col
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Êõ¥Êñ∞Ê§çÁâ©Êï∞ÊçÆ
                    closestPlot.userData.is_empty = false;
                    closestPlot.userData.is_seed = true;
                    closestPlot.userData.growth_stage = 0;
                    
                    // ÈáçÂª∫3DÊ®°ÂûãÔºà‰ªéÁ©∫Âú∞ÂèòÊàêÁßçÂ≠êÔºâ
                    closestPlot.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    closestPlot.children = [];
                    
                    // ÂàõÂª∫ÁßçÂ≠êÊ®°Âûã
                    const seedModel = createPlantModel({
                        is_seed: true,
                        is_empty: false
                    });
                    seedModel.children.forEach(child => closestPlot.add(child));
                    
                    // Êí≠ÁßçÁâπÊïà
                    createPlantingEffect(closestPlot.position);
                    
                    showMessage(`üå± Êí≠ÁßçÊàêÂäüÔºÅ-5üí∞`, 'success');
                    SoundEffects.success();
                    
                    // Êõ¥Êñ∞ÈáëÂ∏Å
                    gameState.coins -= 5;
                    gameState.score += 10;
                    updateUI();
                } else {
                    showMessage(result.message || 'Êí≠ÁßçÂ§±Ë¥•', 'error');
                    SoundEffects.error();
                }
            } catch (error) {
                console.error('Plant error:', error);
                showMessage('Êí≠ÁßçÂ§±Ë¥•', 'error');
                SoundEffects.error();
            }
        }
        
        
        // ========== Êú∫Ê¢∞ËáÇËá™Âä®Êî∂Ëé∑ÔºàËåÉÂõ¥ÂÜÖÊúÄËøëÁöÑÊàêÁÜüÊ§çÁâ©Ôºâ ==========
        async function useArmHarvestAuto() {
            console.log('[DEBUG useArmHarvestAuto] 1. ÂºÄÂßãÊâßË°å useArmHarvestAuto()');
            const config = equipmentConfig.arm;
            console.log(`[DEBUG useArmHarvestAuto] 2. Êú∫Ê¢∞ËáÇËåÉÂõ¥: ${config.range}m`);
            
            // ü¶æ ÊâæÂà∞ËåÉÂõ¥ÂÜÖÊúÄËøëÁöÑÊàêÁÜüÊ§çÁâ©ÔºàÈò∂ÊÆµ3ÁöÑËî¨ËèúÔºâ
            let closestPlant = null;
            let minDist = Infinity;
            const cartPos = cart.position;
            let checkedCount = 0;
            let validCount = 0;
            
            console.log(`[DEBUG useArmHarvestAuto] 3. Â∞èËΩ¶‰ΩçÁΩÆ: x=${cartPos.x.toFixed(2)}, z=${cartPos.z.toFixed(2)}`);
            console.log(`[DEBUG useArmHarvestAuto] 4. farm.children Êï∞Èáè: ${farm.children.length}`);
            
            farm.children.forEach(child => {
                checkedCount++;
                if (!child.userData || !child.userData.id || child.userData.is_removed) {
                    console.log(`[DEBUG useArmHarvestAuto]    - Ê§çÁâ© ${checkedCount}: Êó†Êïà (Êó†userData/id/Â∑≤ÁßªÈô§)`);
                    return;
                }
                if (child.userData.is_empty) {
                    console.log(`[DEBUG useArmHarvestAuto]    - Ê§çÁâ© ${checkedCount}: Á©∫Âú∞`);
                    return; // Ë∑≥ËøáÁ©∫Âú∞
                }
                
                // Âè™Êî∂Ëé∑ÊàêÁÜüÁöÑËî¨ËèúÔºàÈò∂ÊÆµ3‰∏î‰∏çÊòØÊùÇËçâÔºâ
                if (!child.userData.is_vegetable) {
                    console.log(`[DEBUG useArmHarvestAuto]    - Ê§çÁâ© ${checkedCount}: ‰∏çÊòØËî¨Ëèú`);
                    return;
                }
                if (child.userData.growth_stage !== 3) {
                    console.log(`[DEBUG useArmHarvestAuto]    - Ê§çÁâ© ${checkedCount}: Êú™ÊàêÁÜü (stage=${child.userData.growth_stage})`);
                    return;
                }
                
                validCount++;
                const dist = cartPos.distanceTo(child.position);
                console.log(`[DEBUG useArmHarvestAuto]    - Ê§çÁâ© ${checkedCount}: ${child.userData.id}, Ë∑ùÁ¶ª=${dist.toFixed(2)}m, ËåÉÂõ¥=${config.range}m`);
                // ‚ö†Ô∏è Âè™ÈÄâÊã©‰∏ä‰∏ãÂ∑¶Âè≥ÊñπÂêëÁöÑÊ§çÁâ©ÔºåÊéíÈô§ÂØπËßíÁ∫ø
                if (dist < minDist && dist <= config.range && isCardinalDirection(cartPos, child.position)) {
                    minDist = dist;
                    closestPlant = child;
                    console.log(`[DEBUG useArmHarvestAuto]      ‚úÖ Êõ¥Êñ∞ÊúÄËøëÊ§çÁâ©Ôºà‰∏ä‰∏ãÂ∑¶Âè≥Ôºâ: ${child.userData.id}, Ë∑ùÁ¶ª=${dist.toFixed(2)}m`);
                } else if (dist <= config.range) {
                    console.log(`[DEBUG useArmHarvestAuto]      ‚è≠Ô∏è Ë∑≥ËøáÂØπËßíÁ∫øÊ§çÁâ©: ${child.userData.id}, Ë∑ùÁ¶ª=${dist.toFixed(2)}m`);
                }
            });
            
            console.log(`[DEBUG useArmHarvestAuto] 5. Ê£ÄÊü•‰∫Ü ${checkedCount} ‰∏™Ê§çÁâ©ÔºåÊúâÊïà ${validCount} ‰∏™`);
            
            if (!closestPlant) {
                console.log('[DEBUG useArmHarvestAuto] ‚ùå Ê≤°ÊúâÊâæÂà∞ÊàêÁÜüÊ§çÁâ©');
                showMessage('‚ùå ËåÉÂõ¥ÂÜÖÊ≤°ÊúâÊàêÁÜüÊ§çÁâ©ÔºÅËØ∑ÁßªÂä®Âà∞ÊàêÁÜüËî¨ËèúÈôÑËøë', 'error');
                return;
            }
            
            console.log(`[DEBUG useArmHarvestAuto] 6. ‚úÖ ÊâæÂà∞ÊúÄËøëÊ§çÁâ©: ${closestPlant.userData.id}, Ë∑ùÁ¶ª=${minDist.toFixed(2)}m`);
            
            // üé¨ ÂÖàÊí≠ÊîæÈúáÊíºÁöÑÊú∫Ê¢∞ËáÇÊî∂Ëé∑Âä®ÁîªÔºàÈáçË¶ÅÔºöÂøÖÈ°ªÂú®Ë∞ÉÁî®API‰πãÂâçÔºÅÔºâ
            console.log('[DEBUG useArmHarvestAuto] 7. ÂáÜÂ§áÊî∂Ëé∑Ê§çÁâ©:', closestPlant.userData.id);
            await harvestPlant(closestPlant);
            console.log('[DEBUG useArmHarvestAuto] 8. Êú∫Ê¢∞ËáÇÂä®ÁîªÂÆåÊàê');
            
            // Ë∞ÉÁî®Êî∂Ëé∑APIÊõ¥Êñ∞ÊúçÂä°Âô®Áä∂ÊÄÅ
            try {
                const plantData = closestPlant.userData;
                console.log('[DEBUG useArmHarvestAuto] 9. Ë∞ÉÁî®Êî∂Ëé∑API...');
                const response = await fetch('/api/action/harvest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ plant_id: plantData.id })
                });
                
                const result = await response.json();
                console.log('[DEBUG useArmHarvestAuto] 10. APIËøîÂõû:', result.success ? 'ÊàêÂäü' : 'Â§±Ë¥•');
                
                if (result.success) {
                    // üéâ ÈúáÊíºÁöÑÊî∂Ëé∑ÂèçÈ¶àÔºÅ
                    createHarvestEffect(closestPlant.position);
                    SoundEffects.success();
                    shakeCamera(2);  // ËΩªÂæÆÈúáÂä®
                    
                    // ÊòæÁ§∫È£òÊµÆÈáëÂ∏ÅÊï∞Â≠óÔºàÂ¢ûÂº∫Ê≠£ÂèçÈ¶àÔºâ
                    createFloatingCoinText(closestPlant.position, result.coins_earned, result.fruit_count);
                    
                    showMessage(result.message + ' ü¶æüí∞', 'success');
                    
                    // Êî∂Ëé∑ÂÆåÊàêÈü≥Êïà
                    setTimeout(() => {
                        SoundEffects.success();
                    }, 500);
                    
                    // Êõ¥Êñ∞‰ªøÁúüÁä∂ÊÄÅ
                    gameState.coins += result.coins_earned;
                    gameState.score += result.coins_earned;
                    updateUI();
                    
                    console.log('[DEBUG useArmHarvestAuto] 11. ÂºÄÂßãÁßªÈô§Ê§çÁâ©Ê®°Âûã...');
                    
                    // ‚ö†Ô∏è ÂÖ≥ÈîÆ1ÔºöÁ´ãÂç≥Êõ¥Êñ∞gameState.plants‰∏≠ÂØπÂ∫îÊ§çÁâ©ÁöÑÁä∂ÊÄÅÔºåÊ†áËÆ∞‰∏∫Á©∫Âú∞
                    const plantInState = gameState.plants.find(p => p.id === plantData.id);
                    if (plantInState) {
                        console.log(`[DEBUG useArmHarvestAuto] 11.1. Êõ¥Êñ∞gameState.plants‰∏≠Ê§çÁâ© ${plantData.id} ÁöÑÁä∂ÊÄÅ‰∏∫Á©∫Âú∞`);
                        plantInState.is_empty = true;
                        plantInState.is_vegetable = false;
                        plantInState.growth_stage = 0;
                        plantInState.is_seed = false;
                    }
                    
                    // ‚ö†Ô∏è ÂÖ≥ÈîÆ2ÔºöÁ´ãÂç≥‰ªéfarm.children‰∏≠ÁßªÈô§Â∑≤Êî∂Ëé∑ÁöÑÊ§çÁâ©
                    // ÂÖàÊ∏ÖÁêÜËµÑÊ∫ê
                    while (closestPlant.children.length > 0) {
                        const child = closestPlant.children[0];
                        closestPlant.remove(child);
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                    // ‰ªéfarm‰∏≠ÁßªÈô§Ê§çÁâ©
                    farm.remove(closestPlant);
                    console.log(`[DEBUG useArmHarvestAuto] 12. ‚úÖ Ê§çÁâ©Â∑≤ÁßªÈô§ÔºåÂΩìÂâç farm.children Êï∞Èáè: ${farm.children.length}`);
                } else {
                    console.log('[DEBUG useArmHarvestAuto] ‚ùå APIËøîÂõûÂ§±Ë¥•:', result.message);
                    showMessage(result.message, 'error');
                    SoundEffects.error();
                }
            } catch (error) {
                console.error('[DEBUG useArmHarvestAuto] ‚ùå Êî∂Ëé∑ÈîôËØØ:', error);
                showMessage('Êî∂Ëé∑Â§±Ë¥•', 'error');
                SoundEffects.error();
            }
            console.log('[DEBUG useArmHarvestAuto] 13. useArmHarvestAuto() ÊâßË°åÂÆåÊàê');
        }
        
        // üåø Â§ÑÁêÜÊùÇËçâÊâ©Êï£ÊïàÊûú
        function handleWeedSpread(spreadInfo) {
            spreadInfo.forEach(info => {
                // ÊâæÂà∞Ë¢´‰æµÂç†ÁöÑÊ§çÁâ©
                const plant = farm.children.find(child => 
                    child.userData && child.userData.id === info.plant_id
                );
                
                if (!plant) return;
                
                // Êõ¥Êñ∞Ê§çÁâ©Êï∞ÊçÆ‰∏∫ÊùÇËçâ
                plant.userData.is_vegetable = false;
                plant.userData.is_weed = true;
                plant.userData.type = info.new_type;
                plant.userData.growth_stage = 1;  // Êñ∞ÊùÇËçâ‰ªéÈò∂ÊÆµ1ÂºÄÂßã
                plant.userData.health = 100;
                
                // ÁßªÈô§ÊóßÊ®°Âûã
                while (plant.children.length > 0) {
                    const child = plant.children[0];
                    plant.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
                
                // ÂàõÂª∫Êñ∞ÁöÑÊùÇËçâÊ®°Âûã
                const newModel = createPlantModel(plant.userData);
                newModel.children.forEach(child => {
                    plant.add(child.clone());
                });
                
                // ‰æµÂç†ÁâπÊïàÔºàÁ∫¢Ëâ≤Êâ©Êï£Ê≥¢Á∫πÔºâ
                createWeedInvasionEffect(plant.position);
            });
        }
        
        // ÊùÇËçâ‰æµÂç†ÁâπÊïà
        // üå± Êí≠ÁßçÁâπÊïà
        function createPlantingEffect(position) {
            // 1. Ê£ïËâ≤Ê≥•ÂúüÁ≤íÂ≠ê‰∏ãËêΩ
            for (let i = 0; i < 10; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 6, 6),
                    new THREE.MeshBasicMaterial({
                        color: 0x8B4513,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                const angle = (i / 10) * Math.PI * 2;
                const radius = Math.random() * 0.15;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * radius;
                particle.position.z += Math.sin(angle) * radius;
                particle.position.y = 0.3;
                
                scene.add(particle);
                
                const duration = 500 + Math.random() * 300;
                const startTime = Date.now();
                
                const animateParticle = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 1) {
                        particle.position.y = 0.3 - 0.25 * progress;
                        particle.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                };
                animateParticle();
            }
            
            // 2. Â∞èÂûãÂÖâÁéØ
            const ringGeometry = new THREE.RingGeometry(0.05, 0.1, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x8B4513,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.position.y = 0.02;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            const startTime = Date.now();
            const animateRing = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / 600;
                
                if (progress < 1) {
                    ring.scale.set(1 + progress, 1 + progress, 1);
                    ring.material.opacity = 0.6 * (1 - progress);
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                }
            };
            animateRing();
        }
        
        // üå± ÁßçÂ≠êÂèëËäΩÁâπÊïà
        function createGerminationEffect(position, isWeed) {
            const effectColor = isWeed ? 0x8B4513 : 0x00FF00;  // ÊùÇËçâÊ£ïËâ≤ÔºåËî¨ËèúÁªøËâ≤
            
            // 1. ‰∏äÂçáÁöÑÂÖâÁ≤í
            for (let i = 0; i < 15; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 8, 8),
                    new THREE.MeshBasicMaterial({
                        color: effectColor,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                const angle = (i / 15) * Math.PI * 2;
                const radius = Math.random() * 0.2;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * radius;
                particle.position.z += Math.sin(angle) * radius;
                particle.position.y = 0.05;
                
                scene.add(particle);
                
                const targetY = 0.3 + Math.random() * 0.3;
                const duration = 1000 + Math.random() * 500;
                const startTime = Date.now();
                
                const animateParticle = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 1) {
                        particle.position.y = 0.05 + targetY * progress;
                        particle.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                    }
                };
                animateParticle();
            }
            
            // 2. Èó™ÂÖâÁéØ
            const ringGeometry = new THREE.RingGeometry(0.05, 0.15, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: effectColor,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(position);
            ring.position.y = 0.02;
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            const startTime = Date.now();
            const animateRing = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / 800;
                
                if (progress < 1) {
                    ring.scale.set(1 + progress * 2, 1 + progress * 2, 1);
                    ring.material.opacity = 0.8 * (1 - progress);
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                }
            };
            animateRing();
            
            // 3. ÊñáÂ≠óÊèêÁ§∫
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            context.fillStyle = isWeed ? 'rgba(139,69,19,0.9)' : 'rgba(0,255,0,0.9)';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(isWeed ? 'üåø ÊùÇËçâ' : 'ü•¨ Ëî¨Ëèú', 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.position.y = 0.4;
            sprite.scale.set(0.5, 0.25, 1);
            scene.add(sprite);
            
            const startTime2 = Date.now();
            const animateSprite = () => {
                const elapsed = Date.now() - startTime2;
                const progress = elapsed / 1500;
                
                if (progress < 1) {
                    sprite.position.y = 0.4 + progress * 0.3;
                    sprite.material.opacity = 1 - progress;
                    requestAnimationFrame(animateSprite);
                } else {
                    scene.remove(sprite);
                    sprite.material.map.dispose();
                    sprite.material.dispose();
                }
            };
            animateSprite();
            
            // Êí≠ÊîæÈü≥Êïà
            SoundEffects.success();
        }
        
        function createWeedInvasionEffect(position) {
            // Á∫¢Ëâ≤ÂÜ≤ÂáªÊ≥¢
            const ringGeometry = new THREE.RingGeometry(0.05, 0.1, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(position);
            ring.position.y = 0.01;
            scene.add(ring);
            
            // Êâ©Êï£Âä®Áîª
            let time = 0;
            const interval = setInterval(() => {
                time += 0.05;
                ring.scale.x = 1 + time * 5;
                ring.scale.y = 1 + time * 5;
                ringMaterial.opacity = 0.8 * (1 - time);
                
                if (time >= 1) {
                    clearInterval(interval);
                    scene.remove(ring);
                    ringGeometry.dispose();
                    ringMaterial.dispose();
                }
            }, 50);
            
            // Á∫¢Ëâ≤Á≤íÂ≠ê‰∏äÂçá
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.position.x += (Math.random() - 0.5) * 0.2;
                particle.position.z += (Math.random() - 0.5) * 0.2;
                scene.add(particle);
                
                const velocity = {
                    x: (Math.random() - 0.5) * 0.02,
                    y: 0.02 + Math.random() * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                };
                
                let pTime = 0;
                const pInterval = setInterval(() => {
                    pTime += 0.05;
                    particle.position.x += velocity.x;
                    particle.position.y += velocity.y;
                    particle.position.z += velocity.z;
                    particleMaterial.opacity = 0.7 * (1 - pTime);
                    
                    if (pTime >= 1) {
                        clearInterval(pInterval);
                        scene.remove(particle);
                        particleGeometry.dispose();
                        particleMaterial.dispose();
                    }
                }, 50);
            }
            
            // ÈúáÂä®ÊïàÊûú
            shakeCamera();
        }
        
        // ========== ÂêØÂä®‰ªøÁúü ==========
        init();
    </script>
</body>
</html>

