<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test 1: Basic Scene and Cart Movement</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #container { width: 100vw; height: 100vh; }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 300px;
            transition: transform 0.3s ease-in-out;
        }
        #controls.collapsed {
            transform: translateX(calc(-100% - 40px));
        }
        h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 20px;
        }
        .test-info {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        .test-info strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
        }
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .status {
            margin-top: 15px;
            padding: 10px;
            background: #e7f3ff;
            border-radius: 8px;
            font-size: 14px;
        }
        .status-item {
            margin: 5px 0;
        }
        .status-item span {
            font-weight: bold;
            color: #667eea;
        }
        
        /* æ‰‹åŠ¨æ§åˆ¶é¢æ¿ */
        #manualControl {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
        }
        #manualControl.collapsed {
            transform: translateX(calc(100% + 40px));
        }
        
        .control-section {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .control-section h3 {
            color: #667eea;
            font-size: 16px;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            font-size: 13px;
            color: #333;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .slider-value {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        /* å•æ­¥æ§åˆ¶æŒ‰é’®ç»„ */
        .step-controls {
            display: flex;
            gap: 5px;
            margin-top: 5px;
            justify-content: center;
        }
        .step-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .step-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }
        .step-btn:active {
            transform: translateY(0);
        }
        .step-btn.large {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .step-btn.small {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .position-display {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 12px;
            line-height: 1.6;
            border-left: 4px solid #667eea;
        }
        
        .position-display strong {
            color: #667eea;
        }
        
        .record-item {
            background: #e7f3ff;
            padding: 8px;
            border-radius: 6px;
            margin: 5px 0;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .record-item:hover {
            background: #d0e7ff;
            transform: translateX(5px);
        }
        
        .btn-small {
            width: 48%;
            display: inline-block;
            padding: 8px;
            margin: 2px 1%;
            font-size: 14px;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        /* æ”¶çº³æŒ‰é’® */
        .toggle-btn {
            position: fixed;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            padding: 15px 10px;
            cursor: pointer;
            z-index: 1001;
            font-size: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: all 0.3s;
            width: auto;
            min-width: 45px;
            font-weight: bold;
        }
        .toggle-btn:hover {
            background: rgba(118, 75, 162, 0.95);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
        }
        #toggleLeft {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            border-radius: 0 8px 8px 0;
        }
        #toggleRight {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            border-radius: 8px 0 0 8px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <!-- æ”¶çº³æŒ‰é’® -->
    <button id="toggleLeft" class="toggle-btn" onclick="toggleLeftPanel()" title="Collapse/Expand Left Panel">â—€</button>
    <button id="toggleRight" class="toggle-btn" onclick="toggleRightPanel()" title="Collapse/Expand Right Panel">â–¶</button>
    
    <div id="controls">
        <h2>ğŸ¤– Farm Robot Arm Demo System</h2>
        
        <div class="test-info">
            <strong>Demo Content:</strong>
            Four-axis robotic arm cart with automatic weeding and seeding
            <br><br>
            <strong>Workflow:</strong>
            Visit 16 grids sequentially â†’ Remove weeds â†’ Plant seeds â†’ Return to start
        </div>
        
        <button class="btn-primary" onclick="startTest()">â–¶ï¸ Start Test</button>
        <button class="btn-secondary" onclick="stopTest()">â¹ï¸ Stop</button>
        <button class="btn-secondary" onclick="resetTest()">ğŸ”„ Reset</button>
        <button class="btn-secondary" onclick="toggleManualControl()">ğŸ® Manual Control</button>
        
        <div class="status">
            <div class="status-item">
                Status: <span id="status">Ready</span>
            </div>
            <div class="status-item">
                Current Position: <span id="position">(-1.50, -1.50)</span>
            </div>
            <div class="status-item">
                Progress: <span id="waypoint">0/16</span>
            </div>
            <div class="status-item">
                Current Task: <span id="currentCell">Ready</span>
            </div>
        </div>
    </div>
    
    <!-- Manual Control Panel -->
    <div id="manualControl" style="display: none;">
        <h2>ğŸ® Manual Debug Console</h2>
        
        <!-- Cart Position Control -->
        <div class="control-section">
            <h3>ğŸš— Cart Position</h3>
            <div class="slider-group">
                <label>X-axis: <span class="slider-value" id="cartXValue">0.00</span></label>
                <input type="range" id="cartX" min="-1.5" max="1.5" step="0.01" value="0" oninput="updateCartPosition()">
                <div class="step-controls">
                    <button class="step-btn large" onclick="stepCartX(-0.1)">--</button>
                    <button class="step-btn small" onclick="stepCartX(-0.01)">-</button>
                    <button class="step-btn small" onclick="stepCartX(0.01)">+</button>
                    <button class="step-btn large" onclick="stepCartX(0.1)">++</button>
                </div>
            </div>
            <div class="slider-group">
                <label>Z-axis: <span class="slider-value" id="cartZValue">0.00</span></label>
                <input type="range" id="cartZ" min="-1.5" max="1.5" step="0.01" value="0" oninput="updateCartPosition()">
                <div class="step-controls">
                    <button class="step-btn large" onclick="stepCartZ(-0.1)">--</button>
                    <button class="step-btn small" onclick="stepCartZ(-0.01)">-</button>
                    <button class="step-btn small" onclick="stepCartZ(0.01)">+</button>
                    <button class="step-btn large" onclick="stepCartZ(0.1)">++</button>
                </div>
            </div>
            <button class="btn-small btn-info" onclick="moveToGrass()">ğŸ“ Move to Grass</button>
            <button class="btn-small btn-secondary" onclick="moveToOrigin()">ğŸ  Return to Origin</button>
        </div>
        
        <!-- Robotic Arm Joint Control -->
        <div class="control-section">
            <h3>ğŸ¦¾ Robotic Arm Joint Angles</h3>
            <div class="slider-group">
                <label>Shoulder Joint: <span class="slider-value" id="shoulderValue">0Â°</span></label>
                <input type="range" id="shoulder" min="-180" max="180" step="1" value="0" oninput="updateArmAngles()">
                <div class="step-controls">
                    <button class="step-btn large" onclick="stepShoulder(-10)">--</button>
                    <button class="step-btn small" onclick="stepShoulder(-1)">-</button>
                    <button class="step-btn small" onclick="stepShoulder(1)">+</button>
                    <button class="step-btn large" onclick="stepShoulder(10)">++</button>
                </div>
            </div>
            <div class="slider-group">
                <label>Elbow Joint: <span class="slider-value" id="elbowValue">0Â°</span></label>
                <input type="range" id="elbow" min="-180" max="180" step="1" value="0" oninput="updateArmAngles()">
                <div class="step-controls">
                    <button class="step-btn large" onclick="stepElbow(-10)">--</button>
                    <button class="step-btn small" onclick="stepElbow(-1)">-</button>
                    <button class="step-btn small" onclick="stepElbow(1)">+</button>
                    <button class="step-btn large" onclick="stepElbow(10)">++</button>
                </div>
            </div>
            <div class="slider-group">
                <label>Wrist Joint: <span class="slider-value" id="wristValue">0Â°</span></label>
                <input type="range" id="wrist" min="-180" max="180" step="1" value="0" oninput="updateArmAngles()">
                <div class="step-controls">
                    <button class="step-btn large" onclick="stepWrist(-10)">--</button>
                    <button class="step-btn small" onclick="stepWrist(-1)">-</button>
                    <button class="step-btn small" onclick="stepWrist(1)">+</button>
                    <button class="step-btn large" onclick="stepWrist(10)">++</button>
                </div>
            </div>
            <div class="slider-group">
                <label>Gripper: <span class="slider-value" id="gripperValue">Closed</span></label>
                <input type="range" id="gripper" min="0" max="1" step="1" value="0" oninput="updateGripper()">
                <div class="step-controls">
                    <button class="step-btn" onclick="toggleGripper()">Open/Close</button>
                </div>
            </div>
            <button class="btn-small btn-secondary" onclick="resetArm()">â†©ï¸ Reset Pose</button>
            <button class="btn-small btn-info" onclick="autoAlignGrass()">ğŸ¯ Auto Align to Grass</button>
        </div>
        
        <!-- Position Information Display -->
        <div class="control-section">
            <h3>ğŸ“ Real-time Position Information</h3>
            <div class="position-display" id="positionInfo">
                <strong>Gripper End:</strong> (0.00, 0.00, 0.00)<br>
                <strong>Target Grass:</strong> Not Selected<br>
                <strong>Distance:</strong> -
            </div>
            <button class="btn-small btn-info" onclick="selectTargetGrass()">ğŸŒ± Select Target Grass</button>
            <button class="btn-small btn-secondary" onclick="updatePositionInfo()">ğŸ”„ Refresh Position</button>
        </div>
        
        <!-- Status Records -->
        <div class="control-section">
            <h3>ğŸ’¾ Status Records</h3>
            <button class="btn-success" style="width: 100%;" onclick="recordCurrentState()">ğŸ“¸ Record Current State</button>
            <button class="btn-warning" style="width: 100%; margin-top: 5px;" onclick="exportRecords()">ğŸ“¤ Export All Records</button>
            <button class="btn-secondary" style="width: 100%; margin-top: 5px;" onclick="clearRecords()">ğŸ—‘ï¸ Clear Records</button>
            <div id="recordsList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                <!-- Records list will be displayed here -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        let scene, camera, renderer, controls;
        let cart, farm;
        let testRunning = false;
        let currentWaypoint = 0;
        let waypoints = [];
        let grassArray = [];  // å­˜å‚¨æ‰€æœ‰è‰çš„å¼•ç”¨ [row][col]
        let seeds = [];       // å­˜å‚¨æ‰€æœ‰ç§å­
        
        // æ‰‹åŠ¨æ§åˆ¶ç›¸å…³å˜é‡
        let manualMode = false;
        let stateRecords = [];  // çŠ¶æ€è®°å½•æ•°ç»„
        let targetGrass = null;  // å½“å‰é€‰ä¸­çš„ç›®æ ‡è‰
        let targetGrassIndex = 0; // å½“å‰é€‰ä¸­è‰çš„ç´¢å¼• (0-15)
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -5;
            dirLight.shadow.camera.right = 5;
            dirLight.shadow.camera.top = 5;
            dirLight.shadow.camera.bottom = -5;
            scene.add(dirLight);
            
            // åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // åˆ›å»ºå†œç”°
            createFarm();
            
            // åˆ›å»ºå°è½¦
            createCart();
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // åŠ è½½æµ‹è¯•è·¯å¾„
            loadTestPath();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
            
            console.log('âœ… åœºæ™¯åˆå§‹åŒ–å®Œæˆ');
            console.log('ğŸ“ å°è½¦åˆå§‹ä½ç½®:', cart.position);
        }
        
        // åˆ›å»ºä¸€æ ªè‰
        function createGrass() {
            const grassGroup = new THREE.Group();
            
            // è‰çš„æè´¨ - ç»¿è‰²
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8
            });
            
            // è‰èŒï¼ˆç»†åœ†æŸ±ï¼‰
            const stemGeometry = new THREE.CylinderGeometry(0.005, 0.008, 0.08, 8);
            const stem = new THREE.Mesh(stemGeometry, grassMaterial);
            stem.position.y = 0.04;
            grassGroup.add(stem);
            
            // è‰å¶ï¼ˆå¤šä¸ªç»†é•¿çš„æ¤­åœ†ï¼‰
            const leafMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x32CD32,
                roughness: 0.7,
                side: THREE.DoubleSide
            });
            
            // åˆ›å»º5-7ç‰‡è‰å¶
            const leafCount = 5 + Math.floor(Math.random() * 3);
            for (let i = 0; i < leafCount; i++) {
                const angle = (Math.PI * 2 * i) / leafCount;
                const bendAngle = 0.3 + Math.random() * 0.4; // éšæœºå¼¯æ›²è§’åº¦
                
                const leafGeometry = new THREE.PlaneGeometry(0.015, 0.06);
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                
                // å®šä½è‰å¶
                leaf.position.y = 0.05;
                leaf.position.x = Math.cos(angle) * 0.01;
                leaf.position.z = Math.sin(angle) * 0.01;
                
                // æ—‹è½¬è‰å¶
                leaf.rotation.y = angle;
                leaf.rotation.x = -bendAngle;
                
                grassGroup.add(leaf);
            }
            
            // è‰é¡¶éƒ¨çš„å°ç°‡ï¼ˆè®©è‰æ›´èŒ‚å¯†ï¼‰
            const topTuftGeometry = new THREE.SphereGeometry(0.015, 6, 6);
            const topTuft = new THREE.Mesh(topTuftGeometry, grassMaterial);
            topTuft.position.y = 0.08;
            topTuft.scale.set(1, 1.5, 1);
            grassGroup.add(topTuft);
            
            // éšæœºè½»å¾®æ—‹è½¬ï¼Œè®©æ¯æ ªè‰éƒ½ç•¥æœ‰ä¸åŒ
            grassGroup.rotation.y = Math.random() * Math.PI * 2;
            
            // æŠ•å°„é˜´å½±
            grassGroup.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                }
            });
            
            return grassGroup;
        }
        
        // åˆ›å»ºå†œç”°
        function createFarm() {
            farm = new THREE.Group();
            const cellSize = 0.5;
            const gridSize = 4;
            const offsetX = -0.75;
            const offsetZ = -0.75;
            
            // åˆå§‹åŒ–è‰æ•°ç»„
            grassArray = [];
            for (let i = 0; i < gridSize; i++) {
                grassArray[i] = [];
            }
            
            // åˆ›å»º4x4æ ¼å­ï¼Œæ¯ä¸ªæ ¼å­æœ‰ä¸åŒçš„é¢œè‰²ä»¥ä¾¿åŒºåˆ†
            const colors = [0xD2691E, 0xCD853F]; // ä¸¤ç§åœŸå£¤é¢œè‰²äº¤æ›¿
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cellGeometry = new THREE.BoxGeometry(cellSize - 0.02, 0.01, cellSize - 0.02);
                    const colorIndex = (row + col) % 2;
                    const cellMaterial = new THREE.MeshStandardMaterial({ 
                        color: colors[colorIndex],
                        roughness: 0.9
                    });
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.position.set(
                        offsetX + col * cellSize + cellSize / 2,
                        0.005,
                        offsetZ + row * cellSize + cellSize / 2
                    );
                    cell.receiveShadow = true;
                    farm.add(cell);
                    
                    // æ·»åŠ æ ¼å­ç¼–å·æ ‡ç­¾ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');
                    context.fillStyle = 'white';
                    context.font = '32px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(`${row},${col}`, 32, 32);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelGeometry = new THREE.PlaneGeometry(0.15, 0.15);
                    const labelMaterial = new THREE.MeshBasicMaterial({ 
                        map: texture, 
                        transparent: true 
                    });
                    const label = new THREE.Mesh(labelGeometry, labelMaterial);
                    label.rotation.x = -Math.PI / 2;
                    label.position.set(
                        offsetX + col * cellSize + cellSize / 2,
                        0.02,
                        offsetZ + row * cellSize + cellSize / 2
                    );
                    farm.add(label);
                    
                    // åœ¨æ¯ä¸ªæ ¼å­ä¸­å¿ƒæ·»åŠ ä¸€æ ªè‰
                    const grass = createGrass();
                    grass.position.set(
                        offsetX + col * cellSize + cellSize / 2,
                        0.01,
                        offsetZ + row * cellSize + cellSize / 2
                    );
                    grass.userData = { row, col, isPulled: false };  // ä¿å­˜ä½ç½®ä¿¡æ¯
                    farm.add(grass);
                    grassArray[row][col] = grass;  // ä¿å­˜å¼•ç”¨
                }
            }
            
            // å†œç”°å¤–è¾¹æ¡†
            const borderThickness = 0.05;
            const borderHeight = 0.05;
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            
            // å››æ¡è¾¹æ¡†
            const borders = [
                // ä¸Šè¾¹æ¡†
                { w: gridSize * cellSize + borderThickness * 2, h: borderHeight, d: borderThickness,
                  x: offsetX + gridSize * cellSize / 2, z: offsetZ - borderThickness / 2 },
                // ä¸‹è¾¹æ¡†
                { w: gridSize * cellSize + borderThickness * 2, h: borderHeight, d: borderThickness,
                  x: offsetX + gridSize * cellSize / 2, z: offsetZ + gridSize * cellSize + borderThickness / 2 },
                // å·¦è¾¹æ¡†
                { w: borderThickness, h: borderHeight, d: gridSize * cellSize,
                  x: offsetX - borderThickness / 2, z: offsetZ + gridSize * cellSize / 2 },
                // å³è¾¹æ¡†
                { w: borderThickness, h: borderHeight, d: gridSize * cellSize,
                  x: offsetX + gridSize * cellSize + borderThickness / 2, z: offsetZ + gridSize * cellSize / 2 }
            ];
            
            borders.forEach(b => {
                const geometry = new THREE.BoxGeometry(b.w, b.h, b.d);
                const border = new THREE.Mesh(geometry, borderMaterial);
                border.position.set(b.x, borderHeight / 2, b.z);
                border.castShadow = true;
                farm.add(border);
            });
            
            scene.add(farm);
            console.log('âœ… å†œç”°åˆ›å»ºå®Œæˆ: 4x4 = 16ä¸ªæ ¼å­ï¼Œæ¯ä¸ªæ ¼å­éƒ½æœ‰ä¸€æ ªè‰');
        }
        
        // åˆ›å»ºå››è½´æœºæ¢°è‡‚ï¼ˆé‡å»ºç‰ˆ - ä¸“ä¸šå·¥ä¸šé£æ ¼ï¼‰
        function createRobotArm() {
            const armGroup = new THREE.Group();
            
            // æœºæ¢°è‡‚é…ç½®ï¼ˆä¸åç«¯ä¿æŒä¸€è‡´ï¼‰
            const L1 = 0.10;  // åº•åº§é«˜åº¦
            const L2 = 0.30;  // å¤§è‡‚é•¿åº¦
            const L3 = 0.25;  // å°è‡‚é•¿åº¦
            const L4 = 0.15;  // æœ«ç«¯æ‰§è¡Œå™¨é•¿åº¦
            
            // é‡å»ºæè´¨ - ç»Ÿä¸€å·¥ä¸šé£æ ¼
            const mainBodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x34495E,  // æ·±ç°è‰²ä¸»ä½“
                metalness: 0.9,
                roughness: 0.2
            });
            const jointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE67E22,  // æ©™è‰²å…³èŠ‚
                metalness: 0.85,
                roughness: 0.25
            });
            const accentMaterial = new THREE.MeshStandardMaterial({
                color: 0xECF0F1,  // æµ…ç°è‰²è£…é¥°
                metalness: 0.95,
                roughness: 0.1
            });
            
            // === 1. åº•åº§ ===
            const baseJoint = new THREE.Group();
            
            // åº•åº§ - ä¸‰æ®µå¼è®¾è®¡
            const baseLower = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.055, L1 * 0.4, 24),
                mainBodyMaterial
            );
            baseLower.position.y = L1 * 0.2;
            baseLower.castShadow = true;
            baseJoint.add(baseLower);
            
            const baseMid = new THREE.Mesh(
                new THREE.CylinderGeometry(0.048, 0.048, L1 * 0.3, 24),
                accentMaterial
            );
            baseMid.position.y = L1 * 0.55;
            baseMid.castShadow = true;
            baseJoint.add(baseMid);
            
            const baseUpper = new THREE.Mesh(
                new THREE.CylinderGeometry(0.045, 0.048, L1 * 0.3, 24),
                mainBodyMaterial
            );
            baseUpper.position.y = L1 * 0.85;
            baseUpper.castShadow = true;
            baseJoint.add(baseUpper);
            
            // === 2. è‚©å…³èŠ‚ ===
            const shoulderJoint = new THREE.Group();
            shoulderJoint.position.y = L1;
            
            // å…³èŠ‚å£³ä½“ - åŒ…è£¹è®¾è®¡
            const shoulderHousing = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.06, 0.06),
                mainBodyMaterial
            );
            shoulderHousing.castShadow = true;
            shoulderJoint.add(shoulderHousing);
            
            // æ—‹è½¬è½´çªå‡ºéƒ¨åˆ†
            const shoulderAxis = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.08, 16),
                accentMaterial
            );
            shoulderAxis.rotation.x = Math.PI / 2;
            shoulderAxis.castShadow = true;
            shoulderJoint.add(shoulderAxis);
            
            // === 3. å¤§è‡‚ ===
            const link2Group = new THREE.Group();
            
            // å¤§è‡‚ - å®Œæ•´åœ†æŸ±ä½“ï¼Œä¸€ä½“åŒ–
            const link2Main = new THREE.Mesh(
                new THREE.CylinderGeometry(0.025, 0.025, L2, 24),
                mainBodyMaterial
            );
            link2Main.rotation.z = Math.PI / 2;
            link2Main.position.x = L2 / 2;
            link2Main.castShadow = true;
            link2Group.add(link2Main);
            
            // å¤§è‡‚è£…é¥°ç¯
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.027, 0.027, 0.01, 24),
                    accentMaterial
                );
                ring.rotation.z = Math.PI / 2;
                ring.position.x = L2 * (0.2 + i * 0.3);
                ring.castShadow = true;
                link2Group.add(ring);
            }
            
            shoulderJoint.add(link2Group);
            
            // === 4. è‚˜å…³èŠ‚ ===
            const elbowJoint = new THREE.Group();
            elbowJoint.position.x = L2;
            
            // è‚˜å…³èŠ‚å£³ä½“ - æ–¹å½¢è®¾è®¡
            const elbowHousing = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.05, 0.05),
                mainBodyMaterial
            );
            elbowHousing.castShadow = true;
            elbowJoint.add(elbowHousing);
            
            // è‚˜å…³èŠ‚æ©™è‰²è£…é¥°
            const elbowAccent = new THREE.Mesh(
                new THREE.BoxGeometry(0.062, 0.02, 0.052),
                jointMaterial
            );
            elbowAccent.castShadow = true;
            elbowJoint.add(elbowAccent);
            
            // === 5. å°è‡‚ ===
            const link3Group = new THREE.Group();
            
            // å°è‡‚ - å®Œæ•´åœ†æŸ±ä½“
            const link3Main = new THREE.Mesh(
                new THREE.CylinderGeometry(0.020, 0.020, L3, 24),
                mainBodyMaterial
            );
            link3Main.rotation.z = Math.PI / 2;
            link3Main.position.x = L3 / 2;
            link3Main.castShadow = true;
            link3Group.add(link3Main);
            
            // å°è‡‚è£…é¥°ç¯
            for (let i = 0; i < 2; i++) {
                const ring = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.022, 0.022, 0.008, 24),
                    accentMaterial
                );
                ring.rotation.z = Math.PI / 2;
                ring.position.x = L3 * (0.25 + i * 0.5);
                ring.castShadow = true;
                link3Group.add(ring);
            }
            
            elbowJoint.add(link3Group);
            
            // === 6. è…•å…³èŠ‚ ===
            const wristJoint = new THREE.Group();
            wristJoint.position.x = L3;
            
            // è…•å…³èŠ‚å£³ä½“ - å°å‹æ–¹ç›’
            const wristHousing = new THREE.Mesh(
                new THREE.BoxGeometry(0.045, 0.04, 0.04),
                mainBodyMaterial
            );
            wristHousing.castShadow = true;
            wristJoint.add(wristHousing);
            
            // è…•å…³èŠ‚æ©™è‰²è£…é¥°
            const wristAccent = new THREE.Mesh(
                new THREE.BoxGeometry(0.047, 0.015, 0.042),
                jointMaterial
            );
            wristAccent.castShadow = true;
            wristJoint.add(wristAccent);
            
            // è…•éƒ¨å»¶ä¼¸è‡‚ - è¿æ¥åˆ°æŠ“æ‰‹
            const wristExtension = new THREE.Mesh(
                new THREE.CylinderGeometry(0.018, 0.018, L4, 24),
                mainBodyMaterial
            );
            wristExtension.rotation.z = Math.PI / 2;
            wristExtension.position.x = L4 / 2;
            wristExtension.castShadow = true;
            wristJoint.add(wristExtension);
            
            // 7. æœ«ç«¯æ‰§è¡Œå™¨ï¼ˆæŠ“æ‰‹ï¼‰
            const gripperGroup = createGripper();
            gripperGroup.position.x = L4;
            wristJoint.add(gripperGroup);
            
            // ç»„è£…æœºæ¢°è‡‚
            elbowJoint.add(wristJoint);
            shoulderJoint.add(elbowJoint);
            baseJoint.add(shoulderJoint);
            armGroup.add(baseJoint);
            
            // ä¿å­˜å…³èŠ‚å¼•ç”¨ä»¥ä¾¿åç»­æ§åˆ¶
            armGroup.baseJoint = baseJoint;
            armGroup.shoulderJoint = shoulderJoint;
            armGroup.elbowJoint = elbowJoint;
            armGroup.wristJoint = wristJoint;
            armGroup.gripperGroup = gripperGroup;
            
            // è®¾ç½®åˆå§‹å§¿æ€ï¼ˆå‚ç›´å‘ä¸Šï¼‰
            shoulderJoint.rotation.z = 0;
            elbowJoint.rotation.z = 0;
            wristJoint.rotation.z = 0;
            
            console.log('âœ… å››è½´æœºæ¢°è‡‚åˆ›å»ºå®Œæˆ');
            return armGroup;
        }
        
        // åˆ›å»ºæŠ“æ‰‹ï¼ˆé‡å»ºç‰ˆ - ç®€æ´å·¥ä¸šè®¾è®¡ï¼‰
        function createGripper() {
            const gripperGroup = new THREE.Group();
            
            const mainBodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x34495E,
                metalness: 0.9,
                roughness: 0.2
            });
            
            const accentMaterial = new THREE.MeshStandardMaterial({
                color: 0xECF0F1,
                metalness: 0.95,
                roughness: 0.1
            });
            
            // æŠ“æ‰‹åŸºåº§
            const gripperBase = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.03, 0.04),
                mainBodyMaterial
            );
            gripperBase.castShadow = true;
            gripperGroup.add(gripperBase);
            
            // LEDçŠ¶æ€æŒ‡ç¤ºç¯
            const led = new THREE.Mesh(
                new THREE.SphereGeometry(0.004, 12, 12),
                new THREE.MeshStandardMaterial({
                    color: 0x00FF00,
                    emissive: 0x00FF00,
                    emissiveIntensity: 1.0
                })
            );
            led.position.set(0, 0, 0.021);
            gripperGroup.add(led);
            gripperGroup.led = led;
            
            // å·¦æ‰‹æŒ‡
            const leftFinger = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, 0.05, 0.02),
                accentMaterial
            );
            leftFinger.position.set(0, -0.04, 0.01);
            leftFinger.castShadow = true;
            gripperGroup.add(leftFinger);
            
            // å³æ‰‹æŒ‡
            const rightFinger = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, 0.05, 0.02),
                accentMaterial
            );
            rightFinger.position.set(0, -0.04, -0.01);
            rightFinger.castShadow = true;
            gripperGroup.add(rightFinger);
            
            // æŠ“æ‰‹æœ«ç«¯æ ‡è®°ç‚¹ï¼ˆè°ƒè¯•ç”¨ - æ˜¾ç¤ºæŠ“å–ç‚¹ï¼‰
            const tipMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 8, 8),
                new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.6
                })
            );
            tipMarker.position.set(0, -0.065, 0); // æ‰‹æŒ‡æœ«ç«¯ä½ç½®
            gripperGroup.add(tipMarker);
            gripperGroup.tipMarker = tipMarker;
            
            // ä¿å­˜æ‰‹æŒ‡å¼•ç”¨
            gripperGroup.leftFinger = leftFinger;
            gripperGroup.rightFinger = rightFinger;
            gripperGroup.isOpen = false;
            
            return gripperGroup;
        }
        
        // åˆ›å»ºå°è½¦
        function createCart() {
            cart = new THREE.Group();
            
            // è½¦èº«
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.25);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169E1,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.125;
            body.castShadow = true;
            cart.add(body);
            
            // è½®å­
            const wheelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.03, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const positions = [
                [-0.12, 0.05, -0.1],
                [-0.12, 0.05, 0.1],
                [0.12, 0.05, -0.1],
                [0.12, 0.05, 0.1]
            ];
            
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                cart.add(wheel);
            });
            
            // æ·»åŠ å››è½´æœºæ¢°è‡‚åˆ°å°è½¦ä¸Š
            const robotArm = createRobotArm();
            robotArm.position.set(0, 0.2, 0); // å®‰è£…åœ¨è½¦èº«é¡¶éƒ¨
            cart.add(robotArm);
            cart.robotArm = robotArm; // ä¿å­˜å¼•ç”¨ä»¥ä¾¿åç»­æ§åˆ¶
            
            // åˆå§‹ä½ç½®
            cart.position.set(-1.5, 0, -1.5);
            scene.add(cart);
            
            console.log('âœ… å°è½¦åˆ›å»ºå®Œæˆï¼ˆå¸¦å››è½´æœºæ¢°è‡‚ï¼‰');
        }
        
        // åŠ è½½æµ‹è¯•è·¯å¾„
        async function loadTestPath() {
            try {
                const response = await fetch('/api/test/cart_positions');
                const data = await response.json();
                waypoints = data.positions;
                document.getElementById('waypoint').textContent = `0/${waypoints.length}`;
                console.log('âœ… æµ‹è¯•è·¯å¾„åŠ è½½å®Œæˆ:', waypoints.length, 'ä¸ªç‚¹');
                console.log('ğŸ“‹ å®Œæ•´è·¯å¾„åˆ—è¡¨:');
                waypoints.forEach((wp, idx) => {
                    console.log(`  ${idx + 1}. ${wp.label}: (${wp.x.toFixed(2)}, ${wp.y.toFixed(2)})`);
                });
            } catch (error) {
                console.error('âŒ åŠ è½½è·¯å¾„å¤±è´¥:', error);
            }
        }
        
        // å¼€å§‹æµ‹è¯•
        async function startTest() {
            if (testRunning) return;
            testRunning = true;
            currentWaypoint = 0;
            document.getElementById('status').textContent = 'è¿è¡Œä¸­...';
            
            console.log('ğŸš€ å¼€å§‹å®Œæ•´æ¼”ç¤ºï¼šç§»åŠ¨â†’æ‹”è‰â†’æ’­ç§');
            console.log('=' .repeat(60));
            
            // è·³è¿‡èµ·ç‚¹ï¼Œä»ç¬¬ä¸€ä¸ªæ ¼å­å¼€å§‹
            for (let i = 1; i <= 16; i++) {
                if (!testRunning) {
                    console.log('â¹ï¸ æµ‹è¯•è¢«ä¸­æ–­');
                    break;
                }
                
                const waypoint = waypoints[i];
                currentWaypoint = i;
                document.getElementById('waypoint').textContent = `${i}/16`;
                document.getElementById('currentCell').textContent = waypoint.label;
                
                // ä»æ ‡ç­¾ä¸­æå–è¡Œåˆ—å·
                const match = waypoint.label.match(/\[(\d+),(\d+)\]/);
                if (!match) continue;
                const row = parseInt(match[1]);
                const col = parseInt(match[2]);
                
                console.log(`\nğŸ“ [${i}/16] æ ¼å­[${row},${col}]`);
                console.log(`   1ï¸âƒ£  ç§»åŠ¨ä¸­...`);
                
                // 1. ç§»åŠ¨åˆ°æ ¼å­
                await moveCartTo(waypoint.x, waypoint.y, 1.5);
                console.log(`   âœ… å·²åˆ°è¾¾`);
                
                await sleep(300);
                
                // 2. æ‹”è‰
                console.log(`   2ï¸âƒ£  æ‹”è‰ä¸­...`);
                await pullGrassAction(row, col);
                
                await sleep(300);
                
                // 3. æ’­ç§
                console.log(`   3ï¸âƒ£  æ’­ç§ä¸­...`);
                await plantSeedAction(row, col);
                
                console.log(`   âœ… æ ¼å­[${row},${col}]å®Œæˆï¼`);
                await sleep(500);
            }
            
            // è¿”å›èµ·ç‚¹
            console.log(`\nğŸ  è¿”å›èµ·ç‚¹...`);
            document.getElementById('currentCell').textContent = 'è¿”å›èµ·ç‚¹';
            await moveCartTo(-1.5, -1.5, 2.0);
            
            // æœºæ¢°è‡‚å¤ä½
            await setArmJoints(0, 0, 0, 1.0);
            
            console.log('=' .repeat(60));
            console.log(`ğŸ‰ æ¼”ç¤ºå®Œæˆï¼`);
            console.log(`   âœ… æ‹”é™¤äº† 16 æ ªè‰`);
            console.log(`   âœ… ç§æ¤äº† 16 ç²’ç§å­`);
            console.log('=' .repeat(60));
            
            document.getElementById('status').textContent = 'æ¼”ç¤ºå®Œæˆ ğŸ‰';
            testRunning = false;
        }
        
        // åœæ­¢æµ‹è¯•
        function stopTest() {
            testRunning = false;
            document.getElementById('status').textContent = 'å·²åœæ­¢';
            console.log('â¹ï¸ æµ‹è¯•åœæ­¢');
        }
        
        // é‡ç½®æµ‹è¯•
        function resetTest() {
            stopTest();
            cart.position.set(-1.5, 0, -1.5);
            currentWaypoint = 0;
            document.getElementById('waypoint').textContent = `0/${waypoints.length}`;
            document.getElementById('position').textContent = '(-1.50, -1.50)';
            document.getElementById('status').textContent = 'å°±ç»ª';
            console.log('ğŸ”„ æµ‹è¯•é‡ç½®');
        }
        
        // ç§»åŠ¨å°è½¦åˆ°æŒ‡å®šä½ç½®
        async function moveCartTo(targetX, targetZ, duration) {
            const startX = cart.position.x;
            const startZ = cart.position.z;
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            return new Promise((resolve) => {
                const moveInterval = setInterval(() => {
                    const now = Date.now();
                    if (now >= endTime || !testRunning) {
                        cart.position.x = targetX;
                        cart.position.z = targetZ;
                        updatePositionDisplay();
                        clearInterval(moveInterval);
                        resolve();
                        return;
                    }
                    
                    const progress = (now - startTime) / (duration * 1000);
                    const smoothProgress = smoothStep(progress);
                    
                    cart.position.x = startX + (targetX - startX) * smoothProgress;
                    cart.position.z = startZ + (targetZ - startZ) * smoothProgress;
                    
                    updatePositionDisplay();
                }, 16);
            });
        }
        
        // å¹³æ»‘æ’å€¼å‡½æ•°é›†
        function smoothStep(t) {
            return t * t * (3 - 2 * t);
        }
        
        // æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•°ï¼ˆease-in-out cubicï¼‰
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // å¼¹æ€§ç¼“åŠ¨ï¼ˆç”¨äºæŠ“æ‰‹ï¼‰
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 :
                Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }
        
        // æ›´æ–°ä½ç½®æ˜¾ç¤º
        function updatePositionDisplay() {
            document.getElementById('position').textContent = 
                `(${cart.position.x.toFixed(2)}, ${cart.position.z.toFixed(2)})`;
        }
        
        // ç¡çœ å‡½æ•°
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // ========================================================================
        // æœºæ¢°è‡‚æ§åˆ¶å‡½æ•°
        // ========================================================================
        
        // è®¾ç½®æœºæ¢°è‡‚å…³èŠ‚è§’åº¦ï¼ˆä¼˜åŒ–ç‰ˆ - ä½¿ç”¨æ›´å¥½çš„ç¼“åŠ¨ï¼‰
        function setArmJoints(shoulder, elbow, wrist, duration = 0.5) {
            const arm = cart.robotArm;
            if (!arm) return Promise.resolve();
            
            const startShoulder = arm.shoulderJoint.rotation.z;
            const startElbow = arm.elbowJoint.rotation.z;
            const startWrist = arm.wristJoint.rotation.z;
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    if (now >= endTime) {
                        arm.shoulderJoint.rotation.z = shoulder;
                        arm.elbowJoint.rotation.z = elbow;
                        arm.wristJoint.rotation.z = wrist;
                        clearInterval(interval);
                        resolve();
                        return;
                    }
                    
                    const progress = (now - startTime) / (duration * 1000);
                    const smooth = easeInOutCubic(progress);  // ä½¿ç”¨æ›´å¹³æ»‘çš„ç¼“åŠ¨
                    
                    arm.shoulderJoint.rotation.z = startShoulder + (shoulder - startShoulder) * smooth;
                    arm.elbowJoint.rotation.z = startElbow + (elbow - startElbow) * smooth;
                    arm.wristJoint.rotation.z = startWrist + (wrist - startWrist) * smooth;
                }, 16);
            });
        }
        
        // æ§åˆ¶æŠ“æ‰‹å¼€åˆï¼ˆé‡å»ºç‰ˆ - ç®€æ´è®¾è®¡ï¼‰
        function setGripperOpen(isOpen, duration = 0.3) {
            const arm = cart.robotArm;
            if (!arm) return Promise.resolve();
            
            const gripper = arm.gripperGroup;
            const startLeft = gripper.leftFinger.position.z;
            const startRight = gripper.rightFinger.position.z;
            const targetLeft = isOpen ? 0.02 : 0.01;
            const targetRight = isOpen ? -0.02 : -0.01;
            
            // æ›´æ–°LEDé¢œè‰²
            if (gripper.led) {
                const ledMat = gripper.led.material;
                if (isOpen) {
                    ledMat.color.setHex(0x00FF00);
                    ledMat.emissive.setHex(0x00FF00);
                } else {
                    ledMat.color.setHex(0xFF0000);
                    ledMat.emissive.setHex(0xFF0000);
                }
            }
            
            const startTime = Date.now();
            const endTime = startTime + duration * 1000;
            
            return new Promise((resolve) => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    if (now >= endTime) {
                        gripper.leftFinger.position.z = targetLeft;
                        gripper.rightFinger.position.z = targetRight;
                        gripper.isOpen = isOpen;
                        clearInterval(interval);
                        resolve();
                        return;
                    }
                    
                    const progress = (now - startTime) / (duration * 1000);
                    const smooth = easeInOutCubic(progress);
                    
                    gripper.leftFinger.position.z = startLeft + (targetLeft - startLeft) * smooth;
                    gripper.rightFinger.position.z = startRight + (targetRight - startRight) * smooth;
                }, 16);
            });
        }
        
        // ========================================================================
        // è·å–æŠ“æ‰‹æœ«ç«¯çš„ä¸–ç•Œåæ ‡
        // ========================================================================
        function getGripperTipWorldPosition() {
            if (!cart || !cart.robotArm || !cart.robotArm.gripperGroup) {
                return new THREE.Vector3(0, 0, 0);
            }
            
            const tipMarker = cart.robotArm.gripperGroup.tipMarker;
            if (!tipMarker) {
                return new THREE.Vector3(0, 0, 0);
            }
            
            const worldPos = new THREE.Vector3();
            tipMarker.getWorldPosition(worldPos);
            return worldPos;
        }
        
        // ========================================================================
        // é€†è¿åŠ¨å­¦è®¡ç®—ï¼ˆåŸºäºå®æµ‹æ•°æ®æ”¹è¿›ï¼‰
        // ========================================================================
        
        // ç”¨æˆ·å®æµ‹çš„æ‹”è‰å§¿æ€æ•°æ®ï¼ˆè‰é«˜åº¦0.01mï¼Œè·ç¦»çº¦0.5-0.7mï¼‰
        const CALIBRATION_DATA = {
            shoulder: 15 * Math.PI / 180,   // 0.2618 rad
            elbow: -60 * Math.PI / 180,     // -1.0472 rad
            wrist: -29 * Math.PI / 180,     // -0.5061 rad
            referenceDistance: 0.6,         // å‡è®¾å‚è€ƒè·ç¦»
            referenceHeight: 0.01           // è‰é¡¶éƒ¨é«˜åº¦
        };
        
        // ç”¨æˆ·å®æµ‹çš„æ’­ç§å§¿æ€æ•°æ®ï¼ˆæœ€å¥½çœ‹çš„æ’­ç§å§¿æ€ï¼‰
        const PLANTING_POSE = {
            shoulder: 75 * Math.PI / 180,   // 1.3090 rad
            elbow: -111 * Math.PI / 180,    // -1.9373 rad
            wrist: 22 * Math.PI / 180       // 0.3840 rad
        };
        
        function calculateArmAngles(targetDist, targetHeight) {
            // æœºæ¢°è‡‚å‚æ•°ï¼ˆä¸åˆ›å»ºæ—¶ä¸€è‡´ï¼‰
            const L1 = 0.10;  // åº•åº§é«˜åº¦
            const L2 = 0.30;  // å¤§è‡‚é•¿åº¦
            const L3 = 0.25;  // å°è‡‚é•¿åº¦
            const L4 = 0.15;  // æœ«ç«¯æ‰§è¡Œå™¨é•¿åº¦ï¼ˆæ°´å¹³å»¶ä¼¸ï¼‰
            const L5 = 0.065; // æŠ“æ‰‹æœ«ç«¯åˆ°æŠ“æ‰‹åŸºåº§çš„è·ç¦»ï¼ˆå‚ç›´å»¶ä¼¸ï¼‰
            
            // æ–¹æ³•1: åŸå§‹IKç®—æ³•ï¼ˆä¿ç•™ç”¨äºå¯¹æ¯”ï¼‰
            const heightFromShoulder = targetHeight + L5 - L1;
            const wristDist = targetDist - L4;
            const d = Math.sqrt(wristDist * wristDist + heightFromShoulder * heightFromShoulder);
            
            console.log(`    IKè®¡ç®—: targetDist=${targetDist.toFixed(3)}, targetHeight=${targetHeight.toFixed(3)}, heightFromShoulder=${heightFromShoulder.toFixed(3)}, wristDist=${wristDist.toFixed(3)}, d=${d.toFixed(3)}`);
            
            // æ£€æŸ¥æ˜¯å¦å¯è¾¾
            if (d > L2 + L3 || d < Math.abs(L2 - L3)) {
                console.warn(`    âš ï¸ ç›®æ ‡ä¸å¯è¾¾! d=${d.toFixed(3)}, L2+L3=${(L2+L3).toFixed(3)}`);
            }
            
            // ä½™å¼¦å®šç†è®¡ç®—è‚˜å…³èŠ‚è§’åº¦
            const cosElbow = (L2 * L2 + L3 * L3 - d * d) / (2 * L2 * L3);
            const elbowTheory = -Math.acos(Math.max(-1, Math.min(1, cosElbow)));
            
            // è®¡ç®—è‚©å…³èŠ‚è§’åº¦
            const alpha = Math.atan2(heightFromShoulder, wristDist);
            const cosBeta = (L2 * L2 + d * d - L3 * L3) / (2 * L2 * d);
            const beta = Math.acos(Math.max(-1, Math.min(1, cosBeta)));
            const shoulderTheory = alpha + beta;
            
            // è…•å…³èŠ‚è§’åº¦ï¼ˆç†è®ºå€¼ï¼‰
            const wristTheory = -(shoulderTheory + elbowTheory);
            
            console.log(`    ç†è®ºIK: shoulder=${(shoulderTheory*180/Math.PI).toFixed(1)}Â°, elbow=${(elbowTheory*180/Math.PI).toFixed(1)}Â°, wrist=${(wristTheory*180/Math.PI).toFixed(1)}Â°`);
            
            // æ–¹æ³•2: åŸºäºå®æµ‹æ•°æ®çš„æ ¡æ­£ï¼ˆå¦‚æœç›®æ ‡æ˜¯è‰é«˜åº¦0.01mï¼‰
            if (Math.abs(targetHeight - CALIBRATION_DATA.referenceHeight) < 0.005) {
                // ä½¿ç”¨å®æµ‹æ•°æ®ä½œä¸ºåŸºå‡†
                console.log(`    âœ¨ ä½¿ç”¨å®æµ‹æ ¡å‡†æ•°æ®: shoulder=15Â°, elbow=-60Â°, wrist=-29Â°`);
                return {
                    shoulder: CALIBRATION_DATA.shoulder,
                    elbow: CALIBRATION_DATA.elbow,
                    wrist: CALIBRATION_DATA.wrist
                };
            }
            
            // å…¶ä»–é«˜åº¦ä»ä½¿ç”¨ç†è®ºIK
            console.log(`    ä½¿ç”¨ç†è®ºIK (ç›®æ ‡é«˜åº¦${targetHeight.toFixed(3)}mä¸æ˜¯æ ‡å‡†è‰é«˜åº¦)`);
            return { shoulder: shoulderTheory, elbow: elbowTheory, wrist: wristTheory };
        }
        
        // ========================================================================
        // æ‹”è‰åŠ¨ä½œ
        // ========================================================================
        
        async function pullGrassAction(row, col) {
            console.log(`ğŸŒ± å¼€å§‹æ‹”è‰: [${row},${col}]`);
            
            const grass = grassArray[row][col];
            if (!grass || grass.userData.isPulled) return;
            
            // ä¿å­˜è‰çš„åŸå§‹çŠ¶æ€
            const originalPos = grass.position.clone();
            const originalScale = grass.scale.clone();
            
            // è®¡ç®—è‰åœ¨å°è½¦åæ ‡ç³»ä¸­çš„ä½ç½®
            const grassWorldPos = grass.position;
            const cartWorldPos = cart.position;
            const grassRelativeX = grassWorldPos.x - cartWorldPos.x;
            const grassRelativeZ = grassWorldPos.z - cartWorldPos.z;
            
            // è‰çš„é«˜åº¦ï¼ˆè‰çš„ä¸­å¿ƒç‚¹åœ¨Y=grassHeight/2çš„ä½ç½®ï¼‰
            const grassHeight = 0.01;
            const grassTopY = grassHeight;  // è‰é¡¶éƒ¨çš„Yåæ ‡
            
            console.log(`  è‰çš„ä½ç½®: ä¸–ç•Œåæ ‡(${grassWorldPos.x.toFixed(2)}, ${grassWorldPos.z.toFixed(2)}), ç›¸å¯¹å°è½¦(${grassRelativeX.toFixed(2)}, ${grassRelativeZ.toFixed(2)})`);
            console.log(`  è‰é¡¶éƒ¨é«˜åº¦=${grassTopY.toFixed(3)}m`);
            
            // ä½¿ç”¨é€†è¿åŠ¨å­¦è®¡ç®—ç²¾ç¡®è§’åº¦
            const targetDistance = Math.sqrt(grassRelativeX * grassRelativeX + grassRelativeZ * grassRelativeZ);
            console.log(`  ç›®æ ‡è·ç¦»: ${targetDistance.toFixed(3)}m`);
            
            // è®¡ç®—åˆ°è¾¾è‰ä¸Šæ–¹çš„è§’åº¦ï¼ˆæ‚¬åœä½ç½®ï¼Œé«˜ä¸€ç‚¹ï¼‰
            const hoverAngles = calculateArmAngles(targetDistance, grassTopY + 0.05);
            console.log(`  æ‚¬åœè§’åº¦: shoulder=${(hoverAngles.shoulder * 180 / Math.PI).toFixed(1)}Â°, elbow=${(hoverAngles.elbow * 180 / Math.PI).toFixed(1)}Â°, wrist=${(hoverAngles.wrist * 180 / Math.PI).toFixed(1)}Â°`);
            
            // è®¡ç®—åˆ°è¾¾è‰ä½ç½®çš„è§’åº¦ï¼ˆæ¥è§¦ä½ç½® - æŠ“æ‰‹æœ«ç«¯åº”è¯¥åœ¨è‰é¡¶éƒ¨ï¼‰
            const grassAngles = calculateArmAngles(targetDistance, grassTopY);
            console.log(`  æ¥è§¦è§’åº¦: shoulder=${(grassAngles.shoulder * 180 / Math.PI).toFixed(1)}Â°, elbow=${(grassAngles.elbow * 180 / Math.PI).toFixed(1)}Â°, wrist=${(grassAngles.wrist * 180 / Math.PI).toFixed(1)}Â°`);
            
            // 1. æ‰“å¼€æŠ“æ‰‹å‡†å¤‡
            console.log('  ğŸ‘ æ‰“å¼€æŠ“æ‰‹...');
            await setGripperOpen(true, 0.3);
            await sleep(200);
            
            // 2. æœºæ¢°è‡‚ä¸‹é™åˆ°è‰ä¸Šæ–¹ï¼ˆæ‚¬åœï¼‰- ä½¿ç”¨é€†è¿åŠ¨å­¦è®¡ç®—çš„è§’åº¦
            console.log('  â¬‡ï¸ ä¸‹é™åˆ°è‰ä¸Šæ–¹...');
            await setArmJoints(hoverAngles.shoulder, hoverAngles.elbow, hoverAngles.wrist, 0.6);
            await sleep(300);
            
            // 3. ç»§ç»­ä¸‹é™ï¼Œæ¥è§¦è‰ - ä½¿ç”¨é€†è¿åŠ¨å­¦è®¡ç®—çš„ç²¾ç¡®è§’åº¦
            console.log('  ğŸ“ å¯¹å‡†è‰ï¼ˆç²¾ç¡®æ¥è§¦ï¼‰...');
            await setArmJoints(grassAngles.shoulder, grassAngles.elbow, grassAngles.wrist, 0.5);
            await sleep(200);
            
            // éªŒè¯ï¼šæ‰“å°æŠ“æ‰‹æœ«ç«¯çš„å®é™…ä½ç½®
            const tipPos = getGripperTipWorldPosition();
            console.log(`  ğŸ”´ æŠ“æ‰‹æœ«ç«¯å®é™…ä½ç½®: (${tipPos.x.toFixed(3)}, ${tipPos.y.toFixed(3)}, ${tipPos.z.toFixed(3)})`);
            console.log(`  ğŸŒ¿ è‰çš„å®é™…ä½ç½®: (${grassWorldPos.x.toFixed(3)}, ${grassWorldPos.y.toFixed(3)}, ${grassWorldPos.z.toFixed(3)})`);
            console.log(`  ğŸ“ è·ç¦»å·®: X=${(tipPos.x - grassWorldPos.x).toFixed(3)}, Y=${(tipPos.y - grassWorldPos.y).toFixed(3)}, Z=${(tipPos.z - grassWorldPos.z).toFixed(3)}`);
            
            // 4. é—­åˆæŠ“æ‰‹ï¼ˆå¤¹ä½è‰ï¼‰
            console.log('  ğŸ¤ å¤¹ä½è‰...');
            await setGripperOpen(false, 0.4);
            
            // è‰è¢«å¤¹ä½åå˜çª„
            grass.scale.x *= 0.7;
            grass.scale.z *= 0.7;
            await sleep(300);
            
            // 5. ç¼“æ…¢å‘ä¸Šæ‹”èµ·ï¼ˆè‰è·Ÿéšæœºæ¢°è‡‚ä¸Šå‡ï¼‰
            console.log('  â¬†ï¸ æ‹”èµ·è‰ï¼ˆç”¨åŠ›æ‹‰ï¼‰...');
            
            // å°†è‰é™„åŠ åˆ°æŠ“æ‰‹ä¸Šï¼ˆè¿™æ ·è‰ä¼šè·ŸéšæŠ“æ‰‹ç§»åŠ¨ï¼‰
            // è·å–æŠ“æ‰‹æœ«ç«¯ï¼ˆtipMarkerï¼‰çš„ä¸–ç•Œä½ç½®ä½œä¸ºå‚è€ƒç‚¹
            const gripperTipPos = getGripperTipWorldPosition();
            
            // ä¿å­˜è‰ç›¸å¯¹äºæŠ“æ‰‹æœ«ç«¯çš„åˆå§‹åç§»
            const grassOffset = new THREE.Vector3(
                grass.position.x - gripperTipPos.x,
                grass.position.y - gripperTipPos.y,
                grass.position.z - gripperTipPos.z
            );
            
            console.log(`  è‰åç§»é‡: (${grassOffset.x.toFixed(3)}, ${grassOffset.y.toFixed(3)}, ${grassOffset.z.toFixed(3)})`);
            
            const pullSteps = 20;
            const arm = cart.robotArm;
            const pullStartShoulder = arm.shoulderJoint.rotation.z;
            const pullStartElbow = arm.elbowJoint.rotation.z;
            const pullStartWrist = arm.wristJoint.rotation.z;
            
            for (let i = 0; i < pullSteps; i++) {
                const progress = i / pullSteps;
                const smooth = easeInOutCubic(progress);
                
                // æœºæ¢°è‡‚é€æ¸ä¸Šå‡ï¼ˆåªæŠ¬é«˜è‚©å…³èŠ‚ï¼Œå…¶ä»–å…³èŠ‚ä¿æŒä¸å˜ï¼Œç¡®ä¿åªå‘ä¸Šï¼‰
                arm.shoulderJoint.rotation.z = pullStartShoulder + smooth * Math.PI / 4;  // å¢åŠ 45åº¦ï¼Œå‘ä¸ŠæŠ¬èµ·
                // è‚˜å…³èŠ‚å’Œè…•å…³èŠ‚ä¿æŒä¸å˜ï¼Œé¿å…ä»»ä½•å‘ä¸‹çš„å¯èƒ½
                // arm.elbowJoint.rotation.z ä¿æŒ pullStartElbow
                // arm.wristJoint.rotation.z ä¿æŒ pullStartWrist
                
                // è‰è·ŸéšæŠ“æ‰‹æœ«ç«¯ç§»åŠ¨ï¼ˆè·å–æŠ“æ‰‹æœ«ç«¯çš„ä¸–ç•Œåæ ‡ï¼‰
                const currentTipPos = getGripperTipWorldPosition();
                grass.position.x = currentTipPos.x + grassOffset.x;
                grass.position.y = currentTipPos.y + grassOffset.y;
                grass.position.z = currentTipPos.z + grassOffset.z;
                
                // è‰åœ¨æ‹”èµ·æ—¶è½»å¾®æ‘‡æ™ƒ
                grass.rotation.z = Math.sin(progress * Math.PI * 6) * 0.15;
                grass.rotation.x = Math.sin(progress * Math.PI * 4) * 0.1;
                
                await sleep(30);
            }
            
            await sleep(300);
            
            // 6. æ‰“å¼€æŠ“æ‰‹ï¼ˆè‰æ‰è½ï¼‰
            console.log('  ğŸ—‘ï¸ æ‰”æ‰è‰...');
            await setGripperOpen(true, 0.3);
            
            // è‰æ‰è½åŠ¨ç”»ï¼ˆæ—‹è½¬+ä¸‹è½ï¼‰
            const fallSteps = 15;
            const dropStartY = grass.position.y;
            for (let i = 0; i < fallSteps; i++) {
                const progress = i / fallSteps;
                grass.position.y = dropStartY - progress * progress * 0.3; // åŠ é€Ÿä¸‹è½
                grass.rotation.x += 0.2; // æ—‹è½¬
                grass.rotation.z += 0.15;
                grass.scale.multiplyScalar(0.96); // é€æ¸å˜å°
                await sleep(30);
            }
            
            // å®Œå…¨æ¶ˆå¤±
            grass.visible = false;
            grass.userData.isPulled = true;
            
            await sleep(200);
            
            // 7. æœºæ¢°è‡‚è¿”å›åˆå§‹å§¿æ€ï¼ˆå‡†å¤‡æ’­ç§ï¼‰
            console.log('  â†©ï¸ æœºæ¢°è‡‚è¿”å›åˆå§‹å§¿æ€...');
            const returnSteps = 20;
            const returnStartShoulder = arm.shoulderJoint.rotation.z;
            const returnStartElbow = arm.elbowJoint.rotation.z;
            const returnStartWrist = arm.wristJoint.rotation.z;
            
            // è¿”å›åˆ°åˆå§‹å§¿æ€ï¼ˆå‚ç›´å‘ä¸Šï¼‰
            const returnTargetShoulder = 0;
            const returnTargetElbow = 0;
            const returnTargetWrist = 0;
            
            for (let i = 0; i < returnSteps; i++) {
                const progress = i / returnSteps;
                const smooth = easeInOutCubic(progress);
                
                arm.shoulderJoint.rotation.z = returnStartShoulder + smooth * (returnTargetShoulder - returnStartShoulder);
                arm.elbowJoint.rotation.z = returnStartElbow + smooth * (returnTargetElbow - returnStartElbow);
                arm.wristJoint.rotation.z = returnStartWrist + smooth * (returnTargetWrist - returnStartWrist);
                
                await sleep(25);
            }
            
            await sleep(200);
            
            console.log(`   âœ… æ‹”è‰å®Œæˆ`);
        }
        
        // ========================================================================
        // æ’­ç§åŠ¨ä½œ
        // ========================================================================
        
        function createSeed() {
            const seedGroup = new THREE.Group();
            
            // ç§å­ä¸»ä½“ï¼ˆå°çƒï¼‰
            const seedGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const seedMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,  // æ£•è‰²
                roughness: 0.7
            });
            const seedMesh = new THREE.Mesh(seedGeometry, seedMaterial);
            seedMesh.castShadow = true;
            seedGroup.add(seedMesh);
            
            return seedGroup;
        }
        
        async function plantSeedAction(row, col) {
            console.log(`ğŸŒ¾ å¼€å§‹æ’­ç§: [${row},${col}]`);
            
            const cellSize = 0.5;
            const offsetX = -0.75;
            const offsetZ = -0.75;
            const targetX = offsetX + col * cellSize + cellSize / 2;
            const targetZ = offsetZ + row * cellSize + cellSize / 2;
            
            // 1. åˆ›å»ºç§å­
            const seed = createSeed();
            seed.visible = false; // å…ˆéšè—
            farm.add(seed);
            
            // 2. é—­åˆæŠ“æ‰‹ï¼ˆè£…ä½œæ‹¿ç€ç§å­ï¼‰
            console.log('  ğŸ¤ æ‹¿å¥½ç§å­...');
            await setGripperOpen(false, 0.3);
            await sleep(200);
            
            // 3. ç§»åŠ¨åˆ°æ’­ç§å§¿æ€ï¼ˆä½¿ç”¨å®æµ‹æœ€ä½³å§¿æ€ï¼‰
            console.log('  ğŸ“ ç§»åŠ¨åˆ°æ’­ç§ä½ç½®ï¼ˆå®æµ‹æœ€ä½³å§¿æ€: 75Â°, -111Â°, 22Â°ï¼‰...');
            await setArmJoints(PLANTING_POSE.shoulder, PLANTING_POSE.elbow, PLANTING_POSE.wrist, 0.8);
            await sleep(400);
            
            // 4. æ‰“å¼€æŠ“æ‰‹ï¼ˆé‡Šæ”¾ç§å­ï¼‰
            console.log('  ğŸŒ± é‡Šæ”¾ç§å­...');
            await setGripperOpen(true, 0.4);
            
            // ç§å­å‡ºç°å¹¶ä¸‹è½
            seed.visible = true;
            seed.position.set(targetX, 0.15, targetZ); // ä»é€‚å½“é«˜åº¦å¼€å§‹
            seed.scale.set(1, 1, 1);
            
            // ç§å­ä¸‹è½åŠ¨ç”»
            const dropSteps = 15;
            for (let i = 0; i < dropSteps; i++) {
                const progress = i / dropSteps;
                seed.position.y = 0.15 - progress * progress * 0.13; // åŠ é€Ÿä¸‹è½åˆ°0.02
                seed.rotation.x += 0.1;
                seed.rotation.z += 0.08;
                await sleep(30);
            }
            
            await sleep(200);
            
            // 5. ç§å­æ’å…¥åœŸå£¤åŠ¨ç”»
            console.log('  ğŸŒ ç§å­æ’å…¥åœŸå£¤...');
            for (let i = 0; i < 10; i++) {
                seed.position.y -= 0.002; // é€æ¸æ’å…¥
                seed.scale.y *= 0.95; // Yè½´å‹æ‰
                await sleep(40);
            }
            
            await sleep(200);
            
            // 6. æœºæ¢°è‡‚è¿”å›åˆå§‹å§¿æ€
            console.log('  â†©ï¸ æœºæ¢°è‡‚è¿”å›åˆå§‹å§¿æ€...');
            await setArmJoints(0, 0, 0, 0.6);
            await sleep(300);
            
            // 8. ç§å­å‘èŠ½ç”Ÿé•¿åŠ¨ç”»
            console.log('  ğŸŒ± ç§å­å‘èŠ½...');
            
            // åˆ›å»ºå¹¼è‹—
            const sprout = new THREE.Group();
            
            // å«©èŠ½èŒ
            const stemGeometry = new THREE.CylinderGeometry(0.002, 0.003, 0.03, 8);
            const stemMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,  // æµ…ç»¿è‰²
                roughness: 0.6
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.015;
            stem.castShadow = true;
            sprout.add(stem);
            
            // ä¸¤ç‰‡å«©å¶
            const leafGeometry = new THREE.CircleGeometry(0.008, 8);
            const leafMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7CFC00,  // é²œç»¿è‰²
                roughness: 0.5,
                side: THREE.DoubleSide
            });
            
            const leftLeaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leftLeaf.position.set(-0.006, 0.025, 0);
            leftLeaf.rotation.y = Math.PI / 6;
            leftLeaf.rotation.z = Math.PI / 4;
            leftLeaf.castShadow = true;
            sprout.add(leftLeaf);
            
            const rightLeaf = new THREE.Mesh(leafGeometry, leafMaterial);
            rightLeaf.position.set(0.006, 0.025, 0);
            rightLeaf.rotation.y = -Math.PI / 6;
            rightLeaf.rotation.z = -Math.PI / 4;
            rightLeaf.castShadow = true;
            sprout.add(rightLeaf);
            
            sprout.position.set(targetX, 0, targetZ);
            sprout.scale.set(0.1, 0.1, 0.1); // ä»å¾ˆå°å¼€å§‹
            sprout.visible = false;
            farm.add(sprout);
            seeds.push(sprout);
            
            // ç§å­å˜å°æ¶ˆå¤±ï¼Œå¹¼è‹—é•¿å‡º
            await sleep(200);
            
            const growSteps = 30;
            for (let i = 0; i < growSteps; i++) {
                const progress = i / growSteps;
                const smooth = easeInOutCubic(progress);
                
                // ç§å­é€æ¸ç¼©å°
                seed.scale.multiplyScalar(0.95);
                
                // å¹¼è‹—é€æ¸é•¿å‡º
                if (i === 10) {
                    seed.visible = false; // ç§å­æ¶ˆå¤±
                    sprout.visible = true; // å¹¼è‹—å‡ºç°
                }
                
                if (sprout.visible) {
                    sprout.scale.set(
                        0.1 + smooth * 0.9,
                        0.1 + smooth * 0.9,
                        0.1 + smooth * 0.9
                    );
                    
                    // å¶å­å¾®å¾®æ‘†åŠ¨
                    leftLeaf.rotation.z = Math.PI / 4 + Math.sin(progress * Math.PI * 2) * 0.1;
                    rightLeaf.rotation.z = -Math.PI / 4 - Math.sin(progress * Math.PI * 2) * 0.1;
                }
                
                await sleep(40);
            }
            
            await sleep(300);
            
            console.log(`   âœ… æ’­ç§å®Œæˆï¼Œå¹¼è‹—å·²é•¿å‡º`);
        }
        
        // ========================================================================
        // æ‰‹åŠ¨æ§åˆ¶åŠŸèƒ½
        // ========================================================================
        
        // åˆ‡æ¢æ‰‹åŠ¨æ§åˆ¶é¢æ¿
        function toggleManualControl() {
            const panel = document.getElementById('manualControl');
            manualMode = !manualMode;
            panel.style.display = manualMode ? 'block' : 'none';
            
            if (manualMode) {
                // åœæ­¢è‡ªåŠ¨æµ‹è¯•
                stopTest();
                // åŒæ­¥å½“å‰çŠ¶æ€åˆ°æ»‘å—
                syncSlidersToCurrentState();
                // æ›´æ–°ä½ç½®ä¿¡æ¯
                updatePositionInfo();
                console.log('ğŸ® è¿›å…¥æ‰‹åŠ¨æ§åˆ¶æ¨¡å¼');
            } else {
                console.log('ğŸ® é€€å‡ºæ‰‹åŠ¨æ§åˆ¶æ¨¡å¼');
            }
        }
        
        // åŒæ­¥æ»‘å—åˆ°å½“å‰çŠ¶æ€
        function syncSlidersToCurrentState() {
            if (!cart || !cart.robotArm) return;
            
            // å°è½¦ä½ç½®
            document.getElementById('cartX').value = cart.position.x.toFixed(2);
            document.getElementById('cartZ').value = cart.position.z.toFixed(2);
            document.getElementById('cartXValue').textContent = cart.position.x.toFixed(2);
            document.getElementById('cartZValue').textContent = cart.position.z.toFixed(2);
            
            // æœºæ¢°è‡‚è§’åº¦ï¼ˆè½¬æ¢ä¸ºåº¦æ•°ï¼‰
            const arm = cart.robotArm;
            const shoulderDeg = (arm.shoulderJoint.rotation.z * 180 / Math.PI).toFixed(0);
            const elbowDeg = (arm.elbowJoint.rotation.z * 180 / Math.PI).toFixed(0);
            const wristDeg = (arm.wristJoint.rotation.z * 180 / Math.PI).toFixed(0);
            
            document.getElementById('shoulder').value = shoulderDeg;
            document.getElementById('elbow').value = elbowDeg;
            document.getElementById('wrist').value = wristDeg;
            document.getElementById('shoulderValue').textContent = shoulderDeg + 'Â°';
            document.getElementById('elbowValue').textContent = elbowDeg + 'Â°';
            document.getElementById('wristValue').textContent = wristDeg + 'Â°';
            
            // æŠ“æ‰‹çŠ¶æ€
            const gripperOpen = arm.gripperGroup.isOpen ? 1 : 0;
            document.getElementById('gripper').value = gripperOpen;
            document.getElementById('gripperValue').textContent = gripperOpen ? 'æ‰“å¼€' : 'å…³é—­';
        }
        
        // æ›´æ–°å°è½¦ä½ç½®
        function updateCartPosition() {
            if (!cart) return;
            
            const x = parseFloat(document.getElementById('cartX').value);
            const z = parseFloat(document.getElementById('cartZ').value);
            
            cart.position.x = x;
            cart.position.z = z;
            
            document.getElementById('cartXValue').textContent = x.toFixed(2);
            document.getElementById('cartZValue').textContent = z.toFixed(2);
            document.getElementById('position').textContent = `(${x.toFixed(2)}, ${z.toFixed(2)})`;
            
            // å®æ—¶æ›´æ–°ä½ç½®ä¿¡æ¯
            updatePositionInfo();
        }
        
        // æ›´æ–°æœºæ¢°è‡‚è§’åº¦
        function updateArmAngles() {
            if (!cart || !cart.robotArm) return;
            
            const shoulderDeg = parseInt(document.getElementById('shoulder').value);
            const elbowDeg = parseInt(document.getElementById('elbow').value);
            const wristDeg = parseInt(document.getElementById('wrist').value);
            
            const arm = cart.robotArm;
            arm.shoulderJoint.rotation.z = shoulderDeg * Math.PI / 180;
            arm.elbowJoint.rotation.z = elbowDeg * Math.PI / 180;
            arm.wristJoint.rotation.z = wristDeg * Math.PI / 180;
            
            document.getElementById('shoulderValue').textContent = shoulderDeg + 'Â°';
            document.getElementById('elbowValue').textContent = elbowDeg + 'Â°';
            document.getElementById('wristValue').textContent = wristDeg + 'Â°';
            
            // å®æ—¶æ›´æ–°ä½ç½®ä¿¡æ¯
            updatePositionInfo();
        }
        
        // æ›´æ–°æŠ“æ‰‹çŠ¶æ€
        function updateGripper() {
            if (!cart || !cart.robotArm) return;
            
            const gripperOpen = parseInt(document.getElementById('gripper').value) === 1;
            const arm = cart.robotArm;
            
            if (gripperOpen) {
                arm.gripperGroup.leftFinger.position.z = 0.015;
                arm.gripperGroup.rightFinger.position.z = -0.015;
                arm.gripperGroup.isOpen = true;
                arm.gripperGroup.led.material.color.setHex(0x00FF00);
                arm.gripperGroup.led.material.emissive.setHex(0x00FF00);
            } else {
                arm.gripperGroup.leftFinger.position.z = 0.01;
                arm.gripperGroup.rightFinger.position.z = -0.01;
                arm.gripperGroup.isOpen = false;
                arm.gripperGroup.led.material.color.setHex(0xFF0000);
                arm.gripperGroup.led.material.emissive.setHex(0xFF0000);
            }
            
            document.getElementById('gripperValue').textContent = gripperOpen ? 'æ‰“å¼€' : 'å…³é—­';
        }
        
        // ç§»åˆ°è‰çš„ä½ç½®
        function moveToGrass() {
            if (!targetGrass) {
                alert('è¯·å…ˆé€‰æ‹©ç›®æ ‡è‰ï¼');
                return;
            }
            
            const grassPos = targetGrass.position;
            const row = Math.floor(targetGrassIndex / 4);
            const col = targetGrassIndex % 4;
            
            // è®¡ç®—å°è½¦åº”è¯¥åœé çš„ä½ç½®ï¼ˆå°è½¦åœ¨è‰çš„å·¦ä¾§ï¼‰
            const cartTargetX = grassPos.x - 0.45;
            const cartTargetZ = grassPos.z;
            
            document.getElementById('cartX').value = cartTargetX.toFixed(2);
            document.getElementById('cartZ').value = cartTargetZ.toFixed(2);
            updateCartPosition();
            
            console.log(`ğŸ“ å°è½¦ç§»åŠ¨åˆ°è‰ [${row},${col}] ä½ç½®: (${cartTargetX.toFixed(2)}, ${cartTargetZ.toFixed(2)})`);
        }
        
        // å›åˆ°åŸç‚¹
        function moveToOrigin() {
            document.getElementById('cartX').value = '-1.50';
            document.getElementById('cartZ').value = '-1.50';
            updateCartPosition();
            console.log('ğŸ  å°è½¦è¿”å›åŸç‚¹');
        }
        
        // é‡ç½®æœºæ¢°è‡‚å§¿æ€
        function resetArm() {
            document.getElementById('shoulder').value = '0';
            document.getElementById('elbow').value = '0';
            document.getElementById('wrist').value = '0';
            document.getElementById('gripper').value = '0';
            updateArmAngles();
            updateGripper();
            console.log('â†©ï¸ æœºæ¢°è‡‚é‡ç½®ä¸ºåˆå§‹å§¿æ€');
        }
        
        // è‡ªåŠ¨å¯¹é½è‰ï¼ˆä½¿ç”¨IKï¼‰
        function autoAlignGrass() {
            if (!targetGrass) {
                alert('è¯·å…ˆé€‰æ‹©ç›®æ ‡è‰ï¼');
                return;
            }
            
            const grassPos = targetGrass.position;
            const cartPos = cart.position;
            
            // è®¡ç®—è‰ç›¸å¯¹äºå°è½¦çš„ä½ç½®
            const relativeX = grassPos.x - cartPos.x;
            const relativeZ = grassPos.z - cartPos.z;
            const targetDistance = Math.sqrt(relativeX * relativeX + relativeZ * relativeZ);
            const grassTopY = 0.01;
            
            // ä½¿ç”¨IKè®¡ç®—è§’åº¦
            const angles = calculateArmAngles(targetDistance, grassTopY);
            
            // è®¾ç½®æ»‘å—å€¼ï¼ˆè½¬æ¢ä¸ºåº¦æ•°ï¼‰
            document.getElementById('shoulder').value = (angles.shoulder * 180 / Math.PI).toFixed(0);
            document.getElementById('elbow').value = (angles.elbow * 180 / Math.PI).toFixed(0);
            document.getElementById('wrist').value = (angles.wrist * 180 / Math.PI).toFixed(0);
            updateArmAngles();
            
            console.log('ğŸ¯ è‡ªåŠ¨å¯¹é½è‰ä½ç½®å®Œæˆ');
            updatePositionInfo();
        }
        
        // é€‰æ‹©ç›®æ ‡è‰
        function selectTargetGrass() {
            targetGrassIndex = (targetGrassIndex + 1) % 16;
            const row = Math.floor(targetGrassIndex / 4);
            const col = targetGrassIndex % 4;
            targetGrass = grassArray[row][col];
            
            console.log(`ğŸŒ± é€‰æ‹©ç›®æ ‡è‰: [${row},${col}] ä½ç½®(${targetGrass.position.x.toFixed(2)}, ${targetGrass.position.z.toFixed(2)})`);
            updatePositionInfo();
        }
        
        // æ›´æ–°ä½ç½®ä¿¡æ¯æ˜¾ç¤º
        function updatePositionInfo() {
            if (!cart || !cart.robotArm) return;
            
            const tipPos = getGripperTipWorldPosition();
            let infoHTML = `<strong>æŠ“æ‰‹æœ«ç«¯:</strong> (${tipPos.x.toFixed(3)}, ${tipPos.y.toFixed(3)}, ${tipPos.z.toFixed(3)})<br>`;
            
            if (targetGrass) {
                const row = Math.floor(targetGrassIndex / 4);
                const col = targetGrassIndex % 4;
                const grassPos = targetGrass.position;
                
                const dx = tipPos.x - grassPos.x;
                const dy = tipPos.y - grassPos.y;
                const dz = tipPos.z - grassPos.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                infoHTML += `<strong>ç›®æ ‡è‰ [${row},${col}]:</strong> (${grassPos.x.toFixed(3)}, ${grassPos.y.toFixed(3)}, ${grassPos.z.toFixed(3)})<br>`;
                infoHTML += `<strong>è·ç¦»å·®:</strong> X=${dx.toFixed(3)}, Y=${dy.toFixed(3)}, Z=${dz.toFixed(3)}<br>`;
                infoHTML += `<strong>æ€»è·ç¦»:</strong> ${distance.toFixed(3)}m`;
                
                // å¦‚æœè·ç¦»å¾ˆå°ï¼Œé«˜äº®æ˜¾ç¤º
                if (distance < 0.01) {
                    infoHTML += ` <span style="color: #28a745; font-weight: bold;">âœ… ç²¾ç¡®å¯¹é½!</span>`;
                } else if (distance < 0.05) {
                    infoHTML += ` <span style="color: #ffc107; font-weight: bold;">âš ï¸ æ¥è¿‘</span>`;
                }
            } else {
                infoHTML += `<strong>ç›®æ ‡è‰:</strong> æœªé€‰æ‹©ï¼ˆç‚¹å‡»"é€‰æ‹©ç›®æ ‡è‰"æŒ‰é’®ï¼‰<br>`;
                infoHTML += `<strong>è·ç¦»å·®:</strong> -`;
            }
            
            document.getElementById('positionInfo').innerHTML = infoHTML;
        }
        
        // è®°å½•å½“å‰çŠ¶æ€
        function recordCurrentState() {
            if (!cart || !cart.robotArm) return;
            
            const arm = cart.robotArm;
            const tipPos = getGripperTipWorldPosition();
            
            const state = {
                timestamp: new Date().toLocaleTimeString(),
                cart: {
                    x: cart.position.x,
                    z: cart.position.z
                },
                arm: {
                    shoulder: arm.shoulderJoint.rotation.z,
                    elbow: arm.elbowJoint.rotation.z,
                    wrist: arm.wristJoint.rotation.z
                },
                armDegrees: {
                    shoulder: (arm.shoulderJoint.rotation.z * 180 / Math.PI).toFixed(1),
                    elbow: (arm.elbowJoint.rotation.z * 180 / Math.PI).toFixed(1),
                    wrist: (arm.wristJoint.rotation.z * 180 / Math.PI).toFixed(1)
                },
                gripperTip: {
                    x: tipPos.x,
                    y: tipPos.y,
                    z: tipPos.z
                },
                gripperOpen: arm.gripperGroup.isOpen,
                targetGrass: targetGrass ? {
                    index: targetGrassIndex,
                    row: Math.floor(targetGrassIndex / 4),
                    col: targetGrassIndex % 4,
                    position: {
                        x: targetGrass.position.x,
                        y: targetGrass.position.y,
                        z: targetGrass.position.z
                    }
                } : null
            };
            
            stateRecords.push(state);
            console.log('ğŸ“¸ çŠ¶æ€å·²è®°å½•:', state);
            
            // æ›´æ–°è®°å½•åˆ—è¡¨æ˜¾ç¤º
            updateRecordsList();
            
            alert(`âœ… çŠ¶æ€å·²è®°å½•ï¼å…±${stateRecords.length}æ¡è®°å½•`);
        }
        
        // æ›´æ–°è®°å½•åˆ—è¡¨æ˜¾ç¤º
        function updateRecordsList() {
            const listDiv = document.getElementById('recordsList');
            if (stateRecords.length === 0) {
                listDiv.innerHTML = '<div style="text-align: center; color: #999; padding: 10px;">æš‚æ— è®°å½•</div>';
                return;
            }
            
            let html = '';
            stateRecords.forEach((record, index) => {
                const targetInfo = record.targetGrass ? 
                    `è‰[${record.targetGrass.row},${record.targetGrass.col}]` : 'æ— ç›®æ ‡';
                html += `
                    <div class="record-item" onclick="loadRecord(${index})" title="ç‚¹å‡»åŠ è½½æ­¤çŠ¶æ€">
                        <strong>#${index + 1}</strong> ${record.timestamp}<br>
                        <small>å°è½¦: (${record.cart.x.toFixed(2)}, ${record.cart.z.toFixed(2)})</small><br>
                        <small>è‚©:${record.armDegrees.shoulder}Â° è‚˜:${record.armDegrees.elbow}Â° è…•:${record.armDegrees.wrist}Â°</small><br>
                        <small>ç›®æ ‡: ${targetInfo}</small>
                    </div>
                `;
            });
            
            listDiv.innerHTML = html;
        }
        
        // åŠ è½½è®°å½•çš„çŠ¶æ€
        function loadRecord(index) {
            const record = stateRecords[index];
            if (!record) return;
            
            // åŠ è½½å°è½¦ä½ç½®
            document.getElementById('cartX').value = record.cart.x.toFixed(2);
            document.getElementById('cartZ').value = record.cart.z.toFixed(2);
            updateCartPosition();
            
            // åŠ è½½æœºæ¢°è‡‚è§’åº¦
            document.getElementById('shoulder').value = record.armDegrees.shoulder;
            document.getElementById('elbow').value = record.armDegrees.elbow;
            document.getElementById('wrist').value = record.armDegrees.wrist;
            updateArmAngles();
            
            // åŠ è½½æŠ“æ‰‹çŠ¶æ€
            document.getElementById('gripper').value = record.gripperOpen ? 1 : 0;
            updateGripper();
            
            // åŠ è½½ç›®æ ‡è‰
            if (record.targetGrass) {
                targetGrassIndex = record.targetGrass.index;
                const row = record.targetGrass.row;
                const col = record.targetGrass.col;
                targetGrass = grassArray[row][col];
            }
            
            updatePositionInfo();
            
            console.log(`âœ… å·²åŠ è½½è®°å½• #${index + 1}`);
        }
        
        // å¯¼å‡ºæ‰€æœ‰è®°å½•
        function exportRecords() {
            if (stateRecords.length === 0) {
                alert('æš‚æ— è®°å½•å¯å¯¼å‡ºï¼');
                return;
            }
            
            // åˆ›å»ºæ ¼å¼åŒ–çš„æ–‡æœ¬
            let exportText = '========================================\n';
            exportText += 'æœºæ¢°è‡‚çŠ¶æ€è®°å½•å¯¼å‡º\n';
            exportText += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
            exportText += `è®°å½•æ•°é‡: ${stateRecords.length}\n`;
            exportText += '========================================\n\n';
            
            stateRecords.forEach((record, index) => {
                exportText += `è®°å½• #${index + 1} - ${record.timestamp}\n`;
                exportText += `----------------------------------------\n`;
                exportText += `å°è½¦ä½ç½®:\n`;
                exportText += `  X = ${record.cart.x.toFixed(3)}\n`;
                exportText += `  Z = ${record.cart.z.toFixed(3)}\n\n`;
                
                exportText += `æœºæ¢°è‡‚è§’åº¦ (å¼§åº¦):\n`;
                exportText += `  shoulder = ${record.arm.shoulder.toFixed(6)}\n`;
                exportText += `  elbow = ${record.arm.elbow.toFixed(6)}\n`;
                exportText += `  wrist = ${record.arm.wrist.toFixed(6)}\n\n`;
                
                exportText += `æœºæ¢°è‡‚è§’åº¦ (åº¦æ•°):\n`;
                exportText += `  shoulder = ${record.armDegrees.shoulder}Â°\n`;
                exportText += `  elbow = ${record.armDegrees.elbow}Â°\n`;
                exportText += `  wrist = ${record.armDegrees.wrist}Â°\n\n`;
                
                exportText += `æŠ“æ‰‹æœ«ç«¯ä½ç½®:\n`;
                exportText += `  X = ${record.gripperTip.x.toFixed(6)}\n`;
                exportText += `  Y = ${record.gripperTip.y.toFixed(6)}\n`;
                exportText += `  Z = ${record.gripperTip.z.toFixed(6)}\n\n`;
                
                exportText += `æŠ“æ‰‹çŠ¶æ€: ${record.gripperOpen ? 'æ‰“å¼€' : 'å…³é—­'}\n\n`;
                
                if (record.targetGrass) {
                    exportText += `ç›®æ ‡è‰:\n`;
                    exportText += `  ä½ç½®: [${record.targetGrass.row}, ${record.targetGrass.col}]\n`;
                    exportText += `  åæ ‡: (${record.targetGrass.position.x.toFixed(3)}, ${record.targetGrass.position.y.toFixed(3)}, ${record.targetGrass.position.z.toFixed(3)})\n\n`;
                    
                    const dx = record.gripperTip.x - record.targetGrass.position.x;
                    const dy = record.gripperTip.y - record.targetGrass.position.y;
                    const dz = record.gripperTip.z - record.targetGrass.position.z;
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    exportText += `è·ç¦»å·®:\n`;
                    exportText += `  Î”X = ${dx.toFixed(6)}\n`;
                    exportText += `  Î”Y = ${dy.toFixed(6)}\n`;
                    exportText += `  Î”Z = ${dz.toFixed(6)}\n`;
                    exportText += `  æ€»è·ç¦» = ${distance.toFixed(6)}\n`;
                }
                
                exportText += '\n========================================\n\n';
            });
            
            // ä¸‹è½½ä¸ºæ–‡æœ¬æ–‡ä»¶
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `robot_states_${new Date().getTime()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('ğŸ“¤ è®°å½•å·²å¯¼å‡º');
            alert(`âœ… å·²å¯¼å‡º ${stateRecords.length} æ¡è®°å½•ï¼`);
        }
        
        // æ¸…ç©ºè®°å½•
        function clearRecords() {
            if (stateRecords.length === 0) return;
            
            if (confirm(`ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ ${stateRecords.length} æ¡è®°å½•å—ï¼Ÿ`)) {
                stateRecords = [];
                updateRecordsList();
                console.log('ğŸ—‘ï¸ æ‰€æœ‰è®°å½•å·²æ¸…ç©º');
            }
        }
        
        // çª—å£è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ========================================================================
        // å•æ­¥æ§åˆ¶åŠŸèƒ½
        // ========================================================================
        
        function stepCartX(delta) {
            const slider = document.getElementById('cartX');
            let newValue = parseFloat(slider.value) + delta;
            newValue = Math.max(-1.5, Math.min(1.5, newValue)); // é™åˆ¶èŒƒå›´
            slider.value = newValue.toFixed(2);
            updateCartPosition();
        }
        
        function stepCartZ(delta) {
            const slider = document.getElementById('cartZ');
            let newValue = parseFloat(slider.value) + delta;
            newValue = Math.max(-1.5, Math.min(1.5, newValue)); // é™åˆ¶èŒƒå›´
            slider.value = newValue.toFixed(2);
            updateCartPosition();
        }
        
        function stepShoulder(delta) {
            const slider = document.getElementById('shoulder');
            let newValue = parseInt(slider.value) + delta;
            newValue = Math.max(-180, Math.min(180, newValue)); // é™åˆ¶èŒƒå›´
            slider.value = newValue;
            updateArmAngles();
        }
        
        function stepElbow(delta) {
            const slider = document.getElementById('elbow');
            let newValue = parseInt(slider.value) + delta;
            newValue = Math.max(-180, Math.min(180, newValue)); // é™åˆ¶èŒƒå›´
            slider.value = newValue;
            updateArmAngles();
        }
        
        function stepWrist(delta) {
            const slider = document.getElementById('wrist');
            let newValue = parseInt(slider.value) + delta;
            newValue = Math.max(-180, Math.min(180, newValue)); // é™åˆ¶èŒƒå›´
            slider.value = newValue;
            updateArmAngles();
        }
        
        function toggleGripper() {
            const slider = document.getElementById('gripper');
            slider.value = slider.value === '0' ? '1' : '0';
            updateGripper();
        }
        
        // ========================================================================
        // é¢æ¿æ”¶çº³åŠŸèƒ½
        // ========================================================================
        
        function toggleLeftPanel() {
            const panel = document.getElementById('controls');
            const btn = document.getElementById('toggleLeft');
            
            if (panel.classList.contains('collapsed')) {
                // å±•å¼€
                panel.classList.remove('collapsed');
                btn.textContent = 'â—€';
                btn.title = 'æ”¶çº³å·¦ä¾§é¢æ¿';
            } else {
                // æ”¶çº³
                panel.classList.add('collapsed');
                btn.textContent = 'â–¶';
                btn.title = 'å±•å¼€å·¦ä¾§é¢æ¿';
            }
        }
        
        function toggleRightPanel() {
            const panel = document.getElementById('manualControl');
            const btn = document.getElementById('toggleRight');
            
            // æ£€æŸ¥é¢æ¿æ˜¯å¦æ˜¾ç¤º
            const isHidden = panel.style.display === 'none' || !panel.style.display;
            
            if (isHidden) {
                // å¦‚æœæ‰‹åŠ¨æ§åˆ¶é¢æ¿æœ¬èº«æ˜¯éšè—çš„ï¼Œå…ˆæ˜¾ç¤ºå®ƒ
                panel.style.display = 'block';
                manualMode = true;
                syncSlidersToCurrentState();
                updatePositionInfo();
                btn.textContent = 'â–¶';
                btn.title = 'æ”¶çº³å³ä¾§é¢æ¿';
            } else if (panel.classList.contains('collapsed')) {
                // å±•å¼€
                panel.classList.remove('collapsed');
                btn.textContent = 'â–¶';
                btn.title = 'æ”¶çº³å³ä¾§é¢æ¿';
            } else {
                // æ”¶çº³
                panel.classList.add('collapsed');
                btn.textContent = 'â—€';
                btn.title = 'å±•å¼€å³ä¾§é¢æ¿';
            }
        }
        
        // å¯åŠ¨
        init();
    </script>
</body>
</html>

